On Wed, Nov 20, 2013 at 04:03:42PM -0800, Andrew Honig wrote:
> We've come across another bug.
> 
> A guest can cause a BUG_ON() leading to a host kernel crash (at least
> in my configuration).
> 
> When the guest writes to the ICR to request an IPI, while in x2apic
> mode the following things happen
> 
> // irc_high is read from a ICR2, which is a register that the guest can control
>                 irq.dest_id = icr_high;
> 
> This eventually makes its way to
> kvm_irq_delivery_to_apic_fast
> 
> which eventually does
> 629                 u32 mda = irq->dest_id << (32 - map->ldr_bits);
> 630
> 631                 dst = map->logical_map[apic_cluster_id(map, mda)];
> 
> If the apic is in x2apic mode than map->ldr_bits is 32 and mda is not
> shifted at all.
> 
> Then apic_cluster_id does the following:
> 151         u16 cid;
> 152         ldr >>= 32 - map->ldr_bits;
> 153         cid = (ldr >> map->cid_shift) & map->cid_mask;
> 154
> 155         BUG_ON(cid >= ARRAY_SIZE(map->logical_map));
> 
> When in x2apic mode ldr_bits is 32, cid_shift is 16, and cid_mask is 0xFFFF.
> 
> That means that cid assigned on line 153 is any 16 bit value of the
> guests choosing.  It's used as an index into a 16 element array.  The
> BUG_ON is triggered before anything really unsafe occurs.
> 
> I verified this by filtering the irq.dest_id and re-ran the malicious
> workload, but I have no idea what the right fix is, or what real
> hardware would do.
> 
The logic in the code is correct from real HW point of view. The problem
is that KVM supports only one cluster with ID 0 in clustered mode, but
the code that has the bug does not take this into account. Patch below
should solve the issue in the root (not tested):


diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 5439117..37089c8 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -143,6 +143,8 @@ static inline int kvm_apic_id(struct kvm_lapic *apic)
 	return (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;
 }
 
+#define KMV_X2APIC_CID_BITS 0
+
 static void recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
@@ -180,7 +182,8 @@ static void recalculate_apic_map(struct kvm *kvm)
 		if (apic_x2apic_mode(apic)) {
 			new->ldr_bits = 32;
 			new->cid_shift = 16;
-			new->cid_mask = new->lid_mask = 0xffff;
+			new->cid_mask = (1 << KMV_X2APIC_CID_BITS) - 1;
+			new->lid_mask = 0xffff;
 		} else if (kvm_apic_sw_enabled(apic) &&
 				!new->cid_mask /* flat mode */ &&
 				kvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {
--
			Gleb.
