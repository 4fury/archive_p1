diff -Nuar lightspark-0.7.2.orig/ChangeLog lightspark-0.7.2/ChangeLog
--- lightspark-0.7.2.orig/ChangeLog	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/ChangeLog	2013-11-09 19:23:31.000000000 +0200
@@ -1,5 +1,10 @@
 lightspark: An open source flash player implementation
 
+Version NEXT:
+
+	* Support embedded audio
+	* Implement JSON parsing
+
 Version 0.7.2:
 
 	* Improved image support: alpha in palettes, abbreviated JPEGs
diff -Nuar lightspark-0.7.2.orig/CMakeLists.txt lightspark-0.7.2/CMakeLists.txt
--- lightspark-0.7.2.orig/CMakeLists.txt	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/CMakeLists.txt	2013-11-09 19:23:31.000000000 +0200
@@ -287,12 +287,17 @@
 
 IF(ENABLE_LIBAVCODEC)
 	pkg_check_modules(FFMPEG libavcodec libavutil libavformat)
+	pkg_check_modules(LIBAVRESAMPLE libavresample)
 	IF(NOT(FFMPEG_FOUND))
 		INCLUDE(FindFFMpeg REQUIRED)
 	ENDIF(NOT(FFMPEG_FOUND))
 	# Compatibility checks for ffmpeg deprecated functions
   INCLUDE(CheckFunctionExists REQUIRED)
-  SET(CMAKE_REQUIRED_FLAGS ${LIBAVCODEC_CFLAGS})
+  INCLUDE(CheckCSourceCompiles)
+  SET(FFMPEG_FLAGS "${LIBAVCODEC_CFLAGS} ${LIBAVRESAMPLE_FLAGS}")
+  SET(FFMPEG_INCLUDE_DIRS "${FFMPEG_INCLUDE_DIRS} ${LIBAVRESAMPLE_INCLUDE_DIRS}")
+  SET(FFMPEG_LIBRARIES "${FFMPEG_LIBRARIES};${LIBAVRESAMPLE_LIBRARIES}")
+  SET(CMAKE_REQUIRED_FLAGS ${FFMPEG_FLAGS})
   SET(CMAKE_REQUIRED_INCLUDES ${FFMPEG_INCLUDE_DIRS})
   SET(CMAKE_REQUIRED_LIBRARIES ${FFMPEG_LIBRARIES})
   CHECK_FUNCTION_EXISTS(avcodec_decode_video2 HAVE_AVCODEC_DECODE_VIDEO2)
@@ -303,7 +308,8 @@
   CHECK_FUNCTION_EXISTS(avcodec_open2 HAVE_AVCODEC_OPEN2)
   CHECK_FUNCTION_EXISTS(avformat_close_input HAVE_AVFORMAT_CLOSE_INPUT)
   CHECK_FUNCTION_EXISTS(avformat_find_stream_info HAVE_AVFORMAT_FIND_STREAM_INFO)
-  
+  CHECK_C_SOURCE_COMPILES("#include <libavcodec/avcodec.h>\nint main() { enum AVCodecID c; return 0; }" HAVE_AVCODECID)
+
   SET(CMAKE_REQUIRED_FLAGS)
   SET(CMAKE_REQUIRED_INCLUDES)
   SET(CMAKE_REQUIRED_LIBRARIES)
@@ -331,6 +337,12 @@
   IF(HAVE_AVFORMAT_FIND_STREAM_INFO)
     ADD_DEFINITIONS(-DHAVE_AVFORMAT_FIND_STREAM_INFO)
   ENDIF(HAVE_AVFORMAT_FIND_STREAM_INFO)
+  IF(HAVE_AVCODECID)
+    ADD_DEFINITIONS(-DHAVE_AVCODECID)
+  ENDIF(HAVE_AVCODECID)
+  IF(LIBAVRESAMPLE_FOUND)
+    ADD_DEFINITIONS(-DHAVE_LIBAVRESAMPLE)
+  ENDIF(LIBAVRESAMPLE_FOUND)
   ADD_DEFINITIONS(-DENABLE_LIBAVCODEC)
 ENDIF(ENABLE_LIBAVCODEC)
 
diff -Nuar lightspark-0.7.2.orig/conf/FindFFMpeg.cmake lightspark-0.7.2/conf/FindFFMpeg.cmake
--- lightspark-0.7.2.orig/conf/FindFFMpeg.cmake	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/conf/FindFFMpeg.cmake	2013-11-09 19:23:31.000000000 +0200
@@ -23,7 +23,11 @@
     avformat
 )
 
-SET(FFMPEG_LIBRARY ${FFMPEG_AVCODEC_LIBRARY} ${FFMPEG_AVUTIL_LIBRARY} ${FFMPEG_AVFORMAT_LIBRARY})
+FIND_LIBRARY(FFMPEG_AVRESAMPLE_LIBRARY NAMES
+    avresample
+)
+
+SET(FFMPEG_LIBRARY ${FFMPEG_AVCODEC_LIBRARY} ${FFMPEG_AVUTIL_LIBRARY} ${FFMPEG_AVFORMAT_LIBRARY} ${FFMPEG_AVRESAMPLE_LIBRARY})
 MARK_AS_ADVANCED(FFMPEG_LIBRARY)
 
 # handle the QUIETLY and REQUIRED arguments and set FFMPEG_FOUND to TRUE if 
diff -Nuar lightspark-0.7.2.orig/conf/FindLLVM.cmake lightspark-0.7.2/conf/FindLLVM.cmake
--- lightspark-0.7.2.orig/conf/FindLLVM.cmake	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/conf/FindLLVM.cmake	2013-11-09 19:23:31.000000000 +0200
@@ -51,6 +51,9 @@
     /usr/lib/llvm-2.8/bin
     /usr/lib/llvm-2.9/bin
     /usr/lib/llvm-3.0/bin
+    /usr/lib/llvm-3.1/bin
+    /usr/lib/llvm-3.2/bin
+    /usr/lib/llvm-3.3/bin
     )
 
   find_program(LLVM_GCC_EXECUTABLE
@@ -168,11 +171,16 @@
 
   set(CMAKE_REQUIRED_INCLUDES ${LLVM_INCLUDE_DIR})
   check_include_file_cxx("llvm/DataLayout.h" HAVE_DATALAYOUT_H)
+  check_include_file_cxx("llvm/IR/DataLayout.h" HAVE_IR_DATALAYOUT_H)
   unset(CMAKE_REQUIRED_INCLUDES)
   MESSAGE(STATUS "HAVE_DATALAYOUT_H: " ${HAVE_DATALAYOUT_H})
+  MESSAGE(STATUS "HAVE_IR_DATALAYOUT_H: " ${HAVE_IR_DATALAYOUT_H})
   IF(HAVE_DATALAYOUT_H)
     ADD_DEFINITIONS(-DHAVE_DATALAYOUT_H)
   ENDIF(HAVE_DATALAYOUT_H)
+  IF(HAVE_IR_DATALAYOUT_H)
+    ADD_DEFINITIONS(-DHAVE_IR_DATALAYOUT_H)
+  ENDIF(HAVE_IR_DATALAYOUT_H)
   
   exec_program(${LLVM_CONFIG_EXECUTABLE} ARGS --cxxflags  OUTPUT_VARIABLE LLVM_COMPILE_FLAGS )
   MESSAGE(STATUS "LLVM CXX flags: " ${LLVM_COMPILE_FLAGS})
diff -Nuar lightspark-0.7.2.orig/docs/man/lightspark.1 lightspark-0.7.2/docs/man/lightspark.1
--- lightspark-0.7.2.orig/docs/man/lightspark.1	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/docs/man/lightspark.1	2013-11-09 19:23:31.000000000 +0200
@@ -2,7 +2,7 @@
 .\" First parameter, NAME, should be all caps
 .\" Second parameter, SECTION, should be 1-8, maybe w/ subsection
 .\" other parameters are allowed: see man(7), man(1)
-.TH LIGHTSPARK 1 "May 29, 2010"
+.TH LIGHTSPARK 1 "November 9, 2013"
 .\" Please adjust this date whenever revising the manpage.
 .\"
 .\" Some roff macros, for reference:
@@ -19,15 +19,15 @@
 lightspark \- a free Flash player
 .SH SYNOPSIS
 .B lightspark 
-[\-\-url|\-u http://loader.url/file.swf] [\-\-disable-interpreter|\-ni] [\-\-enable\-jit|\-j] [\-\-log\-level|\-l 0-4] [\-\-parameters\-file|\-p params-file] [\-\-version|\-v] file.swf
+[\-\-url|\-u http://loader.url/file.swf] [\-\-air] [\-\-disable-interpreter|\-ni] [\-\-enable-fast-interpreter|\-fi] [\-\-enable\-jit|\-j] [\-\-log\-level|\-l 0-4] [\-\-parameters\-file|\-p params-file] [\-\-profiling-output|\-o] [\-\-security-sandbox|\-s <sandbox type>] [\-\-exit-on-error] [\-\-HTTP-cookies <cookie>] [\-\-version|\-v] file.swf
 .SH DESCRIPTION
 .B Lightspark
 is a free, modern Flash Player implementation, this documents the options accepted by the standalone version of the program.
 .PP
 .\" TeX users may be more comfortable with the \fB<whatever>\fP and
-.\" \fI<whatever>\fP escape sequences to invode bold face and italics,
+.\" \fI<whatever>\fP escape sequences to invoke bold face and italics,
 .\" respectively.
-The player is currently in Beta, support for any particular SWF file is not guaranteed
+The player is currently in Beta, support for any particular SWF file is not guaranteed.
 .PP
 You might wish to see the project website at http://lightspark.sf.net or our 
 technical blog at http://allievi.sssup.it/techblog
@@ -41,6 +41,10 @@
 .IP
 Disable the ActionScript interpreter
 .HP 
+\fB\-\-enable-fast-interpreter\fP
+.IP
+Enable an experimental optimized ActionScript interpreter
+.HP 
 \fB\-\-enable-jit\fP, \fB\-j\fP
 .IP
 Enable the ActionScript JIT compilation engine
@@ -56,6 +60,22 @@
 \fB\-\-profiling-output\fP profiling-file, \fB\-o\fP profiling-file
 .IP
 Output profiling data to profiling-file in a callgrind/KCachegrind compatible format
+.HP 
+\fB\-\-security-sandbox\fP type, \fB\-s\fP type
+.IP
+Run a Flash file in a given sandbox to control access to network and local files. The possible types are: remote (default), local-with-filesystem, local-with-networking, local-trusted.
+.HP
+\fB\-\-exit-on-error\fP
+.IP
+Exit as soon as the first error is encountered.
+.HP
+\fB\-\-HTTP-cookies\fP cookie
+.IP
+Set cookie to be used in HTTP requests.
+.HP
+\fB\-\-air\fP
+.IP
+Run as an AIR application: grant permission to access both local files and network, and enable AIR APIs.
 .HP
 \fB\-\-version\fP, \fB\-v\fP
 .IP
diff -Nuar lightspark-0.7.2.orig/README lightspark-0.7.2/README
--- lightspark-0.7.2.orig/README	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/README	2013-11-09 19:23:31.000000000 +0200
@@ -35,15 +35,20 @@
 To enable debug mode change the cmake command like this:
 4b) cmake -DCMAKE_BUILD_TYPE=Debug
 
-CMAKE_BUILD_TYPE available: Debug Release RelWithDebInfo Profile Sound
-support may be disabled using the following option: -DENABLE_SOUND=0
-The audio backend can be set using -DAUDIO_BACKEND=<pulseaudio|sdl>
-(default is pulseaudio)
+CMAKE_BUILD_TYPE available: Debug LeanDebug Release RelWithDebInfo Profile
+
+Sound support may be disabled using the following option:
+-DENABLE_SOUND=0 The audio backend can be set using
+-DAUDIO_BACKEND=<pulseaudio|sdl> (default is pulseaudio)
 
 EXECUTION
 =========
 
 Using `make install`, lightspark is installed in the system wide
+
+Browser plugin
+--------------
+
 Firefox plugin path and Firefox should show it in the about:plugins
 list and in the Tools->Add-ons->Plugins window.
 
@@ -57,6 +62,14 @@
 same MIME type. If you only see a black box where a flash app should
 be try to remove any other flash plugin you have installed.
 
+Command line
+------------
+
+The command line version of Lightspark can play a local SWF file.
+Execution: lightspark file.swf
+
+Type `lightspark` to see all command line options.
+
 Keyboard shortcuts
 ------------------
 
diff -Nuar lightspark-0.7.2.orig/src/allclasses.cpp lightspark-0.7.2/src/allclasses.cpp
--- lightspark-0.7.2.orig/src/allclasses.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/allclasses.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -19,6 +19,7 @@
 
 #include "scripting/toplevel/ASString.h"
 #include "scripting/toplevel/Date.h"
+#include "scripting/toplevel/JSON.h"
 #include "scripting/toplevel/Math.h"
 #include "scripting/toplevel/RegExp.h"
 #include "scripting/toplevel/Vector.h"
@@ -28,6 +29,19 @@
 #include "scripting/flash/desktop/flashdesktop.h"
 #include "scripting/flash/display/flashdisplay.h"
 #include "scripting/flash/display/BitmapData.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/flash/display/GraphicsBitmapFill.h"
+#include "scripting/flash/display/GraphicsEndFill.h"
+#include "scripting/flash/display/GraphicsGradientFill.h"
+#include "scripting/flash/display/GraphicsPath.h"
+#include "scripting/flash/display/GraphicsShaderFill.h"
+#include "scripting/flash/display/GraphicsSolidFill.h"
+#include "scripting/flash/display/GraphicsStroke.h"
+#include "scripting/flash/display/GraphicsTrianglePath.h"
+#include "scripting/flash/display/IGraphicsData.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsPath.h"
+#include "scripting/flash/display/IGraphicsStroke.h"
 #include "scripting/flash/events/flashevents.h"
 #include "scripting/flash/filters/flashfilters.h"
 #include "scripting/flash/net/flashnet.h"
@@ -37,6 +51,12 @@
 #include "scripting/flash/system/flashsystem.h"
 #include "scripting/flash/sensors/flashsensors.h"
 #include "scripting/flash/utils/flashutils.h"
+#include "scripting/flash/utils/ByteArray.h"
+#include "scripting/flash/utils/Dictionary.h"
+#include "scripting/flash/utils/Proxy.h"
+#include "scripting/flash/utils/Timer.h"
+#include "scripting/flash/utils/IntervalManager.h"
+#include "scripting/flash/utils/IntervalRunner.h"
 #include "scripting/flash/geom/flashgeom.h"
 #include "scripting/flash/external/ExternalInterface.h"
 #include "scripting/flash/media/flashmedia.h"
@@ -45,6 +65,7 @@
 #include "scripting/flash/text/flashtext.h"
 #include "scripting/flash/text/flashtextengine.h"
 #include "scripting/flash/ui/Keyboard.h"
+#include "scripting/flash/ui/Mouse.h"
 
 using namespace lightspark;
 
diff -Nuar lightspark-0.7.2.orig/src/allclasses.h lightspark-0.7.2/src/allclasses.h
--- lightspark-0.7.2.orig/src/allclasses.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/allclasses.h	2013-11-09 19:23:31.000000000 +0200
@@ -28,6 +28,7 @@
 REGISTER_CLASS_NAME2(Global,"global","")
 REGISTER_CLASS_NAME2(IFunction,"Function","")
 REGISTER_CLASS_NAME2(Integer,"int","")
+REGISTER_CLASS_NAME(JSON,"")
 REGISTER_CLASS_NAME(Math,"")
 REGISTER_CLASS_NAME(Namespace,"")
 REGISTER_CLASS_NAME(Number,"")
@@ -69,6 +70,20 @@
 REGISTER_CLASS_NAME(FrameLabel,"flash.display")
 REGISTER_CLASS_NAME(GradientType,"flash.display")
 REGISTER_CLASS_NAME(Graphics,"flash.display")
+REGISTER_CLASS_NAME(GraphicsBitmapFill,"flash.display")
+REGISTER_CLASS_NAME(GraphicsEndFill,"flash.display")
+REGISTER_CLASS_NAME(GraphicsGradientFill,"flash.display")
+REGISTER_CLASS_NAME(GraphicsPath,"flash.display")
+REGISTER_CLASS_NAME(GraphicsPathCommand,"flash.display")
+REGISTER_CLASS_NAME(GraphicsPathWinding,"flash.display")
+REGISTER_CLASS_NAME(GraphicsShaderFill,"flash.display")
+REGISTER_CLASS_NAME(GraphicsSolidFill,"flash.display")
+REGISTER_CLASS_NAME(GraphicsStroke,"flash.display")
+REGISTER_CLASS_NAME(GraphicsTrianglePath,"flash.display")
+REGISTER_CLASS_NAME(IGraphicsData,"flash.display")
+REGISTER_CLASS_NAME(IGraphicsFill,"flash.display")
+REGISTER_CLASS_NAME(IGraphicsPath,"flash.display")
+REGISTER_CLASS_NAME(IGraphicsStroke,"flash.display")
 REGISTER_CLASS_NAME(IBitmapDrawable,"flash.display")
 REGISTER_CLASS_NAME(InteractiveObject,"flash.display")
 REGISTER_CLASS_NAME(InterpolationMethod,"flash.display")
@@ -120,6 +135,7 @@
 
 //Filters
 REGISTER_CLASS_NAME(BitmapFilter,"flash.filters")
+REGISTER_CLASS_NAME(BitmapFilterQuality,"flash.filters")
 REGISTER_CLASS_NAME(DropShadowFilter,"flash.filters")
 REGISTER_CLASS_NAME(GlowFilter,"flash.filters")
 
@@ -189,6 +205,7 @@
 REGISTER_CLASS_NAME(TextFieldType,"flash.text")
 REGISTER_CLASS_NAME(TextFormat,"flash.text")
 REGISTER_CLASS_NAME(TextFormatAlign,"flash.text")
+REGISTER_CLASS_NAME(TextInteractionMode,"flash.text")
 REGISTER_CLASS_NAME(TextLineMetrics,"flash.text")
 REGISTER_CLASS_NAME(StaticText,"flash.text")
 REGISTER_CLASS_NAME(StyleSheet,"flash.text")
@@ -216,6 +233,7 @@
 REGISTER_CLASS_NAME(Keyboard,"flash.ui")
 REGISTER_CLASS_NAME(KeyboardType,"flash.ui")
 REGISTER_CLASS_NAME(KeyLocation,"flash.ui")
+REGISTER_CLASS_NAME(Mouse,"flash.ui")
 
 //XML
 REGISTER_CLASS_NAME(XMLDocument,"flash.xml")
diff -Nuar lightspark-0.7.2.orig/src/asobject.cpp lightspark-0.7.2/src/asobject.cpp
--- lightspark-0.7.2.orig/src/asobject.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/asobject.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -53,6 +53,10 @@
 		ret+=this->as<Class_base>()->class_name.getQualifiedName().raw_buf();
 		ret+="]";
 	}
+	else if(this->is<Template_base>())
+	{
+		ret = "[templated class]";
+	}
 	else
 	{
 		assert(false);
@@ -85,6 +89,14 @@
 	}
 }
 
+tiny_string ASObject::toLocaleString()
+{
+	_NR<ASObject> str = executeASMethod("toLocaleString", {""}, NULL, 0);
+	if (str.isNull())
+		return "";
+	return str->toString();
+}
+
 TRISTATE ASObject::isLess(ASObject* r)
 {
 	check();
@@ -143,7 +155,7 @@
 	c->setDeclaredMethodByQName("hasOwnProperty",AS3,Class<IFunction>::getFunction(hasOwnProperty),NORMAL_METHOD,true);
 
 	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("toLocaleString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toLocaleString","",Class<IFunction>::getFunction(_toLocaleString),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(valueOf),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("hasOwnProperty","",Class<IFunction>::getFunction(hasOwnProperty),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("isPrototypeOf","",Class<IFunction>::getFunction(isPrototypeOf),DYNAMIC_TRAIT);
@@ -215,7 +227,7 @@
 
 int32_t ASObject::toInt()
 {
-	return 0;
+	return toPrimitive()->toInt();
 }
 
 /* Implements ECMA's ToPrimitive (9.1) and [[DefaultValue]] (8.6.2.6) */
@@ -328,6 +340,46 @@
 	return _MR(ret);
 }
 
+bool ASObject::has_toJSON()
+{
+	multiname toJSONName(NULL);
+	toJSONName.name_type=multiname::NAME_STRING;
+	toJSONName.name_s_id=getSys()->getUniqueStringId("toJSON");
+	toJSONName.ns.push_back(nsNameAndKind("",NAMESPACE));
+	toJSONName.ns.push_back(nsNameAndKind(AS3,NAMESPACE));
+	toJSONName.isAttribute = false;
+	return ASObject::hasPropertyByMultiname(toJSONName, true, true);
+}
+
+tiny_string ASObject::call_toJSON()
+{
+	multiname toJSONName(NULL);
+	toJSONName.name_type=multiname::NAME_STRING;
+	toJSONName.name_s_id=getSys()->getUniqueStringId("toJSON");
+	toJSONName.ns.push_back(nsNameAndKind("",NAMESPACE));
+	toJSONName.ns.push_back(nsNameAndKind(AS3,NAMESPACE));
+	toJSONName.isAttribute = false;
+	assert(ASObject::hasPropertyByMultiname(toJSONName, true, true));
+
+	_NR<ASObject> o=getVariableByMultiname(toJSONName,SKIP_IMPL);
+	assert_and_throw(o->is<IFunction>());
+	IFunction* f=o->as<IFunction>();
+
+	incRef();
+	ASObject *ret=f->call(this,NULL,0);
+	tiny_string res;
+	if (ret->is<ASString>())
+	{
+		res += "\"";
+		res += ret->toString();
+		res += "\"";
+	}
+	else 
+		res = ret->toString();
+	
+	return res;
+}
+
 bool ASObject::isPrimitive() const
 {
 	// ECMA 3, section 4.3.2, T_INTEGER and T_UINTEGER are added
@@ -537,7 +589,20 @@
 		}
 	}
 
-	//Do not lookup in the prototype chain. This is tested behaviour
+	//Do not set variables in prototype chain. Still have to do
+	//lookup to throw a correct error in case a named function
+	//exists in prototype chain. See Tamarin test
+	//ecma3/Boolean/ecma4_sealedtype_1_rt
+	if(!obj && cls && cls->isSealed)
+	{
+		variable *protoObj = cls->findSettableInPrototype(name);
+		if (protoObj && 
+		    ((protoObj->var && protoObj->var->is<Function>()) ||
+		     protoObj->setter))
+		{
+			throwError<ReferenceError>(kCannotAssignToMethodError, name.normalizedName(), cls ? cls->getQualifiedClassName() : "");
+		}
+	}
 
 	if(!obj)
 	{
@@ -826,6 +891,16 @@
 	return Class<ASString>::getInstanceS(ret);
 }
 
+ASFUNCTIONBODY(ASObject,_toLocaleString)
+{
+	if (!obj->has_toString())
+		throwError<TypeError>(kCallNotFoundError, "toString", obj->getClassName());
+
+	_R<ASObject> res = obj->call_toString();
+	res->incRef();
+	return res.getPtr();
+}
+
 ASFUNCTIONBODY(ASObject,hasOwnProperty)
 {
 	assert_and_throw(argslen==1);
@@ -892,6 +967,12 @@
 	return NULL;
 }
 
+ASFUNCTIONBODY(ASObject,_constructorNotInstantiatable)
+{
+	throwError<ArgumentError>(kCantInstantiateError, obj->getClassName());
+	return NULL;
+}
+
 void ASObject::initSlot(unsigned int n, const multiname& name)
 {
 	Variables.initSlot(n,name.name_s_id,name.ns[0]);
@@ -1446,6 +1527,131 @@
 	return Class<XML>::getInstanceS(root);
 }
 
+tiny_string ASObject::toJSON(std::vector<ASObject *> &path, IFunction *replacer, const tiny_string &spaces,const tiny_string& filter)
+{
+	if (has_toJSON())
+	{
+		return call_toJSON();
+	}
+
+	tiny_string newline = (spaces.empty() ? "" : "\n");
+	tiny_string res;
+	if (this->isPrimitive())
+	{
+		switch(this->type)
+		{
+			case T_STRING:
+			{
+				res += "\"";
+				tiny_string sub = this->toString();
+				for (CharIterator it=sub.begin(); it!=sub.end(); it++)
+				{
+					switch (*it)
+					{
+						case '\b':
+							res += "\\b";
+							break;
+						case '\f':
+							res += "\\f";
+							break;
+						case '\n':
+							res += "\\n";
+							break;
+						case '\r':
+							res += "\\r";
+							break;
+						case '\t':
+							res += "\\t";
+							break;
+						case '\"':
+							res += "\\\"";
+							break;
+						case '\\':
+							res += "\\\\";
+							break;
+						default:
+							if (*it < 0x20 || *it > 0xff)
+							{
+								char hexstr[7];
+								sprintf(hexstr,"\\u%04x",*it);
+								res += hexstr;
+							}
+							else
+								res += *it;
+							break;
+					}
+				}
+				res += "\"";
+				break;
+			}
+			case T_UNDEFINED:
+				res += "null";
+				break;
+			default:
+				res += this->toString();
+				break;
+		}
+	}
+	else
+	{
+		res += "{";
+		const variables_map::const_var_iterator beginIt = Variables.Variables.begin();
+		const variables_map::const_var_iterator endIt = Variables.Variables.end();
+		bool bfirst = true;
+		for(variables_map::const_var_iterator varIt=beginIt; varIt != endIt; ++varIt)
+		{
+			// check for cylic reference
+			if (std::find(path.begin(),path.end(), varIt->second.var) != path.end())
+				throwError<TypeError>(kJSONCyclicStructure);
+
+			if (replacer != NULL)
+			{
+				if (!bfirst)
+					res += ",";
+				res += newline+spaces;
+				res += "\"";
+				res += getSys()->getStringFromUniqueId(varIt->first.nameId);
+				res += "\"";
+				res += ":";
+				if (!spaces.empty())
+					res += " ";
+				ASObject* params[2];
+				
+				params[0] = Class<ASString>::getInstanceS(getSys()->getStringFromUniqueId(varIt->first.nameId));
+				params[1] = varIt->second.var;
+				params[1]->incRef();
+				ASObject *funcret=replacer->call(getSys()->getNullRef(), params, 2);
+				LOG(LOG_ERROR,"funcall:"<<res<<"|"<<funcret);
+				if (funcret)
+					res += funcret->toString();
+				else
+					res += varIt->second.var->toJSON(path,replacer,spaces+spaces,filter);
+				bfirst = false;
+			}
+			else if (filter.empty() || filter.find(tiny_string(" ")+getSys()->getStringFromUniqueId(varIt->first.nameId)+" ") != tiny_string::npos)
+			{
+				if (!bfirst)
+					res += ",";
+				res += newline+spaces;
+				res += "\"";
+				res += getSys()->getStringFromUniqueId(varIt->first.nameId);
+				res += "\"";
+				res += ":";
+				if (!spaces.empty())
+					res += " ";
+				res += varIt->second.var->toJSON(path,replacer,spaces+spaces,filter);
+				bfirst = false;
+			}
+			path.push_back(varIt->second.var);
+		}
+		if (!bfirst)
+			res += newline+spaces.substr_bytes(0,spaces.numBytes()/2);
+
+		res += "}";
+	}
+	return res;
+}
+
 bool ASObject::hasprop_prototype()
 {
 	variable* var=Variables.findObjVar(BUILTIN_STRINGS::PROTOTYPE,nsNameAndKind(BUILTIN_NAMESPACES::EMPTY_NS),
diff -Nuar lightspark-0.7.2.orig/src/asobject.h lightspark-0.7.2/src/asobject.h
--- lightspark-0.7.2.orig/src/asobject.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/asobject.h	2013-11-09 19:23:31.000000000 +0200
@@ -122,6 +122,25 @@
 		REGISTER_GETTER(c,name); \
 		REGISTER_SETTER(c,name)
 
+#define CLASS_DYNAMIC_NOT_FINAL 0
+#define CLASS_FINAL 1
+#define CLASS_SEALED 2
+
+// TODO: Every class should have a constructor
+#define CLASS_SETUP_NO_CONSTRUCTOR(c, superClass, attributes) \
+	c->setSuper(Class<superClass>::getRef()); \
+	c->setConstructor(NULL); \
+	c->isFinal = ((attributes) & CLASS_FINAL) != 0;	\
+	c->isSealed = ((attributes) & CLASS_SEALED) != 0
+
+#define CLASS_SETUP(c, superClass, constructor, attributes) \
+	CLASS_SETUP_NO_CONSTRUCTOR(c, superClass, attributes); \
+	c->setConstructor(Class<IFunction>::getFunction(constructor));
+
+#define CLASS_SETUP_CONSTRUCTOR_LENGTH(c, superClass, constructor, ctorlength, attributes) \
+	CLASS_SETUP_NO_CONSTRUCTOR(c, superClass, attributes); \
+	c->setConstructor(Class<IFunction>::getFunction((constructor), (ctorlength)));
+
 namespace lightspark
 {
 
@@ -274,7 +293,11 @@
 	bool implEnable:1;
 	Class_base* getClass() const { return classdef; }
 	ASFUNCTION(_constructor);
+	// constructor for subclasses that can't be instantiated.
+	// Throws ArgumentError.
+	ASFUNCTION(_constructorNotInstantiatable);
 	ASFUNCTION(_toString);
+	ASFUNCTION(_toLocaleString);
 	ASFUNCTION(hasOwnProperty);
 	ASFUNCTION(valueOf);
 	ASFUNCTION(isPrototypeOf);
@@ -387,6 +410,7 @@
 	}
 	/* Implements ECMA's 9.8 ToString operation, but returns the concrete value */
 	tiny_string toString();
+	tiny_string toLocaleString();
 	virtual int32_t toInt();
 	virtual uint32_t toUInt();
 	uint16_t toUInt16();
@@ -403,6 +427,8 @@
 	_R<ASObject> call_valueOf();
 	bool has_toString();
 	_R<ASObject> call_toString();
+	bool has_toJSON();
+	tiny_string call_toJSON();
 
 	/* Helper function for calling getClass()->getQualifiedClassName() */
 	virtual tiny_string getClassName();
@@ -441,6 +467,7 @@
 
 	virtual ASObject *describeType() const;
 
+	virtual tiny_string toJSON(std::vector<ASObject *> &path, IFunction *replacer, const tiny_string &spaces,const tiny_string& filter);
 	/* returns true if the current object is of type T */
 	template<class T> bool is() const { return dynamic_cast<const T*>(this); }
 	/* returns this object casted to the given type.
diff -Nuar lightspark-0.7.2.orig/src/backends/decoder.cpp lightspark-0.7.2/src/backends/decoder.cpp
--- lightspark-0.7.2.orig/src/backends/decoder.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/decoder.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -295,6 +295,8 @@
 #else
 	int ret=avcodec_decode_video(codecContext, frameIn, &frameOk, pkt->data, pkt->size);
 #endif
+	if (ret < 0)
+		return false;
 
 	assert_and_throw(ret==(int)pkt->size);
 	if(frameOk)
@@ -451,19 +453,7 @@
 #ifdef ENABLE_LIBAVCODEC
 FFMpegAudioDecoder::FFMpegAudioDecoder(LS_AUDIO_CODEC audioCodec, uint8_t* initdata, uint32_t datalen):ownedContext(true)
 {
-	CodecID codecId;
-	switch(audioCodec)
-	{
-		case AAC:
-			codecId=CODEC_ID_AAC;
-			break;
-		case MP3:
-			codecId=CODEC_ID_MP3;
-			break;
-		default:
-			::abort();
-	}
-	AVCodec* codec=avcodec_find_decoder(codecId);
+	AVCodec* codec=avcodec_find_decoder(LSToFFMpegCodec(audioCodec));
 	assert(codec);
 
 	codecContext=avcodec_alloc_context3(codec);
@@ -490,7 +480,33 @@
 #endif
 }
 
-FFMpegAudioDecoder::FFMpegAudioDecoder(AVCodecContext* _c):codecContext(_c)
+FFMpegAudioDecoder::FFMpegAudioDecoder(LS_AUDIO_CODEC lscodec, int sampleRate, int channels, bool):ownedContext(true)
+{
+	status=INIT;
+
+	CodecID codecId = LSToFFMpegCodec(lscodec);
+	AVCodec* codec=avcodec_find_decoder(codecId);
+	assert(codec);
+	codecContext=avcodec_alloc_context3(codec);
+	codecContext->codec_id = codecId;
+	codecContext->sample_rate = sampleRate;
+	codecContext->channels = channels;
+
+#ifdef HAVE_AVCODEC_OPEN2
+	if(avcodec_open2(codecContext, codec, NULL)<0)
+#else
+	if(avcodec_open(codecContext, codec)<0)
+#endif //HAVE_AVCODEC_ALLOC_CONTEXT3
+		return;
+
+	if(fillDataAndCheckValidity())
+		status=VALID;
+#if HAVE_AVCODEC_DECODE_AUDIO4
+	frameIn=avcodec_alloc_frame();
+#endif
+}
+
+FFMpegAudioDecoder::FFMpegAudioDecoder(AVCodecContext* _c):ownedContext(false),codecContext(_c)
 {
 	status=INIT;
 	AVCodec* codec=avcodec_find_decoder(codecContext->codec_id);
@@ -520,6 +536,21 @@
 #endif
 }
 
+CodecID FFMpegAudioDecoder::LSToFFMpegCodec(LS_AUDIO_CODEC LSCodec)
+{
+	switch(LSCodec)
+	{
+		case AAC:
+			return CODEC_ID_AAC;
+		case MP3:
+			return CODEC_ID_MP3;
+		case ADPCM:
+			return CODEC_ID_ADPCM_SWF;
+		default:
+			return CODEC_ID_NONE;
+	}
+}
+
 bool FFMpegAudioDecoder::fillDataAndCheckValidity()
 {
 	if(codecContext->sample_rate!=0)
@@ -556,8 +587,25 @@
 #if HAVE_AVCODEC_DECODE_AUDIO3 || HAVE_AVCODEC_DECODE_AUDIO4
 	AVPacket pkt;
 	av_init_packet(&pkt);
-	pkt.data=data;
-	pkt.size=datalen;
+
+	// If some data was left unprocessed on previous call,
+	// concatenate.
+	std::vector<uint8_t> combinedBuffer;
+	if (overflowBuffer.empty())
+	{
+		pkt.data=data;
+		pkt.size=datalen;
+	}
+	else
+	{
+		combinedBuffer.assign(overflowBuffer.begin(), overflowBuffer.end());
+		if (datalen > 0)
+			combinedBuffer.insert(combinedBuffer.end(), data, data+datalen);
+		pkt.data = &combinedBuffer[0];
+		pkt.size = combinedBuffer.size();
+		overflowBuffer.clear();
+	}
+
 #if HAVE_AVCODEC_DECODE_AUDIO4
 	avcodec_get_frame_defaults(frameIn);
 	int frameOk=0;
@@ -566,21 +614,36 @@
 		ret=-1;
 	else
 	{
-		//This is suboptimal but equivalent to what libavcodec
-		//does for the compatibility version of avcodec_decode_audio3
-		memcpy(curTail.samples, frameIn->extended_data[0], frameIn->linesize[0]);
-		maxLen=frameIn->linesize[0];
+		if (frameIn->format != AV_SAMPLE_FMT_S16)
+		{
+			maxLen = resampleFrameToS16(curTail);
+		}
+		else 
+		{
+			//This is suboptimal but equivalent to what libavcodec
+			//does for the compatibility version of avcodec_decode_audio3
+			memcpy(curTail.samples, frameIn->extended_data[0], frameIn->linesize[0]);
+			maxLen=frameIn->linesize[0];
+		}
 	}
 #else
 	int32_t ret=avcodec_decode_audio3(codecContext, curTail.samples, &maxLen, &pkt);
 #endif
+
+	if (ret > 0)
+	{
+		pkt.data += ret;
+		pkt.size -= ret;
+
+		if (pkt.size > 0)
+		{
+			overflowBuffer.assign(pkt.data, pkt.data+pkt.size);
+		}
+	}
+
 #else
 	int32_t ret=avcodec_decode_audio2(codecContext, curTail.samples, &maxLen, data, datalen);
 #endif
-	assert_and_throw(ret==datalen);
-
-	if(status==INIT && fillDataAndCheckValidity())
-		status=VALID;
 
 	curTail.len=maxLen;
 	assert(!(curTail.len&0x80000000));
@@ -588,6 +651,10 @@
 	curTail.current=curTail.samples;
 	curTail.time=time;
 	samplesBuffer.commitLast();
+
+	if(status==INIT && fillDataAndCheckValidity())
+		status=VALID;
+
 	return maxLen;
 }
 
@@ -604,10 +671,17 @@
 		ret=-1;
 	else
 	{
-		//This is suboptimal but equivalent to what libavcodec
-		//does for the compatibility version of avcodec_decode_audio3
-		memcpy(curTail.samples, frameIn->extended_data[0], frameIn->linesize[0]);
-		maxLen=frameIn->linesize[0];
+		if (frameIn->format != AV_SAMPLE_FMT_S16)
+		{
+			maxLen = resampleFrameToS16(curTail);
+		}
+		else 
+		{
+			//This is suboptimal but equivalent to what libavcodec
+			//does for the compatibility version of avcodec_decode_audio3
+			memcpy(curTail.samples, frameIn->extended_data[0], frameIn->linesize[0]);
+			maxLen=frameIn->linesize[0];
+		}
 	}
 #elif HAVE_AVCODEC_DECODE_AUDIO3
 	int ret=avcodec_decode_audio3(codecContext, curTail.samples, &maxLen, pkt);
@@ -639,6 +713,61 @@
 	samplesBuffer.commitLast();
 	return maxLen;
 }
+#if HAVE_AVCODEC_DECODE_AUDIO4
+int FFMpegAudioDecoder::resampleFrameToS16(FrameSamples& curTail)
+{
+	int maxLen;
+#ifdef HAVE_LIBAVRESAMPLE
+	AVAudioResampleContext * avr = avresample_alloc_context();
+	av_opt_set_int(avr, "in_channel_layout",  frameIn->channel_layout, 0);
+	av_opt_set_int(avr, "out_channel_layout", frameIn->channel_layout,  0);
+	av_opt_set_int(avr, "in_sample_rate",     frameIn->sample_rate,     0);
+	av_opt_set_int(avr, "out_sample_rate",    frameIn->sample_rate,     0);
+	av_opt_set_int(avr, "in_sample_fmt",      frameIn->format,   0);
+	av_opt_set_int(avr, "out_sample_fmt",     AV_SAMPLE_FMT_S16,    0);
+	avresample_open(avr);
+
+	uint8_t *output;
+	int out_linesize;
+	int out_samples = avresample_available(avr) + av_rescale_rnd(avresample_get_delay(avr) + frameIn->linesize[0], frameIn->sample_rate, frameIn->sample_rate, AV_ROUND_UP);
+	av_samples_alloc(&output, &out_linesize, frameIn->nb_samples, out_samples, AV_SAMPLE_FMT_S16, 0);
+	maxLen = avresample_convert(avr, &output, out_linesize, out_samples, frameIn->extended_data, frameIn->linesize[0], frameIn->nb_samples)*4;
+	memcpy(curTail.samples, output, maxLen);
+	av_freep(&output);
+	avresample_free(&avr);
+#else
+	LOG(LOG_ERROR, "unexpected sample format and can't resample, recompile with libavresample");
+	memset(curTail.samples, 0, frameIn->linesize[0]);
+	maxLen = frameIn->linesize[0];
+#endif
+	return maxLen;
+}
+#endif
+
+uint32_t FFMpegAudioDecoder::decodeStreamSomePackets(std::istream& s, uint32_t time)
+{
+	const size_t BUF_SIZE = 4096;
+	uint32_t ret;
+	uint8_t inbuf[BUF_SIZE + FF_INPUT_BUFFER_PADDING_SIZE];
+	s.read((char*)inbuf, BUF_SIZE);
+	if (s.gcount() == 0)
+		return 0;
+
+	ret = decodeData(inbuf, s.gcount(), time);
+
+	// Keep the overflowBuffer from growing without bounds
+	size_t overflowSize = overflowBuffer.size();
+	while (overflowSize > BUF_SIZE)
+	{
+		ret = decodeData(NULL, 0, time);
+		if (overflowBuffer.size() == overflowSize)
+			break;
+		overflowSize = overflowBuffer.size();
+	}
+
+	return ret;
+}
+
 #endif //ENABLE_LIBAVCODEC
 
 StreamDecoder::~StreamDecoder()
diff -Nuar lightspark-0.7.2.orig/src/backends/decoder.h lightspark-0.7.2/src/backends/decoder.h
--- lightspark-0.7.2.orig/src/backends/decoder.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/decoder.h	2013-11-09 19:23:31.000000000 +0200
@@ -28,6 +28,17 @@
 {
 #include <libavcodec/avcodec.h>
 #include <libavformat/avformat.h>
+#ifdef HAVE_LIBAVRESAMPLE
+#include <libavresample/avresample.h>
+#endif
+#include <libavutil/opt.h>
+#include <libavutil/mathematics.h>
+#ifndef AVCODEC_MAX_AUDIO_FRAME_SIZE
+#define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
+#endif
+#ifdef HAVE_AVCODECID
+#define CodecID AVCodecID
+#endif
 #define MAX_AUDIO_FRAME_SIZE AVCODEC_MAX_AUDIO_FRAME_SIZE
 }
 #else
@@ -40,7 +51,8 @@
 {
 
 enum LS_VIDEO_CODEC { H264=0, H263, VP6 };
-enum LS_AUDIO_CODEC { LINEAR_PCM_PLATFORM_ENDIAN=0, ADPCM=1, MP3=2, LINEAR_PCM_LE=3, AAC=10 };
+// "Audio coding formats" from Chapter 11 in SWF documentation
+enum LS_AUDIO_CODEC { CODEC_NONE=-1, LINEAR_PCM_PLATFORM_ENDIAN=0, ADPCM=1, MP3=2, LINEAR_PCM_LE=3, AAC=10 };
 
 class Decoder
 {
@@ -277,12 +289,16 @@
 private:
 	bool ownedContext;
 	AVCodecContext* codecContext;
+	std::vector<uint8_t> overflowBuffer;
 	bool fillDataAndCheckValidity();
+	CodecID LSToFFMpegCodec(LS_AUDIO_CODEC lscodec);
 #if HAVE_AVCODEC_DECODE_AUDIO4
 	AVFrame* frameIn;
+	int resampleFrameToS16(FrameSamples& curTail);
 #endif
 public:
 	FFMpegAudioDecoder(LS_AUDIO_CODEC codec, uint8_t* initdata, uint32_t datalen);
+	FFMpegAudioDecoder(LS_AUDIO_CODEC codec, int sampleRate, int channels, bool);
 	/*
 	   Specialized constructor used by FFMpegStreamDecoder
 	*/
@@ -293,6 +309,7 @@
 	*/
 	uint32_t decodePacket(AVPacket* pkt, uint32_t time);
 	uint32_t decodeData(uint8_t* data, int32_t datalen, uint32_t time);
+	uint32_t decodeStreamSomePackets(std::istream& s, uint32_t time);
 };
 #endif
 
diff -Nuar lightspark-0.7.2.orig/src/backends/graphics.cpp lightspark-0.7.2/src/backends/graphics.cpp
--- lightspark-0.7.2.orig/src/backends/graphics.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/graphics.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -458,10 +458,20 @@
 				cairo_stroke(stroke_cr);
 
 				const LINESTYLE2& style = tokens[i].lineStyle;
-				const RGBA& color = style.Color;
 
 				cairo_set_operator(stroke_cr, CAIRO_OPERATOR_OVER);
-				cairo_set_source_rgba(stroke_cr, color.rf(), color.gf(), color.bf(), color.af());
+				if (style.HasFillFlag)
+				{
+					cairo_pattern_t* pattern = FILLSTYLEToCairo(style.FillType, scaleCorrection);
+					if (pattern)
+					{
+						cairo_set_source(stroke_cr, pattern);
+						cairo_pattern_destroy(pattern);
+					}
+				} else {
+					const RGBA& color = style.Color;
+					cairo_set_source_rgba(stroke_cr, color.rf(), color.gf(), color.bf(), color.af());
+				}
 
 				// TODO: EndCapStyle
 				if (style.StartCapStyle == 0)
@@ -838,12 +848,6 @@
 		pango_layout_set_width(layout,PANGO_SCALE*tData.width);
 		pango_layout_set_wrap(layout,PANGO_WRAP_WORD);//I think this is what Adobe does
 	}
-	//In case autoSize is NONE, we also have the height
-	if(tData.autoSize == TextData::AUTO_SIZE::AS_NONE)
-	{
-		pango_layout_set_width(layout,PANGO_SCALE*tData.width);
-		pango_layout_set_height(layout,PANGO_SCALE*tData.height);//TODO:Not sure what Pango does if the text is too long to fit
-	}
 
 	/* setup font description */
 	desc = pango_font_description_new();
@@ -870,9 +874,19 @@
 		cairo_paint(cr);
 	}
 
+	/* text scroll position */
+	int32_t translateX = textData.scrollH;
+	int32_t translateY = 0;
+	if (textData.scrollV > 1)
+	{
+		translateY = -PANGO_PIXELS(lineExtents(layout, textData.scrollV-1).y);
+	}
+
 	/* draw the text */
 	cairo_set_source_rgb (cr, textData.textColor.Red/255., textData.textColor.Green/255., textData.textColor.Blue/255.);
+	cairo_translate(cr, translateX, translateY);
 	pango_cairo_show_layout(cr, layout);
+	cairo_translate(cr, -translateX, -translateY);
 
 	if(textData.border)
 	{
@@ -917,6 +931,68 @@
 	return (h!=0) && (w!=0);
 }
 
+PangoRectangle CairoPangoRenderer::lineExtents(PangoLayout *layout, int lineNumber)
+{
+	PangoRectangle rect;
+	memset(&rect, 0, sizeof(PangoRectangle));
+	int i = 0;
+	PangoLayoutIter* lineIter = pango_layout_get_iter(layout);
+	do
+	{
+		if (i == lineNumber)
+		{
+			pango_layout_iter_get_line_extents(lineIter, NULL, &rect);
+			break;
+		}
+
+		i++;
+	} while (pango_layout_iter_next_line(lineIter));
+	pango_layout_iter_free(lineIter);
+
+	return rect;
+}
+
+std::vector<LineData> CairoPangoRenderer::getLineData(const TextData& _textData)
+{
+	//TODO:check locking
+	Locker l(pangoMutex);
+	cairo_surface_t* cairoSurface=cairo_image_surface_create_for_data(NULL, CAIRO_FORMAT_ARGB32, 0, 0, 0);
+	cairo_t *cr=cairo_create(cairoSurface);
+
+	PangoLayout* layout;
+	layout = pango_cairo_create_layout(cr);
+	pangoLayoutFromData(layout, _textData);
+
+	int XOffset = _textData.scrollH;
+	int YOffset = PANGO_PIXELS(lineExtents(layout, _textData.scrollV-1).y);
+	std::vector<LineData> data;
+	data.reserve(pango_layout_get_line_count(layout));
+	PangoLayoutIter* lineIter = pango_layout_get_iter(layout);
+	do
+	{
+		PangoRectangle rect;
+		pango_layout_iter_get_line_extents(lineIter, NULL, &rect);
+		PangoLayoutLine* line = pango_layout_iter_get_line(lineIter);
+		data.emplace_back(PANGO_PIXELS(rect.x) - XOffset,
+				  PANGO_PIXELS(rect.y) - YOffset,
+				  PANGO_PIXELS(rect.width),
+				  PANGO_PIXELS(rect.height),
+				  _textData.text.bytePosToIndex(line->start_index),
+				  _textData.text.substr_bytes(line->start_index, line->length).numChars(),
+				  PANGO_PIXELS(PANGO_ASCENT(rect)),
+				  PANGO_PIXELS(PANGO_DESCENT(rect)),
+				  PANGO_PIXELS(PANGO_LBEARING(rect)),
+				  0); // FIXME
+	} while (pango_layout_iter_next_line(lineIter));
+	pango_layout_iter_free(lineIter);
+
+	g_object_unref(layout);
+	cairo_destroy(cr);
+	cairo_surface_destroy(cairoSurface);
+
+	return data;
+}
+
 void CairoPangoRenderer::applyCairoMask(cairo_t* cr, int32_t xOffset, int32_t yOffset) const
 {
 	assert(false);
diff -Nuar lightspark-0.7.2.orig/src/backends/graphics.h lightspark-0.7.2/src/backends/graphics.h
--- lightspark-0.7.2.orig/src/backends/graphics.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/graphics.h	2013-11-09 19:23:31.000000000 +0200
@@ -344,7 +344,7 @@
 {
 public:
 	/* the default values are from the spec for flash.text.TextField and flash.text.TextFormat */
-	TextData() : width(100), height(100), textWidth(0), textHeight(0), font("Times New Roman"), background(false), backgroundColor(0xFFFFFF),
+	TextData() : width(100), height(100), textWidth(0), textHeight(0), font("Times New Roman"), scrollH(0), scrollV(1), background(false), backgroundColor(0xFFFFFF),
 		border(false), borderColor(0x000000), multiline(false), textColor(0x000000),
 		autoSize(AS_NONE), fontSize(12), wordWrap(false) {}
 	uint32_t width;
@@ -353,6 +353,8 @@
 	uint32_t textHeight;
 	tiny_string text;
 	tiny_string font;
+	int32_t scrollH; // pixels, 0-based
+	int32_t scrollV; // lines, 1-based
 	bool background;
 	RGB backgroundColor;
 	bool border;
@@ -365,6 +367,28 @@
 	bool wordWrap;
 };
 
+class LineData {
+public:
+	LineData(int32_t x, int32_t y, int32_t _width,
+		 int32_t _height, int32_t _firstCharOffset, int32_t _length,
+		 number_t _ascent, number_t _descent, number_t _leading,
+		 number_t _indent):
+		extents(x, x+_width, y, y+_height), 
+		firstCharOffset(_firstCharOffset), length(_length),
+		ascent(_ascent), descent(_descent), leading(_leading),
+		indent(_indent) {}
+	// position and size
+	RECT extents;
+	// Offset of the first character on this line
+	int32_t firstCharOffset;
+	// length of the line in characters
+	int32_t length;
+	number_t ascent;
+	number_t descent;
+	number_t leading;
+	number_t indent;
+};
+
 class CairoPangoRenderer : public CairoRenderer
 {
 	static StaticMutex pangoMutex;
@@ -375,6 +399,7 @@
 	TextData textData;
 	static void pangoLayoutFromData(PangoLayout* layout, const TextData& tData);
 	void applyCairoMask(cairo_t* cr, int32_t offsetX, int32_t offsetY) const;
+	static PangoRectangle lineExtents(PangoLayout *layout, int lineNumber);
 public:
 	CairoPangoRenderer(const TextData& _textData, const MATRIX& _m,
 			int32_t _x, int32_t _y, int32_t _w, int32_t _h, float _s, float _a, const std::vector<MaskData>& _ms)
@@ -385,6 +410,7 @@
 		@param w,h,tw,th are the (text)width and (text)height of the textData.
 	*/
 	static bool getBounds(const TextData& _textData, uint32_t& w, uint32_t& h, uint32_t& tw, uint32_t& th);
+	static std::vector<LineData> getLineData(const TextData& _textData);
 };
 
 class InvalidateQueue
diff -Nuar lightspark-0.7.2.orig/src/backends/input.cpp lightspark-0.7.2/src/backends/input.cpp
--- lightspark-0.7.2.orig/src/backends/input.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/input.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -141,6 +141,12 @@
 			ret=TRUE;
 			break;
 		}
+		case GDK_LEAVE_NOTIFY:
+		{
+			handleMouseLeave();
+			ret=TRUE;
+			break;
+		}
 		default:
 //#ifdef EXPENSIVE_DEBUG
 //			LOG(LOG_INFO, "GDKTYPE " << event->type);
@@ -292,6 +298,15 @@
 		_MR(Class<MouseEvent>::getInstanceS("mouseWheel",localX,localY,true,buttonState,NullRef,delta)));
 }
 
+void InputThread::handleMouseLeave()
+{
+	if(m_sys->currentVm == NULL)
+		return;
+
+	m_sys->currentVm->addEvent(m_sys->mainClip->getStage(),
+		_MR(Class<Event>::getInstanceS("mouseLeave")));
+}
+
 void InputThread::initKeyTable()
 {
 	int i = 0;
diff -Nuar lightspark-0.7.2.orig/src/backends/input.h lightspark-0.7.2/src/backends/input.h
--- lightspark-0.7.2.orig/src/backends/input.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/input.h	2013-11-09 19:23:31.000000000 +0200
@@ -78,6 +78,7 @@
 	void handleMouseUp(uint32_t x, uint32_t y, unsigned int buttonState);
 	void handleMouseMove(uint32_t x, uint32_t y, unsigned int buttonState);
 	void handleScrollEvent(uint32_t x, uint32_t y, GdkScrollDirection direction, unsigned int buttonState);
+        void handleMouseLeave();
 
 	void initKeyTable();
 	bool handleKeyboardShortcuts(const GdkEventKey *keyevent);
diff -Nuar lightspark-0.7.2.orig/src/backends/netutils.cpp lightspark-0.7.2/src/backends/netutils.cpp
--- lightspark-0.7.2.orig/src/backends/netutils.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/netutils.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -24,6 +24,7 @@
 #include "backends/config.h"
 #include "backends/netutils.h"
 #include "backends/rtmputils.h"
+#include "backends/streamcache.h"
 #include "compat.h"
 #include <string>
 #include <algorithm>
@@ -165,25 +166,26 @@
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-Downloader* StandaloneDownloadManager::download(const URLInfo& url, bool cached, ILoadable* owner)
+Downloader* StandaloneDownloadManager::download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner)
 {
+	bool cached = dynamic_cast<FileStreamCache *>(cache.getPtr()) != NULL;
 	LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager::download '") << url.getParsedURL()
 			<< "'" << (cached ? _(" - cached") : ""));
 	ThreadedDownloader* downloader;
 	if(url.getProtocol() == "file")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: local file"));
-		downloader=new LocalDownloader(url.getPath(), cached, owner);
+		downloader=new LocalDownloader(url.getPath(), cache, owner);
 	}
 	else if(url.getProtocol().substr(0, 4) == "rtmp")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: RTMP stream"));
-		downloader=new RTMPDownloader(url.getParsedURL(), url.getStream(), owner);
+		downloader=new RTMPDownloader(url.getParsedURL(), cache, url.getStream(), owner);
 	}
 	else
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: remote file"));
-		downloader=new CurlDownloader(url.getParsedURL(), cached, owner);
+		downloader=new CurlDownloader(url.getParsedURL(), cache, owner);
 	}
 	downloader->enableFencingWaiting();
 	addDownloader(downloader);
@@ -201,7 +203,8 @@
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+Downloader* StandaloneDownloadManager::downloadWithData(const URLInfo& url, _R<StreamCache> cache, 
+		const std::vector<uint8_t>& data,
 		const std::list<tiny_string>& headers, ILoadable* owner)
 {
 	LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager::downloadWithData '") << url.getParsedURL());
@@ -209,14 +212,14 @@
 	if(url.getProtocol() == "file")
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: local file - Ignoring data field"));
-		downloader=new LocalDownloader(url.getPath(), false, owner);
+		downloader=new LocalDownloader(url.getPath(), cache, owner);
 	}
 	else if(url.getProtocol() == "rtmpe")
 		throw RunTimeException("RTMPE does not support additional data");
 	else
 	{
 		LOG(LOG_INFO, _("NET: STANDALONE: DownloadManager: remote file"));
-		downloader=new CurlDownloader(url.getParsedURL(), data, headers, owner);
+		downloader=new CurlDownloader(url.getParsedURL(), cache, data, headers, owner);
 	}
 	downloader->enableFencingWaiting();
 	addDownloader(downloader);
@@ -229,20 +232,15 @@
  *
  * Constructor for the Downloader class. Can only be called from derived classes.
  * \param[in] _url The URL for the Downloader.
- * \param[in] _cached Whether or not to cache this download.
+ * \param[in] _cache StreamCache instance for caching this download.
  */
-Downloader::Downloader(const tiny_string& _url, bool _cached, ILoadable* o):
-	cacheOpened(0),dataAvailable(0),terminated(0),hasTerminated(false),cacheHasOpened(false), //LOCKING
-	waitingForCache(false),waitingForData(false),waitingForTermination(false), //STATUS
-	forceStop(true),failed(false),finished(false),                //FLAGS
+Downloader::Downloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
 	url(_url),originalURL(url),                                   //PROPERTIES
-	buffer(NULL),stableBuffer(NULL),                              //BUFFERING
+	cache(_cache),                                                //CACHING
 	owner(o),                                                     //PROGRESS
-	cachePos(0),cacheSize(0),keepCache(false),cached(_cached),    //CACHING
 	redirected(false),requestStatus(0),                           //HTTP REDIR, STATUS & HEADERS
-	length(0),receivedLength(0)                                   //DOWNLOADED DATA
+	length(0)                                                     //DOWNLOADED DATA
 {
-	setg(NULL,NULL,NULL);
 }
 
 /**
@@ -252,18 +250,13 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-Downloader::Downloader(const tiny_string& _url, const std::vector<uint8_t>& _data, const std::list<tiny_string>& h, ILoadable* o):
-	cacheOpened(0),dataAvailable(0),terminated(0),hasTerminated(false),cacheHasOpened(false), //LOCKING
-	waitingForCache(false),waitingForData(false),waitingForTermination(false), //STATUS
-	forceStop(true),failed(false),finished(false),                   //FLAGS
+Downloader::Downloader(const tiny_string& _url, _R<StreamCache> _cache, const std::vector<uint8_t>& _data, const std::list<tiny_string>& h, ILoadable* o):
 	url(_url),originalURL(url),                                      //PROPERTIES
-	buffer(NULL),stableBuffer(NULL),                                 //BUFFERING
+	cache(_cache),                                                   //CACHING
 	owner(o),                                                        //PROGRESS
-	cachePos(0),cacheSize(0),keepCache(false),cached(false),         //CACHING
 	redirected(false),requestStatus(0),requestHeaders(h),data(_data),//HTTP REDIR, STATUS & HEADERS
-	length(0),receivedLength(0)                                      //DOWNLOADED DATA
+	length(0)                                                        //DOWNLOADED DATA
 {
-	setg(NULL,NULL,NULL);
 }
 
 /**
@@ -275,263 +268,6 @@
  */
 Downloader::~Downloader()
 {
-	waitForTermination();
-
-	Mutex::Lock l(mutex);
-
-	if(cached)
-	{
-		if(cache.is_open())
-			cache.close();
-		if(!keepCache && cacheFilename != "")
-			unlink(cacheFilename.raw_buf());
-	}
-	if(buffer != NULL)
-	{
-		free(buffer);
-	}
-	if(stableBuffer != NULL && stableBuffer!=buffer)
-	{
-		free(stableBuffer);
-	}
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API when there is no more data to read.
- * Waits for the mutex at start and releases the mutex when finished.
- * \throw RunTimeException Cache file could not be read
- */
-Downloader::int_type Downloader::underflow()
-{
-	Mutex::Lock l(mutex);
-	//Let's see if the other buffer contains new data
-	syncBuffers();
-	if(egptr()-gptr()>0)
-	{
-		//There is data already
-		return *(uint8_t*)gptr();
-	}
-	const unsigned int startOffset=getOffset();
-	const unsigned int startReceivedLength=receivedLength;
-	assert(startOffset<=startReceivedLength);
-	//If we have read all available data
-	if(startReceivedLength==startOffset)
-	{
-		//The download has failed or has finished
-		if(failed || finished)
-			return EOF;
-		//We haven't reached the end of the download, more bytes should follow
-		else
-		{
-			waitForData_locked();
-			syncBuffers();
-
-			//Check if we haven't failed or finished (and there wasn't any new data)
-			if(failed || (finished && startReceivedLength==receivedLength))
-				return EOF;
-		}
-	}
-
-	//We should have an initialized buffer here since there is some data
-	assert_and_throw(buffer != NULL);
-	//Temporary pointers to new streambuf read positions
-	char* begin;
-	char* cur;
-	char* end;
-	//Index in the buffer pointing to the data to be returned
-	uint32_t index;
-
-	if(cached)
-	{
-		waitForCache();
-
-		size_t newCacheSize = receivedLength-(cachePos+cacheSize);
-		if(newCacheSize > cacheMaxSize)
-			newCacheSize = cacheMaxSize;
-
-		//Move the start of our new window to the end of our last window
-		cachePos = cachePos+cacheSize;
-		cacheSize = newCacheSize;
-		//Seek to the start of our new window
-		cache.seekg(cachePos);
-		//Read into our buffer window
-		cache.read((char*)stableBuffer, cacheSize);
-		if(cache.fail())
-		{
-			throw RunTimeException(_("Downloader::underflow: reading from cache file failed"));
-		}
-
-		begin=(char*)stableBuffer;
-		cur=(char*)stableBuffer;
-		end=(char*)stableBuffer+cacheSize;
-		index=0;
-
-	}
-	else
-	{
-		begin=(char*)stableBuffer;
-		cur=(char*)stableBuffer+startOffset;
-		end=(char*)stableBuffer+receivedLength;
-		index=startOffset;
-	}
-
-	//If we've failed, don't bother any more
-	if(failed)
-		return EOF;
-
-	//Set our new iterators in the buffer (begin, cursor, end)
-	setg(begin, cur, end);
-
-	//Cast to unsigned, otherwise 0xff would become eof
-	return (unsigned char)stableBuffer[index];
-}
-
-/**
-  * Internal function to synchronize oldBuffer and buffer
-  *
-  * \pre Must be called from a function called by the streambuf API
-  */
-void Downloader::syncBuffers()
-{
-	if(stableBuffer!=buffer)
-	{
-		//The buffer have been changed
-		free(stableBuffer);
-		stableBuffer=buffer;
-		//Remember the relative positions of the input pointers
-		intptr_t curPos = (intptr_t) (gptr()-eback());
-		intptr_t curLen = (intptr_t) (egptr()-eback());
-		//Do some pointer arithmetic to point the input pointers to the right places in the new buffer
-		setg((char*)stableBuffer,(char*)(stableBuffer+curPos),(char*)(stableBuffer+curLen));
-	}
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API to seek to an absolute position
- * Mutex must be locked on entry.
- * \throw RunTimeException Cache file could not be read
- */
-Downloader::pos_type Downloader::seekpos(pos_type pos, std::ios_base::openmode mode)
-{
-	assert_and_throw(mode==std::ios_base::in);
-	assert_and_throw(buffer && stableBuffer);
-
-	syncBuffers();
-
-	// read from stream until we have enough data
-	uint32_t tmplen = receivedLength;
-	while (!hasTerminated && pos > receivedLength) 
-	{
-		waitForData_locked();
-		syncBuffers();
-		if (tmplen == receivedLength)
-			break; // no new data read
-		tmplen = receivedLength;
-	}
-	
-	if(cached)
-	{
-		waitForCache();
-
-		//The requested position is inside our current window
-		if(pos >= cachePos && pos <= cachePos+cacheSize)
-		{
-			//Just move our cursor to the correct position in our window
-			setg((char*)stableBuffer, (char*)stableBuffer+pos-cachePos, (char*)stableBuffer+cacheSize);
-		}
-		//The requested position is outside our current window
-		else if(pos <= receivedLength)
-		{
-			cachePos = pos;
-			cacheSize = receivedLength-pos;
-			if(cacheSize > cacheMaxSize)
-				cacheSize = cacheMaxSize;
-
-			//Seek to the requested position
-			cache.seekg(cachePos);
-			//Read into our window
-			cache.read((char*)stableBuffer, cacheSize);
-			if(cache.fail())
-				throw RunTimeException(_("Downloader::seekpos: reading from cache file failed"));
-
-			//Our window starts at position pos
-			setg((char*) stableBuffer, (char*) stableBuffer, ((char*) stableBuffer)+cacheSize);
-		}
-		//The requested position is bigger then our current amount of available data
-		else if(pos > receivedLength)
-			return -1;
-	}
-	else
-	{
-		//The requested position is valid
-		if(pos <= receivedLength)
-			setg((char*)stableBuffer,(char*)stableBuffer+pos,(char*)stableBuffer+receivedLength);
-		//The requested position is bigger then our current amount of available data
-		else
-			return -1;
-	}
-
-	return pos;
-}
-
-/**
- * \brief Called by the streambuf API
- *
- * Called by the streambuf API to seek to a relative position
- * Waits for the mutex at start and releases the mutex when finished.
- */
-Downloader::pos_type Downloader::seekoff(off_type off, std::ios_base::seekdir dir, std::ios_base::openmode mode)
-{
-	assert_and_throw(mode==std::ios_base::in);
-	assert_and_throw(buffer != NULL);
-
-	Mutex::Lock l(mutex);
-	if (off != 0)
-	{
-		switch (dir)
-		{
-			case std::ios_base::beg:
-				seekpos(off,mode);
-				break;
-			case std::ios_base::cur:
-			{
-				pos_type tmp = getOffset();
-				seekpos(tmp+off,mode);
-				break;
-			}
-			case std::ios_base::end:
-				l.release();
-				waitForTermination();
-				l.acquire();
-				if (finished)
-					seekpos(length+off,mode);
-				break;
-			default:
-				break;
-		}
-	}
-
-	return getOffset();
-}
-
-/**
- * \brief Get the position of the read cursor in the (virtual) downloaded data
- *
- * Get the position of the read cursor in the (virtual) downloaded data.
- * If downloading to memory this method returns the position of the read cursor in the buffer.
- * If downloading to a cache file, this method returns the position of the read cursor in the buffer
- * + the position of the buffer window into the cache file.
- */
-Downloader::pos_type Downloader::getOffset() const
-{
-	pos_type ret = gptr()-eback();
-	if(cached)
-		ret+=cachePos;
-	return ret;
 }
 
 /**
@@ -541,28 +277,13 @@
  * signals \c dataAvailable if it is being waited for.
  * It also signals \c terminated to mark the end of the download.
  * A download should finish be either calling \c setFailed() or \c setFinished(), not both.
- * \post \c failed == \c true & \c finished == \c true
  * \post \c length == \c receivedLength
- * \post Signals \c dataAvailable if it is being waited for (\c waitingForData == \c true). 
- * \post \c waitingForTermination == \c false
- * \post Signals \c terminated
  */
 void Downloader::setFailed()
 {
-	failed=true;
-	finished = true;
+	cache->markFinished(true);
 	//Set the final length
-	length = receivedLength;
-
-	//If we are waiting for data to become available, signal dataAvailable
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
-
-	waitingForTermination = false;
-	terminated.signal();
+	length = cache->getReceivedLength();
 }
 
 /**
@@ -572,139 +293,13 @@
  * signals \c dataAvailable if it is being waited for.
  * It also signals \c terminated to mark the end of the download.
  * A download should finish be either calling \c setFailed() or \c setFinished(), not both.
- * \post \c finished == \ctrue
  * \post \c length == \c receivedLength
- * \post Signals \c dataAvailable if it is being waited for (\c waitingForData == true).
- * \post \c waitingForTermination == \c false
- * \post Signals \c terminated
  */
 void Downloader::setFinished()
 {
-	finished=true;
+	cache->markFinished();
 	//Set the final length
-	length = receivedLength;
-
-	//If we are waiting for data to become available, signal dataAvailable
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
-
-	waitingForTermination = false;
-	terminated.signal();
-}
-
-/**
- * \brief (Re)allocates the buffer
- *
- * (Re)allocates the buffer to a given size
- * Waits for mutex at start and releases mutex when finished.
- * \post \c buffer is (re)allocated
- * mutex must be locked on entry
- */
-void Downloader::allocateBuffer(size_t size)
-{
-	//Create buffer
-	if(buffer == NULL)
-	{
-		buffer = (uint8_t*) calloc(size, sizeof(uint8_t));
-		stableBuffer = buffer;
-		setg((char*)buffer,(char*)buffer,(char*)buffer);
-	}
-	//If the buffer already exists, reallocate
-	else
-	{
-		assert(!cached);
-		intptr_t curLen = receivedLength;
-		//We have to extend the buffer, so create a new one
-		if(stableBuffer!=buffer)
-		{
-			//We're already filling a different buffer from the one used to read
-			//Extend it!
-			buffer = (uint8_t*)realloc(buffer,size);
-		}
-		else
-		{
-			//Create a different buffer
-			buffer = (uint8_t*) calloc(size, sizeof(uint8_t));
-			//Copy the stableBuffer into this
-			memcpy(buffer,stableBuffer,curLen);
-		}
-		//Synchronization of the buffers will be done at the first chance
-	}
-}
-
-/**
- * \brief Creates & opens a temporary cache file
- *
- * Creates a temporary cache file in /tmp and calls \c openExistingCache() with that file.
- * Waits for mutex at start and releases mutex when finished.
- * \throw RunTimeException Temporary file could not be created
- * \throw RunTimeException Called when the downloader isn't cached or when the cache is already open
- * \see Downloader::openExistingCache()
- * mutex must be hold prior calling
- */
-void Downloader::openCache()
-{
-	//Only act if the downloader is cached and the cache hasn't been opened yet
-	if(cached && !cache.is_open())
-	{
-		//Create a temporary file(name)
-		std::string cacheFilenameS = Config::getConfig()->getCacheDirectory() + "/" + Config::getConfig()->getCachePrefix() + "XXXXXX";
-		char* cacheFilenameC = g_newa(char,cacheFilenameS.length()+1);
-		strncpy(cacheFilenameC, cacheFilenameS.c_str(), cacheFilenameS.length());
-		cacheFilenameC[cacheFilenameS.length()] = '\0';
-		//char cacheFilenameC[30] = "/tmp/lightsparkdownloadXXXXXX";
-		//strcpy(cacheFilenameC, "/tmp/lightsparkdownloadXXXXXX");
-		int fd = g_mkstemp(cacheFilenameC);
-		if(fd == -1)
-			throw RunTimeException(_("Downloader::openCache: cannot create temporary file"));
-		//We are using fstream to read/write to the cache, so we don't need this FD
-		close(fd);
-
-		//Let the openExistingCache function handle the rest
-		openExistingCache(tiny_string(cacheFilenameC, true));
-	}
-	else
-		throw RunTimeException(_("Downloader::openCache: downloader isn't cached or called twice"));
-}
-
-/**
- * \brief Opens an existing cache file
- *
- * Opens an existing cache file, allocates the buffer and signals \c cacheOpened.
- * Waits for mutex at start and releases mutex when finished.
- * \post \c cacheFilename is set
- * \post \c cache file is opened
- * \post \c buffer is initialized
- * \post \c cacheOpened is signalled
- * \throw RunTimeException File could not be opened
- * \throw RunTimeException Called when the downloader isn't cached or when the cache is already open
- * \see Downloader::allocateBuffer()
- * mutex must be hold on entering
- */
-void Downloader::openExistingCache(tiny_string filename)
-{
-	//Only act if the downloader is cached and the cache hasn't been opened yet
-	if(cached && !cache.is_open())
-	{
-		//Save the filename
-		cacheFilename = filename;
-
-		//Open the cache file
-		cache.open(cacheFilename.raw_buf(), std::fstream::binary | std::fstream::in | std::fstream::out);
-		if(!cache.is_open())
-			throw RunTimeException(_("Downloader::openCache: cannot open temporary cache file"));
-
-		allocateBuffer(cacheMaxSize);
-
-		LOG(LOG_INFO, _("NET: Downloading to cache file: ") << cacheFilename);
-
-		cacheOpened.signal();
-	}
-	else
-		throw RunTimeException(_("Downloader::openCache: downloader isn't cached or called twice"));
+	length = cache->getReceivedLength();
 }
 
 /**
@@ -712,27 +307,14 @@
  *
  * Sets the expected length of the download.
  * Can be called multiple times if the length isn't known up front (reallocating the buffer on the fly).
- * Waits for mutex at start and releases mutex when finished.
- * \post \c buffer is (re)allocated 
- * mutex must be hold prior calling
  */
 void Downloader::setLength(uint32_t _length)
 {
 	//Set the length
 	length=_length;
 
-	//The first call to this function should open the cache
-	if(cached)
-	{
-		if(!cache.is_open())
-			openCache();
-	}
-	else
-	{
-		if(buffer == NULL)
-			LOG(LOG_INFO, _("NET: Downloading to memory"));
-		allocateBuffer(length);
-	}
+	cache->reserve(length);
+
 	notifyOwnerAboutBytesTotal();
 }
 
@@ -752,39 +334,9 @@
 	if(added==0)
 		return;
 
-	Mutex::Lock l(mutex);
-
-	//If the added data would overflow the buffer, grow it
-	if((receivedLength+added)>length)
-	{
-		uint32_t newLength;
-		assert(length>=receivedLength);
-		//If reallocating the buffer ask for a minimum amount of space
-		if((receivedLength+added)-length > bufferMinGrowth)
-			newLength = receivedLength + added;
-		else
-			newLength = length + bufferMinGrowth;
-		assert(newLength>=receivedLength+added);
-
-		setLength(newLength);
-	}
-
-	if(cached)
-	{
-		//Seek to where we last wrote data
-		cache.seekp(receivedLength);
-		cache.write((char*) buf, added);
-	}
-	else
-		memcpy(buffer+receivedLength, buf, added);
-
-	receivedLength += added;
-
-	if(waitingForData)
-	{
-		waitingForData = false;
-		dataAvailable.signal();
-	}
+	cache->append((unsigned char *)buf, added);
+	if (cache->getReceivedLength() > length)
+		setLength(cache->getReceivedLength());
 
 	notifyOwnerAboutBytesLoaded();
 }
@@ -824,8 +376,6 @@
  */
 void Downloader::parseHeader(std::string header, bool _setLength)
 {
-	Mutex::Lock l(mutex);
-
 	if(header.substr(0, 9) == "HTTP/1.1 " || header.substr(0, 9) == "HTTP/1.0 ") 
 	{
 		std::string status = header.substr(9, 3);
@@ -891,83 +441,8 @@
  */
 void Downloader::stop()
 {
-	failed = true;
-	finished = true;
-	length = receivedLength;
-
-	waitingForData = false;
-	dataAvailable.signal();
-
-	waitingForTermination = false;
-	terminated.signal();
-}
-
-/**
- * \brief Wait for the cache file to be opened
- *
- * If \c !cacheHasOpened: wait for the \c cacheOpened signal and set \c cacheHasOpened to \c true
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c cacheOpened signals has been handled
- * \post \c cacheHasOpened = true
- * mutex must be locked on entry
- */
-void Downloader::waitForCache()
-{
-	if(!cacheHasOpened)
-	{
-		waitingForCache = true;
-
-		mutex.unlock();
-		cacheOpened.wait();
-		mutex.lock();
-
-		cacheHasOpened = true;
-	}
-}
-
-/**
- * \brief Wait for data to become available
- *
- * Wait for data to become available.
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c dataAvailable signal has been handled
- */
-void Downloader::waitForData_locked()
-{
-	waitingForData = true;
-	mutex.unlock();
-	dataAvailable.wait();
-	mutex.lock();
-}
-
-/**
- * \brief Wait for termination of the downloader
- *
- * If \c getSys()->isShuttingDown(), calls \c setFailed() and returns.
- * Otherwise if \c !hasTerminated: wait for the \c terminated signal and set \c hasTerminated to \c true
- * Waits for the mutex at start and releases the mutex when finished.
- * \post \c terminated signal has been handled
- * \post \c hasTerminated = true
- */
-void Downloader::waitForTermination()
-{
-	Mutex::Lock l(mutex);
-	if(getSys()->isShuttingDown())
-	{
-		setFailed();
-		return;
-	}
-
-	if(!hasTerminated)
-	{
-		waitingForTermination = true;
-
-		l.release();
-		terminated.wait();
-		l.acquire();
-
-		hasTerminated = true;
-	}
+	cache->markFinished(true);
+	length = cache->getReceivedLength();
 }
 
 void Downloader::notifyOwnerAboutBytesTotal() const
@@ -979,7 +454,7 @@
 void Downloader::notifyOwnerAboutBytesLoaded() const
 {
 	if(owner)
-		owner->setBytesLoaded(receivedLength);
+		owner->setBytesLoaded(cache->getReceivedLength());
 }
 
 void ThreadedDownloader::enableFencingWaiting()
@@ -1010,8 +485,8 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-ThreadedDownloader::ThreadedDownloader(const tiny_string& url, bool cached, ILoadable* o):
-	Downloader(url, cached, o),fenceState(false)
+ThreadedDownloader::ThreadedDownloader(const tiny_string& url, _R <StreamCache> cache, ILoadable* o):
+	Downloader(url, cache, o),fenceState(false)
 {
 }
 
@@ -1022,9 +497,10 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-ThreadedDownloader::ThreadedDownloader(const tiny_string& url, const std::vector<uint8_t>& data,
+ThreadedDownloader::ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache,
+				       const std::vector<uint8_t>& data,
 				       const std::list<tiny_string>& headers, ILoadable* o):
-	Downloader(url, data, headers, o),fenceState(false)
+	Downloader(url, cache, data, headers, o),fenceState(false)
 {
 }
 
@@ -1046,8 +522,8 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-CurlDownloader::CurlDownloader(const tiny_string& _url, bool _cached, ILoadable* o):
-	ThreadedDownloader(_url, _cached, o)
+CurlDownloader::CurlDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o)
 {
 }
 
@@ -1057,9 +533,10 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] data Additional data to send to the host
  */
-CurlDownloader::CurlDownloader(const tiny_string& _url, const std::vector<uint8_t>& _data,
+CurlDownloader::CurlDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+			       const std::vector<uint8_t>& _data,
 			       const std::list<tiny_string>& _headers, ILoadable* o):
-	ThreadedDownloader(_url, _data, _headers, o)
+	ThreadedDownloader(_url, _cache, _data, _headers, o)
 {
 }
 
@@ -1180,7 +657,7 @@
 int CurlDownloader::progress_callback(void *clientp, double dltotal, double dlnow, double ultotal, double ulnow)
 {
 	CurlDownloader* th=static_cast<CurlDownloader*>(clientp);
-	return th->threadAborting || th->failed;
+	return th->threadAborting || th->cache->hasFailed();
 }
 
 /**
@@ -1224,7 +701,8 @@
  * \param[in] _url The URL for the Downloader.
  * \param[in] _cached Whether or not to cache this download.
  */
-LocalDownloader::LocalDownloader(const tiny_string& _url, bool _cached, ILoadable* o):ThreadedDownloader(_url, _cached, o)
+LocalDownloader::LocalDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o)
 {
 }
 
@@ -1256,18 +734,14 @@
 		LOG(LOG_INFO, _("NET: LocalDownloader::execute: reading local file: ") << url.raw_buf());
 		//If the caching is selected, we override the normal behaviour and use the local file as the cache file
 		//This prevents unneeded copying of the file's data
-		if(isCached())
-		{
-			Mutex::Lock l(mutex);
-			//Make sure we don't delete the local file afterwards
-			keepCache = true;
 
-			openExistingCache(url);
+		FileStreamCache *fileCache = dynamic_cast<FileStreamCache *>(cache.getPtr());
+		if (fileCache)
+		{
+			fileCache->useExistingFile(url);
 
-			cache.seekg(0, std::ios::end);
 			//Report that we've downloaded everything already
-			length = cache.tellg();
-			receivedLength = length;
+			length = fileCache->getReceivedLength();
 			notifyOwnerAboutBytesLoaded();
 			notifyOwnerAboutBytesTotal();
 		}
@@ -1280,7 +754,6 @@
 			{
 				file.seekg(0, std::ios::end);
 				{
-					Mutex::Lock l(mutex);
 					setLength(file.tellg());
 				}
 				file.seekg(0, std::ios::beg);
@@ -1290,7 +763,7 @@
 				bool readFailed = 0;
 				while(!file.eof())
 				{
-					if(file.fail() || hasFailed())
+					if(file.fail() || cache->hasFailed())
 					{
 						readFailed = 1;
 						break;
@@ -1329,7 +802,7 @@
 	}
 }
 
-bool DownloaderThreadBase::createDownloader(bool cached,
+bool DownloaderThreadBase::createDownloader(_R<StreamCache> cache,
 					    _NR<EventDispatcher> dispatcher,
 					    ILoadable* owner,
 					    bool checkPolicyFile)
@@ -1355,11 +828,11 @@
 	if(postData.empty())
 	{
 		//This is a GET request
-		downloader=getSys()->downloadManager->download(url, cached, owner);
+		downloader=getSys()->downloadManager->download(url, cache, owner);
 	}
 	else
 	{
-		downloader=getSys()->downloadManager->downloadWithData(url, postData, requestHeaders, owner);
+		downloader=getSys()->downloadManager->downloadWithData(url, cache, postData, requestHeaders, owner);
 	}
 
 	return true;
diff -Nuar lightspark-0.7.2.orig/src/backends/netutils.h lightspark-0.7.2/src/backends/netutils.h
--- lightspark-0.7.2.orig/src/backends/netutils.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/netutils.h	2013-11-09 19:23:31.000000000 +0200
@@ -29,6 +29,7 @@
 #include "swftypes.h"
 #include "thread_pool.h"
 #include "backends/urlutils.h"
+#include "backends/streamcache.h"
 #include "smartrefs.h"
 
 namespace lightspark
@@ -57,8 +58,9 @@
 	void cleanUp();
 public:
 	virtual ~DownloadManager();
-	virtual Downloader* download(const URLInfo& url, bool cached, ILoadable* owner)=0;
-	virtual Downloader* downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+	virtual Downloader* download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner)=0;
+	virtual Downloader* downloadWithData(const URLInfo& url, _R<StreamCache> cache, 
+			const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, ILoadable* owner)=0;
 	virtual void destroy(Downloader* downloader)=0;
 	void stopAll();
@@ -72,57 +74,22 @@
 public:
 	StandaloneDownloadManager();
 	~StandaloneDownloadManager();
-	Downloader* download(const URLInfo& url, bool cached, ILoadable* owner);
-	Downloader* downloadWithData(const URLInfo& url, const std::vector<uint8_t>& data,
+	Downloader* download(const URLInfo& url, _R<StreamCache> cache, ILoadable* owner);
+	Downloader* downloadWithData(const URLInfo& url, _R<StreamCache> cache,
+			const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, ILoadable* owner);
 	void destroy(Downloader* downloader);
 };
 
-class DLL_PUBLIC Downloader: public std::streambuf
+class DLL_PUBLIC Downloader
 {
-private:
-	//Handles streambuf out-of-data events
-	virtual int_type underflow();
-	//Seeks to absolute position
-	virtual pos_type seekoff(off_type, std::ios_base::seekdir, std::ios_base::openmode);
-	//Seeks to relative position
-	virtual pos_type seekpos(pos_type, std::ios_base::openmode);
-	//Helper to get the current offset
-	pos_type getOffset() const;
 protected:
 	//Abstract base class, can't be constructed
-	Downloader(const tiny_string& _url, bool _cached, ILoadable* o);
-	Downloader(const tiny_string& _url, const std::vector<uint8_t>& data,
+	Downloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o);
+	Downloader(const tiny_string& _url, _R<StreamCache> _cache, const std::vector<uint8_t>& data,
 		   const std::list<tiny_string>& headers, ILoadable* o);
-	//-- LOCKING
-	//Provides internal mutual exclusing
-	Mutex mutex;
-	//Signals the cache opening
-	Semaphore cacheOpened;
-	//Signals new bytes available for reading
-	Semaphore dataAvailable;
-	//Signals termination of the download
-	Semaphore terminated;
-	//True if the download is terminated
-	bool hasTerminated;
-	//True if cache has opened
-	bool cacheHasOpened;
-
-	//-- STATUS
-	//True if the downloader is waiting for the cache to be opened
-	bool waitingForCache;
-	//True if the downloader is waiting for data
-	bool waitingForData;
-	void waitForData_locked();
-	//True if the downloader is waiting for termination
-	bool waitingForTermination;
 
 	//-- FLAGS
-	//This flag forces a stop in internal code
-	bool forceStop;
-	//These flags specify what type of termination happened
-	bool failed;
-	bool finished;
 	//Mark the download as failed
 	void setFailed();
 	//Mark the download as finished
@@ -132,43 +99,14 @@
 	tiny_string url;
 	tiny_string originalURL;
 
-	//-- BUFFERING
-	//This will hold the whole download (non-cached) or a window into the download (cached)
-	uint8_t* buffer;
-	//We can't change the used buffer (for example when resizing) asynchronously. We can only do that on underflows
-	uint8_t* stableBuffer;
-	//Minimum growth of the buffer
-	static const size_t bufferMinGrowth = 4096;
-	//(Re)allocate the buffer
-	void allocateBuffer(size_t size);
-	//Synchronize stableBuffer and buffer
-	void syncBuffers();
+	//-- CACHING
+        _R<StreamCache> cache;
 
 	//-- PROGRESS MONITORING
 	ILoadable* owner;
 	void notifyOwnerAboutBytesTotal() const;
 	void notifyOwnerAboutBytesLoaded() const;
 
-	//-- CACHING
-	//Cache filename
-	tiny_string cacheFilename;
-	//Cache fstream
-	std::fstream cache;
-	//Position of the cache buffer into the file
-	uint32_t cachePos;
-	//Size of data in the buffer
-	uint32_t cacheSize;
-	//Maximum size of the cache buffer
-	static const size_t cacheMaxSize = 8192;
-	//True if the cache file doesn't need to be deleted on destruction
-	bool keepCache:1;
-	//True if the file is cached to disk (default = false)
-	bool cached:1;
-	//Creates & opens a temporary cache file
-	void openCache();
-	//Opens an existing cache file
-	void openExistingCache(tiny_string filename);
-
 	//-- HTTP REDIRECTION, STATUS & HEADERS
 	bool redirected:1;
 	void setRedirected(const tiny_string& newURL)
@@ -187,8 +125,6 @@
 	//-- DOWNLOADED DATA
 	//File length (can change in certain cases, resulting in reallocation of the buffer (non-cached))
 	uint32_t length;
-	//Amount of data already received
-	uint32_t receivedLength;
 	//Append data to the internal buffer
 	void append(uint8_t* buffer, uint32_t length);
 	//Set the length of the downloaded file, can be called multiple times to accomodate a growing file
@@ -198,28 +134,23 @@
 	virtual ~Downloader();
 	//Stop the download
 	void stop();
-	//Wait for cache to be opened
-	void waitForCache();
-	//Wait for data to become available
-	void waitForData() { Mutex::Lock l(mutex); waitForData_locked(); }
-	//Wait for the download to terminate
-	void waitForTermination();
 
 	//True if the download has failed
-	bool hasFailed() { return failed; }
+	bool hasFailed() { return cache->hasFailed(); }
 	//True if the download has finished
 	//Can be used in conjunction with failed to find out if it finished successfully
-	bool hasFinished() { return finished; }
-
-	//True if the download is cached
-	bool isCached() { return cached; }
+	bool hasFinished() { return cache->hasTerminated(); }
 
 	const tiny_string& getURL() { return url; }
 
+	//Wait until the downloader completes
+	void waitForTermination() { return cache->waitForTermination(); }
+
+	_R<StreamCache> getCache() { return cache; }
 	//Gets the total length of the downloaded file (may change)
 	uint32_t getLength() { return length; }
 	//Gets the length of downloaded data
-	uint32_t getReceivedLength() { return receivedLength; }
+	uint32_t getReceivedLength() { return cache->getReceivedLength(); }
 
 	size_t getHeaderCount() { return headers.size(); }
 	tiny_string getHeader(const char* header) { return getHeader(tiny_string(header)); }
@@ -245,8 +176,9 @@
 	void waitFencing();
 protected:
 	//Abstract base class, can not be constructed
-	ThreadedDownloader(const tiny_string& url, bool cached, ILoadable* o);
-	ThreadedDownloader(const tiny_string& url, const std::vector<uint8_t>& data,
+	ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache, ILoadable* o);
+	ThreadedDownloader(const tiny_string& url, _R<StreamCache> cache,
+			   const std::vector<uint8_t>& data,
 			   const std::list<tiny_string>& headers, ILoadable* o);
 //	//This class can only get destroyed by DownloadManager
 //	virtual ~ThreadedDownloader();
@@ -262,8 +194,8 @@
 	void execute();
 	void threadAbort();
 public:
-	CurlDownloader(const tiny_string& _url, bool _cached, ILoadable* o);
-	CurlDownloader(const tiny_string& _url, const std::vector<uint8_t>& data,
+	CurlDownloader(const tiny_string& _url, _R<StreamCache> cache, ILoadable* o);
+	CurlDownloader(const tiny_string& _url, _R<StreamCache> cache, const std::vector<uint8_t>& data,
 		       const std::list<tiny_string>& headers, ILoadable* o);
 };
 
@@ -280,7 +212,7 @@
 	//Size of the reading buffer
 	static const size_t bufSize = 8192;
 public:
-	LocalDownloader(const tiny_string& _url, bool _cached, ILoadable* o);
+	LocalDownloader(const tiny_string& _url, _R<StreamCache> _cache, ILoadable* o);
 };
 
 class IDownloaderThreadListener
@@ -306,7 +238,7 @@
 	std::list<tiny_string> requestHeaders;
 	Spinlock downloaderLock;
 	Downloader* downloader;
-	bool createDownloader(bool cached,
+	bool createDownloader(_R<StreamCache> cache,
 			      _NR<EventDispatcher> dispatcher=NullRef,
 			      ILoadable* owner=NULL,
 			      bool checkPolicyFile=true);
diff -Nuar lightspark-0.7.2.orig/src/backends/rendering.cpp lightspark-0.7.2/src/backends/rendering.cpp
--- lightspark-0.7.2.orig/src/backends/rendering.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/rendering.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -46,10 +46,10 @@
 /* calculate FPS every second */
 const Glib::TimeVal RenderThread::FPS_time(/*seconds*/1,/*microseconds*/0);
 
-static GStaticPrivate renderThread = G_STATIC_PRIVATE_INIT; /* TLS */
+DEFINE_AND_INITIALIZE_TLS(renderThread);
 RenderThread* lightspark::getRenderThread()
 {
-	RenderThread* ret = (RenderThread*)g_static_private_get(&renderThread);
+	RenderThread* ret = (RenderThread*)tls_get(&renderThread);
 	/* If this is NULL, then you are not calling from the render thread,
 	 * which is disallowed! (OpenGL is not threadsafe)
 	 */
@@ -326,7 +326,7 @@
 {
 	setTLSSys(m_sys);
 	/* set TLS variable for getRenderThread() */
-	g_static_private_set(&renderThread, this, NULL);
+	tls_set(&renderThread, this);
 
 	ThreadProfile* profile=m_sys->allocateProfiler(RGB(200,0,0));
 	profile->setTag("Render");
diff -Nuar lightspark-0.7.2.orig/src/backends/rtmputils.cpp lightspark-0.7.2/src/backends/rtmputils.cpp
--- lightspark-0.7.2.orig/src/backends/rtmputils.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/rtmputils.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -20,6 +20,7 @@
 #include "backends/rtmputils.h"
 #include "logger.h"
 #include "swf.h"
+#include "backends/streamcache.h"
 
 #ifdef ENABLE_RTMP
 #include <librtmp/rtmp.h>
@@ -28,8 +29,9 @@
 using namespace lightspark;
 using namespace std;
 
-RTMPDownloader::RTMPDownloader(const tiny_string& _url, const tiny_string& _stream, ILoadable* o):
-	ThreadedDownloader(_url, true, o),
+RTMPDownloader::RTMPDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+			       const tiny_string& _stream, ILoadable* o):
+	ThreadedDownloader(_url, _cache, o),
 	stream(_stream)
 {
 }
diff -Nuar lightspark-0.7.2.orig/src/backends/rtmputils.h lightspark-0.7.2/src/backends/rtmputils.h
--- lightspark-0.7.2.orig/src/backends/rtmputils.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/rtmputils.h	2013-11-09 19:23:31.000000000 +0200
@@ -34,7 +34,8 @@
 	void threadAbort();
 	tiny_string stream;
 public:
-	RTMPDownloader(const tiny_string& _url, const tiny_string& _stream, ILoadable* o);
+	RTMPDownloader(const tiny_string& _url, _R<StreamCache> _cache,
+		       const tiny_string& _stream, ILoadable* o);
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/src/backends/security.cpp lightspark-0.7.2/src/backends/security.cpp
--- lightspark-0.7.2.orig/src/backends/security.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/security.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -1001,7 +1001,7 @@
 	bool ok = true;
 
 	//No caching needed for this download, we don't expect very big files
-	Downloader* downloader=getSys()->downloadManager->download(url, false, NULL);
+	Downloader* downloader=getSys()->downloadManager->download(url, _MR(new MemoryStreamCache), NULL);
 
 	//Wait until the file is fetched
 	downloader->waitForTermination();
@@ -1052,11 +1052,13 @@
 
 	if (ok)
 	{
-		istream s(downloader);
+		std::streambuf *sbuf = downloader->getCache()->createReader();
+		istream s(sbuf);
 		size_t bufLength = downloader->getLength();
 		size_t offset = outData.size();
 		outData.resize(offset+bufLength);
 		s.read((char*)&outData[offset], bufLength);
+		delete sbuf;
 	}
 
 	getSys()->downloadManager->destroy(downloader);
diff -Nuar lightspark-0.7.2.orig/src/backends/streamcache.cpp lightspark-0.7.2/src/backends/streamcache.cpp
--- lightspark-0.7.2.orig/src/backends/streamcache.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/backends/streamcache.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,499 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include <string.h>
+#include <unistd.h>
+#include <glib.h>
+#include "backends/streamcache.h"
+#include "backends/config.h"
+#include "exceptions.h"
+#include "logger.h"
+
+using namespace std;
+using namespace lightspark;
+
+StreamCache::StreamCache()
+  : receivedLength(0), failed(false), terminated(false)
+{
+}
+
+void StreamCache::markFinished(bool _failed)
+{
+	Locker locker(stateMutex);
+	if (terminated)
+		return;
+
+	failed = _failed;
+	terminated = true;
+	stateCond.broadcast();
+}
+
+void StreamCache::waitForData(size_t currentOffset)
+{
+	Locker locker(stateMutex);
+	while (receivedLength <= currentOffset && !terminated)
+		stateCond.wait(stateMutex);
+}
+
+void StreamCache::waitForTermination()
+{
+	Locker locker(stateMutex);
+	while (!terminated)
+		stateCond.wait(stateMutex);
+}
+
+void StreamCache::append(const unsigned char* buffer, size_t length)
+{
+	if (!buffer || length == 0 || terminated)
+		return;
+
+	handleAppend(buffer, length);
+
+	{
+		Locker locker(stateMutex);
+		receivedLength += length;
+		stateCond.broadcast();
+	}
+}
+
+class lightspark::MemoryChunk {
+public:
+	MemoryChunk(size_t len);
+	~MemoryChunk();
+	unsigned char * const buffer;
+	const size_t capacity;
+	ACQUIRE_RELEASE_VARIABLE(size_t, used);
+};
+
+MemoryChunk::MemoryChunk(size_t len) :
+	buffer(new unsigned char[len]), capacity(len), used(0)
+{
+}
+
+MemoryChunk::~MemoryChunk()
+{
+	delete[] buffer;
+}
+
+MemoryStreamCache::MemoryStreamCache():
+	writeChunk(NULL), nextChunkSize(0)
+{
+}
+
+MemoryStreamCache::~MemoryStreamCache()
+{
+	for (auto it=chunks.begin(); it!=chunks.end(); ++it)
+		delete *it;
+}
+
+// Rounds val up to the next multiple of pow(2, s).
+static size_t nextMultipleOf2Pow(size_t val, size_t s)
+{
+	return ((size_t)((double)(val-1) / (1 << s)) + 1) << s;
+}
+
+void MemoryStreamCache::allocateChunk(size_t minLength)
+{
+	size_t len = imax(imax(minLength, minChunkSize), nextChunkSize);
+	len = nextMultipleOf2Pow(len, 12);
+	assert(len >= minLength);
+	nextChunkSize = len;
+
+	{
+		Locker locker(chunkListMutex);
+		writeChunk = new MemoryChunk(len);
+		chunks.push_back(writeChunk);
+	}
+}
+
+void MemoryStreamCache::handleAppend(const unsigned char* data, size_t length)
+{
+	assert(length > 0);
+
+	if (!writeChunk || (ACQUIRE_READ(writeChunk->used) >= writeChunk->capacity))
+		allocateChunk(length);
+
+	assert(writeChunk);
+
+	size_t used = ACQUIRE_READ(writeChunk->used);
+	if (writeChunk->capacity >= used + length)
+	{
+		// Data fits in to the current chunk
+		memcpy(writeChunk->buffer + used, data, length);
+		RELEASE_WRITE(writeChunk->used, used + length);
+	}
+	else
+	{
+		// Write as much as possible to the current buffer
+		size_t unused = writeChunk->capacity - used;
+		memcpy(writeChunk->buffer + used, data, unused);
+		RELEASE_WRITE(writeChunk->used, writeChunk->capacity);
+
+		// allocate a new chunk by a recursive call
+		handleAppend(data + unused, length - unused);
+	}
+}
+
+void MemoryStreamCache::reserve(size_t expectedLength)
+{
+	if (expectedLength <= receivedLength)
+		return;
+
+	// Set the next chunk to be large enough to hold the remaining
+	// of the stream. The memory will be actually allocated in
+	// append().
+	size_t unused = 0;
+	if (writeChunk)
+		unused = writeChunk->capacity - ACQUIRE_READ(writeChunk->used);
+
+	size_t allocated = receivedLength + unused;
+	if (expectedLength > allocated)
+		nextChunkSize = expectedLength - allocated;
+}
+
+std::streambuf *MemoryStreamCache::createReader()
+{
+	incRef();
+	return new MemoryStreamCache::Reader(_MR(this));
+}
+
+MemoryStreamCache::Reader::Reader(_R<MemoryStreamCache> b) :
+	buffer(b), chunkIndex(0), chunkStartOffset(0)
+{
+	setg(NULL, NULL, NULL);
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API when there is no more data to read.
+ */
+int MemoryStreamCache::Reader::underflow()
+{
+	Locker locker(buffer->chunkListMutex);
+
+	// Wait until there is some data to be read or until terminated
+	bool hasMoreChunks = chunkIndex+1 < buffer->chunks.size();
+	bool lastChunkHasBytes = (chunkIndex+1 == buffer->chunks.size()) && 
+		((size_t)(gptr() - eback()) < ACQUIRE_READ(buffer->chunks[chunkIndex]->used));
+	if (!buffer->hasTerminated() && !hasMoreChunks && !lastChunkHasBytes)
+	{
+		locker.release();
+		buffer->waitForData(getOffset());
+		locker.acquire();
+	}
+
+	if (chunkIndex >= buffer->chunks.size())
+	{
+		// This can only happen if the stream is terminated
+		// before any data is written.
+		assert(chunkIndex == 0);
+		assert(buffer->hasTerminated());
+		return EOF;
+	}
+
+	MemoryChunk *chunk = buffer->chunks[chunkIndex];
+	size_t used = ACQUIRE_READ(chunk->used);
+	unsigned char *cursor;
+	unsigned char *end = chunk->buffer + used;
+
+	if (gptr() == NULL)
+	{
+		// On the first call gptr() is NULL (as set in the
+		// constructor). Nothing has been read yet.
+		cursor = chunk->buffer;
+	}
+	else if ((unsigned char*)gptr() < end)
+	{
+		// Data left in this chunk
+		cursor = (unsigned char*)gptr();
+	}
+	else if (chunkIndex == buffer->chunks.size()-1)
+	{
+		// This is the last received chunk and there is no
+		// data to be read => we're finished
+		assert(buffer->hasTerminated());
+		return EOF;
+	}
+	else
+	{
+		// Move to the next chunk
+		chunkStartOffset = chunkStartOffset + used;
+		chunkIndex++;
+
+		// chunkIndex is still valid, because the case
+		// size()-1 was handled above
+		assert_and_throw(chunkIndex < buffer->chunks.size());
+
+		chunk = buffer->chunks[chunkIndex];
+		cursor = chunk->buffer;
+		end = chunk->buffer + ACQUIRE_READ(chunk->used);
+	}
+
+	setg((char *)chunk->buffer, (char *)cursor, (char *)end);
+
+	assert(cursor != end); // there is at least one byte to return
+	return (int)cursor[0];
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API to seek to a relative position
+ */
+streampos MemoryStreamCache::Reader::seekoff(streamoff off, std::ios_base::seekdir dir,
+					     std::ios_base::openmode mode)
+{
+	if (mode != std::ios_base::in)
+		return -1;
+
+	switch (dir)
+	{
+		case std::ios_base::beg:
+			seekpos(off, mode);
+			break;
+		case std::ios_base::cur:
+			// TODO: optimize by checking if the new
+			// offset is in the current chunk
+			seekpos(getOffset() + off, mode);
+			break;
+		case std::ios_base::end:
+			buffer->waitForTermination();
+			if (buffer->hasFailed())
+				return -1;
+
+			seekpos((streampos)buffer->getReceivedLength() + off, mode);
+			break;
+		default:
+			break;
+	}
+
+	return getOffset();
+}
+
+/**
+ * \brief Called by the streambuf API
+ *
+ * Called by the streambuf API to seek to an absolute position
+ */
+streampos MemoryStreamCache::Reader::seekpos(streampos pos, std::ios_base::openmode mode)
+{
+	if (mode != std::ios_base::in || pos < 0)
+		return -1;
+
+	if (pos >= (streampos)buffer->getReceivedLength())
+		buffer->waitForTermination();
+
+	Locker locker(buffer->chunkListMutex);
+	streampos offset = 0;
+	for (auto it=buffer->chunks.begin(); it!=buffer->chunks.end(); ++it)
+	{
+		streampos used = (streampos)ACQUIRE_READ((*it)->used);
+		if (pos >= offset + used)
+		{
+			offset += used;
+		}
+		else
+		{
+			setg((char *)(*it)->buffer,
+			     (char *)((*it)->buffer + (pos - offset)),
+			     (char *)((*it)->buffer + used));
+			return pos;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * Get the position of the read cursor in the (virtual) downloaded data.
+ */
+streampos MemoryStreamCache::Reader::getOffset() const
+{
+	return chunkStartOffset + (size_t)(gptr() - eback());
+}
+
+FileStreamCache::FileStreamCache()
+  : keepCache(false)
+{
+}
+
+FileStreamCache::~FileStreamCache()
+{
+	if (cache.is_open())
+		cache.close();
+	if (!keepCache && !cacheFilename.empty())
+		unlink(cacheFilename.raw_buf());
+}
+
+void FileStreamCache::handleAppend(const unsigned char* buffer, size_t length)
+{
+	if (!cache.is_open())
+		openCache();
+
+	cache.write((const char*)buffer, length);
+	cache.sync();
+}
+
+/**
+ * \brief Creates & opens a temporary cache file
+ *
+ * Creates a temporary cache file in /tmp and calls \c openExistingCache() with that file.
+ * Waits for mutex at start and releases mutex when finished.
+ * \throw RunTimeException Temporary file could not be created
+ * \throw RunTimeException Called when  the cache is already open
+ * \see Downloader::openExistingCache()
+ */
+void FileStreamCache::openCache()
+{
+	if (cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache called twice"));
+	}
+
+	//Create a temporary file(name)
+	std::string cacheFilenameS = Config::getConfig()->getCacheDirectory() + "/" + Config::getConfig()->getCachePrefix() + "XXXXXX";
+	char* cacheFilenameC = g_newa(char,cacheFilenameS.length()+1);
+	strncpy(cacheFilenameC, cacheFilenameS.c_str(), cacheFilenameS.length());
+	cacheFilenameC[cacheFilenameS.length()] = '\0';
+	int fd = g_mkstemp(cacheFilenameC);
+	if(fd == -1)
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache: cannot create temporary file"));
+	}
+
+	//We are using fstream to read/write to the cache, so we don't need this FD
+	close(fd);
+
+	//Let the openExistingCache function handle the rest
+	openExistingCache(tiny_string(cacheFilenameC, true));
+}
+
+/**
+ * \brief Opens an existing cache file
+ *
+ * Opens an existing cache file, allocates the buffer and signals \c cacheOpened.
+ * \post \c cacheFilename is set
+ * \post \c cache file is opened
+ * \throw RunTimeException File could not be opened
+ * \throw RunTimeException Called when the cache is already open
+ */
+void FileStreamCache::openExistingCache(const tiny_string& filename, bool forWriting)
+{
+	if (cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache called twice"));
+	}
+
+	cacheFilename = filename;
+
+	//Open the cache file
+	ios_base::openmode mode;
+	if (forWriting)
+		mode = std::fstream::binary | std::fstream::out;
+	else
+		mode = std::fstream::binary | std::fstream::in;
+	cache.open(cacheFilename.raw_buf(), mode);
+	if (!cache.is_open())
+	{
+		markFinished(true);
+		throw RunTimeException(_("FileStreamCache::openCache: cannot open temporary cache file"));
+	}
+
+	LOG(LOG_INFO, _("NET: Downloading to cache file: ") << cacheFilename);
+}
+
+void FileStreamCache::useExistingFile(const tiny_string& filename)
+{
+	//Make sure we don't delete the local file afterwards
+	keepCache = true;
+
+	cacheFilename = filename;
+	openExistingCache(filename, false);
+
+	cache.seekg(0, std::ios::end);
+	receivedLength = cache.tellg();
+
+	// We already have the whole file
+	markFinished();
+}
+
+void FileStreamCache::waitForCache()
+{
+	if (cache.is_open())
+		return;
+
+	// Cache file will be opened when the first byte is received
+	waitForData(0);
+
+	// Check if the stream was terminated before anything was written
+	if (!cache.is_open())
+		throw RunTimeException(_("FileStreamCache::waitForCache: cache file is not open"));
+}
+
+std::streambuf *FileStreamCache::createReader()
+{
+	waitForCache();
+
+	incRef();
+	FileStreamCache::Reader *fbuf = new FileStreamCache::Reader(_MR(this));
+	fbuf->open(cacheFilename.raw_buf(), std::fstream::binary | std::fstream::in);
+	if (!fbuf->is_open())
+	{
+		delete fbuf;
+		throw RunTimeException(_("FileStreamCache::createReader: opening cache file for reading failed"));
+	}
+	return fbuf;
+}
+
+FileStreamCache::Reader::Reader(_R<FileStreamCache> b) : buffer(b)
+{
+}
+
+int FileStreamCache::Reader::underflow()
+{
+	if (!buffer->hasTerminated())
+		buffer->waitForData(seekoff(0, ios_base::cur, ios_base::in));
+
+	return filebuf::underflow();
+}
+
+streamsize FileStreamCache::Reader::xsgetn(char* s, streamsize n)
+{
+	streamsize read=filebuf::xsgetn(s, n);
+
+	// If not enough data was available, wait for writer
+	while (read < n)
+	{
+		buffer->waitForData(seekoff(0, ios_base::cur, ios_base::in));
+
+		streamsize b = filebuf::xsgetn(s+read, n-read);
+
+		// No more data after waiting, this must be EOF
+		if (b == 0)
+			return read;
+
+		read += b;
+	}
+
+	return read;
+}
diff -Nuar lightspark-0.7.2.orig/src/backends/streamcache.h lightspark-0.7.2/src/backends/streamcache.h
--- lightspark-0.7.2.orig/src/backends/streamcache.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/backends/streamcache.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,197 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef BACKENDS_STREAMCACHE_H
+#define BACKENDS_STREAMCACHE_H 1
+
+#include <list>
+#include <istream>
+#include <fstream>
+#include <cstdint>
+#include "threading.h"
+#include "tiny_string.h"
+#include "smartrefs.h"
+#include "compat.h"
+
+namespace lightspark
+{
+
+/*
+ * A single-writer-multiple-reader buffer for downloaded streams.
+ *
+ * Writing is done by one thread by calling append(), reading is done
+ * through streambuf interface (constructred by createReader()) in a
+ * separate thread. There can be several readers in multiple threads.
+ *
+ * This is an abstract base class.
+ */
+class DLL_PUBLIC StreamCache : public RefCountable {
+protected:
+	StreamCache() DLL_LOCAL;
+
+	// stateMutex must be held while receivedLength, failed or
+	// terminated are accessed
+	Mutex stateMutex;
+	// stateCond is signalled when data is received or the stream
+	// is terminated
+	Cond stateCond;
+	// Amount of data already received
+	size_t receivedLength;
+	// Has the stream been completely downloaded or failed?
+	bool failed:1;
+	bool terminated:1;
+
+	// Wait until more than currentOffset bytes has been received
+	// or until terminated
+	void waitForData(size_t currentOffset) DLL_LOCAL;
+
+	// Derived class implements this to store received data
+	virtual void handleAppend(const unsigned char* buffer, size_t length)=0;
+
+public:
+	virtual ~StreamCache() {}
+
+	// Gets the length of downloaded data
+	size_t getReceivedLength() const { return receivedLength; }
+
+	bool hasTerminated() const { return terminated; }
+	bool hasFailed() const { return failed; }
+
+	// Wait until the writer calls markTerminated
+	void waitForTermination();
+
+	// Set the expected length of the stream.
+	// The default implementation does nothing, but the derived
+	// classes can allocate memory here.
+	virtual void reserve(size_t expectedLength) {}
+
+	// Write new data to the buffer (writer thread)
+	void append(const unsigned char* buffer, size_t length);
+
+	// Writer should call this when all of the stream has been
+	// append()'ed
+	void markFinished(bool failed=false);
+
+	// Create a streambuf for reading from this buffer (reader
+	// thread). Every call returns a new, independent streambuf.
+	// The caller must delete the returned value.
+	virtual std::streambuf *createReader()=0;
+};
+
+class MemoryChunk;
+
+/*
+ * MemoryStreamCache buffers the stream in memory.
+ */
+class DLL_PUBLIC MemoryStreamCache : public StreamCache {
+private:
+	class DLL_LOCAL Reader : public std::streambuf {
+	private:
+		_R<MemoryStreamCache> buffer;
+		// The chunk that is currently being read
+		unsigned int chunkIndex;
+		// Offset at the start of current chunk
+		size_t chunkStartOffset;
+
+		// Handles streambuf out-of-data events
+		virtual int underflow();
+		// Seeks to absolute position
+		virtual std::streampos seekoff(std::streamoff, std::ios_base::seekdir, std::ios_base::openmode);
+		// Seeks to relative position
+		virtual std::streampos seekpos(std::streampos, std::ios_base::openmode);
+		// Helper to get the current offset
+		std::streampos getOffset() const;
+	public:
+		Reader(_R<MemoryStreamCache> b);
+	};
+
+	// Stream is stored into a sequence of memory chunks. The
+	// chunks can grow, but they are never moved, so both readers
+	// and writer can safely use them. However, the mutex must be
+	// held when the container is accessed.
+	Mutex chunkListMutex;
+	std::vector<MemoryChunk *> chunks;
+
+	// The last chunk, the next write will happen here (writer thread)
+	MemoryChunk *writeChunk;
+
+	// Variables controlling the memory allocation
+	size_t nextChunkSize;
+	static const size_t minChunkSize = 4*4096;
+
+	// Allocate a new chunk, append it to chunks, update writeChunk
+	void allocateChunk(size_t minLength) DLL_LOCAL;
+
+	virtual void handleAppend(const unsigned char* buffer, size_t length) DLL_LOCAL;
+
+public:
+	MemoryStreamCache();
+	virtual ~MemoryStreamCache();
+
+	virtual void reserve(size_t expectedLength);
+
+	virtual std::streambuf *createReader();
+};
+
+/*
+ * FileStreamCache saves the stream in a temporary file.
+ */
+class DLL_PUBLIC FileStreamCache : public StreamCache {
+private:
+	/*
+	 * Extends filebuf to wait for writer thread to supply more
+	 * data when the end of temporary file is reached.
+	 */
+	class DLL_LOCAL Reader : public std::filebuf {
+	private:
+		_R<FileStreamCache> buffer;
+		virtual int underflow();
+		virtual std::streamsize xsgetn(char* s, std::streamsize n);
+	public:
+		Reader(_R<FileStreamCache> buffer);
+	};
+
+	//Cache filename
+	tiny_string cacheFilename;
+	//Cache fstream
+	std::fstream cache;
+	//True if the cache file doesn't need to be deleted on destruction
+	bool keepCache:1;
+
+	void openCache() DLL_LOCAL;
+	void openExistingCache(const tiny_string& filename, bool forWriting=true) DLL_LOCAL;
+
+	// Block until the cache file is opened by the writer stream
+	void waitForCache() DLL_LOCAL;
+
+	virtual void handleAppend(const unsigned char* buffer, size_t length) DLL_LOCAL;
+
+public:
+	FileStreamCache();
+	virtual ~FileStreamCache();
+
+	virtual std::streambuf *createReader();
+
+	// Use an existing file as cache. Must be called before append().
+	void useExistingFile(const tiny_string& filename);
+};
+
+};
+
+#endif // BACKENDS_STREAMCACHE_H
diff -Nuar lightspark-0.7.2.orig/src/backends/urlutils.cpp lightspark-0.7.2/src/backends/urlutils.cpp
--- lightspark-0.7.2.orig/src/backends/urlutils.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/urlutils.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -22,15 +22,39 @@
 #include "backends/urlutils.h"
 #include "compat.h"
 #include "scripting/toplevel/Integer.h"
+#include "scripting/toplevel/Error.h"
+#include "scripting/class.h"
 #include <string>
 #include <algorithm>
 #include <cctype>
 #include <sstream>
 #include <iostream>
 #include <fstream>
+#ifdef __MINGW32__
+#include <malloc.h>
+#else
+#include <alloca.h>
+#endif
 
 using namespace lightspark;
 
+std::list<uint32_t> URLInfo::uriReservedAndHash =
+	{';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '#'};
+std::list<uint32_t> URLInfo::uriUnescaped = 
+	{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
+	 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
+	 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+	 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3',
+	 '4', '5', '6', '7', '8', '9', '-', '_', '.', '!', '~', '*', '\'', '(',
+	 ')'};
+std::list<uint32_t> URLInfo::uriReservedAndUnescapedAndHash =
+	{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
+	 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
+	 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+	 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3',
+	 '4', '5', '6', '7', '8', '9', '-', '_', '.', '!', '~', '*', '\'', '(',
+	 ')', ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '#'};
+
 std::ostream& lightspark::operator<<(std::ostream& s, const URLInfo& u)
 {
 	s << u.getParsedURL();
@@ -332,6 +356,11 @@
 
 tiny_string URLInfo::encode(const tiny_string& u, ENCODING type)
 {
+	if (type == ENCODE_URI)
+		return encodeURI(u, uriReservedAndUnescapedAndHash);
+	else if (type == ENCODE_URICOMPONENT)
+		return encodeURI(u, uriUnescaped);
+
 	tiny_string str;
 	char buf[7];
 	
@@ -355,20 +384,6 @@
 			//ENCODE_FORM encodes spaces as + instead of %20
 			else if(type == ENCODE_FORM && *i == ' ')
 				str += '+';
-			//Additionally ENCODE_URICOMPONENT and ENCODE_URI don't encode:
-			//- _ . ! ~ * ' ( )
-			else if((type == ENCODE_URI || type == ENCODE_URICOMPONENT) && 
-					(*i == '-' || *i == '_' || *i == '.' || *i == '!' ||
-						*i == '~' || *i == '*' || *i == '\'' ||	*i == '(' ||
-						*i == ')'))
-				str += *i;
-			//Additionally ENCODE_URI doesn't encode:
-			//; / ? : @ & = + $ , # 
-			else if((type == ENCODE_URI) && 
-						(*i == ';' || *i == '/' || *i == '?' || *i == ':' ||
-							*i == '@' || *i == '&' || *i == '=' || *i == '+' ||
-							*i == '$' || *i == ',' || *i == '#'))
-				str += *i;
 			// ENCODE_ESCAPE doesn't encode:
 			//@ - _ . * + /
 			else if(type == ENCODE_ESCAPE && 
@@ -390,8 +405,72 @@
 	return str;
 }
 
-std::string URLInfo::decode(const std::string& u, ENCODING type)
+tiny_string URLInfo::encodeURI(const tiny_string& u, const std::list<uint32_t>& unescapedChars) {
+	tiny_string res;
+	CharIterator c = u.begin();
+	CharIterator end = u.end();
+	while (c != end)
+	{
+		if (std::find(unescapedChars.begin(), unescapedChars.end(), *c) == unescapedChars.end())
+		{
+			if ((*c >= 0xD800) && (*c <= 0xDFFF))
+			{
+				res += encodeSurrogatePair(c, end);
+			}
+			else
+			{
+				res += encodeSingleChar(*c);
+			}
+		}
+		else
+		{
+			res += *c;
+		}
+		++c;
+	}
+	return res;
+}
+
+tiny_string URLInfo::encodeSurrogatePair(CharIterator& c, const CharIterator& end)
+{
+	if ((*c < 0xD800) || (*c >= 0xDC00))
+		throwError<URIError>(kInvalidURIError, "encodeURI");
+	uint32_t highSurrogate = *c;
+	++c;
+	if ((c == end) || ((*c < 0xDC00) || (*c > 0xDFFF)))
+		throwError<URIError>(kInvalidURIError, "encodeURI");
+	uint32_t lowSurrogate = *c;
+	return encodeSingleChar((highSurrogate - 0xD800)*0x400 +
+				(lowSurrogate - 0xDC00) + 0x10000);
+}
+
+tiny_string URLInfo::encodeSingleChar(uint32_t codepoint)
+{
+	char octets[6];
+	gint numOctets = g_unichar_to_utf8(codepoint, octets);
+	tiny_string encoded;
+	for (int i=0; i<numOctets; i++)
+	{
+		encoded += encodeOctet(octets[i]);
+	}
+
+	return encoded;
+}
+
+tiny_string URLInfo::encodeOctet(char c) {
+	gchar *buf = (gchar *)alloca(6);
+	g_snprintf(buf, 6, "%%%.2X", (unsigned char)c);
+	buf[5] = '\0';
+	return tiny_string(buf, true);
+}
+
+tiny_string URLInfo::decode(const std::string& u, ENCODING type)
 {
+	if (type == ENCODE_URI)
+		return decodeURI(u, uriReservedAndHash);
+	else if (type == ENCODE_URICOMPONENT)
+		return decodeURI(u, {});
+
 	std::string str;
 	//The string can only shrink
 	str.reserve(u.length());
@@ -419,26 +498,6 @@
 				str += stringBuf;
 				i+=2;
 			}
-			//ENCODE_URI and ENCODE_URICOMPONENT don't decode:
-			//- _ . ! ~ * ' ( ) 
-			else if((type == ENCODE_URI || type == ENCODE_URICOMPONENT) && 
-					(stringBuf == "%2D" || stringBuf == "%5F" || stringBuf == "%2E" || stringBuf == "%21" ||
-					 stringBuf == "%7E" || stringBuf == "%2A" || stringBuf == "%27" || stringBuf == "%28" || 
-					 stringBuf == "%29"))
-			{
-				str += stringBuf;
-				i+=2;
-			}
-			//Additionally ENCODE_URI doesn't decode:
-			//; / ? : @ & = + $ , # 
-			else if(type == ENCODE_URI && 
-					(stringBuf == "%23" || stringBuf == "%24" || stringBuf == "%26" || stringBuf == "%2B" ||
-					 stringBuf == "%2C" || stringBuf == "%2F" || stringBuf == "%3A" || stringBuf == "%3B" ||
-					 stringBuf == "%3D" || stringBuf == "%3F" || stringBuf == "%40"))
-			{
-				str += stringBuf;
-				i+=2;
-			}
 			//All encoded characters that weren't excluded above are now decoded
 			else
 			{	
@@ -466,6 +525,112 @@
 	return str;
 }
 
+tiny_string URLInfo::decodeURI(const tiny_string& u, const std::list<uint32_t>& reservedChars)
+{
+	tiny_string res;
+	CharIterator c = u.begin();
+	CharIterator end = u.end();
+	while (c != end)
+	{
+		if (*c == '%')
+		{
+			CharIterator encodeBegin = c;
+			uint32_t decoded = decodeSingleChar(c, end);
+			if (std::find(reservedChars.begin(), reservedChars.end(), decoded) == reservedChars.end())
+			{
+				res += decoded;
+			}
+			else
+			{
+				CharIterator it = encodeBegin;
+				while (it != c)
+				{
+					res += *it;
+					++it;
+				}
+			}
+		}
+		else
+		{
+			res += *c;
+			++c;
+		}
+	}
+
+	return res;
+}
+
+uint32_t URLInfo::decodeSingleChar(CharIterator& c, const CharIterator& end)
+{
+	uint32_t decoded = decodeSingleEscapeSequence(c, end);
+	if ((decoded & 0x80) != 0) {
+		decoded = decodeRestOfUTF8Sequence(decoded, c, end);
+	}
+	return decoded;
+}
+
+uint32_t URLInfo::decodeRestOfUTF8Sequence(uint32_t firstOctet, CharIterator& c, const CharIterator& end) {
+	unsigned int numOctets = 0;
+	uint32_t mask = 0x80;
+	while ((firstOctet & mask) != 0) {
+		numOctets++;
+		mask = mask >> 1;
+	}
+	if (numOctets <= 1 || numOctets > 4)
+		throwError<URIError>(kInvalidURIError, "decodeURI");
+
+	char *octets = (char *)alloca(numOctets);
+	octets[0] = firstOctet;
+	for (unsigned int i=1; i<numOctets; i++) {
+		octets[i] = decodeSingleEscapeSequence(c, end);
+	}
+
+	if (isSurrogateUTF8Sequence(octets, numOctets))
+	{
+		LOG(LOG_NOT_IMPLEMENTED, "decodeURI: decoding surrogate pairs");
+		return REPLACEMENT_CHARACTER;
+	}
+
+	gunichar unichar = g_utf8_get_char_validated(octets, numOctets);
+	if ((unichar == (gunichar)-1) || 
+	    (unichar == (gunichar)-2) ||
+	    (unichar >= 0x10FFFF))
+		throwError<URIError>(kInvalidURIError, "decodeURI");
+
+	return (uint32_t)unichar;
+}
+
+uint32_t URLInfo::decodeSingleEscapeSequence(CharIterator& c, const CharIterator& end)
+{
+	if (*c != '%')
+		throwError<URIError>(kInvalidURIError, "decodeURI");
+	++c;
+	uint32_t h1 = decodeHexDigit(c, end);
+	uint32_t h2 = decodeHexDigit(c, end);
+	return (h1 << 4) + h2;
+}
+
+bool URLInfo::isSurrogateUTF8Sequence(const char *octets, unsigned int numOctets)
+{
+	// Surrogate code points: 0xD800 - 0xDFFF
+	// UTF-8 encoded: 0xED 0xA0 0x80 - 0xED 0xBF 0xBF
+	return (numOctets == 3) &&
+		((unsigned char)octets[0] == 0xED) &&
+		((unsigned char)octets[1] >= 0xA0) &&
+		((unsigned char)octets[1] <= 0xBF);
+}
+
+uint32_t URLInfo::decodeHexDigit(CharIterator& c, const CharIterator& end)
+{
+	if (c == end || !isxdigit(*c))
+		throwError<URIError>(kInvalidURIError, "decodeURI");
+
+	gint h = g_unichar_xdigit_value(*c);
+	assert((h >= 0) && (h < 16));
+	++c;
+	return (uint32_t) h;
+}
+
 bool URLInfo::isRTMP() const
 {
 	return protocol == "rtmp" || protocol == "rtmpe" || protocol == "rtmps" ||
diff -Nuar lightspark-0.7.2.orig/src/backends/urlutils.h lightspark-0.7.2/src/backends/urlutils.h
--- lightspark-0.7.2.orig/src/backends/urlutils.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/urlutils.h	2013-11-09 19:23:31.000000000 +0200
@@ -35,6 +35,10 @@
 {
 	friend std::ostream& operator<<(std::ostream& s, const URLInfo& u);
 private:
+	static std::list<uint32_t> uriReservedAndHash;
+	static std::list<uint32_t> uriUnescaped;
+	static std::list<uint32_t> uriReservedAndUnescapedAndHash;
+	static const uint32_t REPLACEMENT_CHARACTER = 0xFFFD;
 	tiny_string url; //The URL space encoded
 	tiny_string parsedURL; //The URL normalized and space encoded
 	tiny_string protocol; //Part after
@@ -51,6 +55,16 @@
 	INVALID_REASON invalidReason;
 	uint16_t port; //Part after first : after hostname
 	bool valid;
+	static tiny_string encodeURI(const tiny_string& u, const std::list<uint32_t>& unescapedChars);
+	static tiny_string encodeSurrogatePair(CharIterator& c, const CharIterator& end);
+	static tiny_string encodeSingleChar(uint32_t codepoint);
+	static tiny_string encodeOctet(char c);
+	static tiny_string decodeURI(const tiny_string& u, const std::list<uint32_t>& reservedChars);
+	static uint32_t decodeSingleEscapeSequence(CharIterator& c, const CharIterator& end);
+	static uint32_t decodeSingleChar(CharIterator& c, const CharIterator& end);
+	static uint32_t decodeRestOfUTF8Sequence(uint32_t firstOctet, CharIterator& c, const CharIterator& end);
+	static uint32_t decodeHexDigit(CharIterator& c, const CharIterator& end);
+	static bool isSurrogateUTF8Sequence(const char *octets, unsigned int numOctets);
 public:
 	URLInfo():invalidReason(IS_EMPTY),valid(false) {};
 	URLInfo(const tiny_string& u);
@@ -109,11 +123,7 @@
 	{
 		return std::string(encode(tiny_string(u), type));
 	}
-	static tiny_string decode(const tiny_string& u, ENCODING type=ENCODE_URICOMPONENT)
-	{
-		return tiny_string(decode(std::string(u.raw_buf()), type));
-	};
-	static std::string decode(const std::string& u, ENCODING type=ENCODE_URICOMPONENT);
+	static tiny_string decode(const std::string& u, ENCODING type=ENCODE_URICOMPONENT);
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/src/backends/xml_support.cpp lightspark-0.7.2/src/backends/xml_support.cpp
--- lightspark-0.7.2.orig/src/backends/xml_support.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/xml_support.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -60,7 +60,8 @@
 	if(!context_->wellFormed)
 		LOG(LOG_ERROR, "XML data not well formed!");
 
-	doc_ = new RecoveryDocument(context_->myDoc);
+	if (context_->myDoc)
+		doc_ = new RecoveryDocument(context_->myDoc);
 	// This is to indicate to release_underlying that we took the
 	// ownership on the doc.
 	context_->myDoc = 0;
@@ -74,7 +75,7 @@
 #endif
 
 xmlpp::Node* XMLBase::buildFromString(const string& str,
-				      bool ignoreEmptyTextNodes,
+				      bool ignoreEmptyTextNodes, bool *hasParent,
 				      const string& default_ns)
 {
 	string buf = parserQuirks(str);
@@ -88,6 +89,7 @@
 	xmlpp::Document* doc=parser.get_document();
 	if(doc && doc->get_root_node())
 	{
+		*hasParent = true;
 		xmlpp::Element *root = doc->get_root_node();
 		// It would be better to remove empty nodes during
 		// parsing, but xmlpp doesn't offer an interface.
@@ -97,16 +99,16 @@
 		return root;
 	}
 
-	LOG(LOG_ERROR, "XML parsing failed, creating text node");
 	//If everything fails, create a fake document and add a single text string child
+	// see 10.3.1 in ECMA 357
 	if (default_ns.empty())
-		buf="<a></a>";
+		buf="<parent></parent>";
 	else
-		buf="<a xmlns=\"" + default_ns + "\"></a>";
+		buf="<parent xmlns=\"" + default_ns + "\"></parent>";
 	parser.parse_memory_raw((const unsigned char*)buf.c_str(), buf.size());
 
+	*hasParent = false;
 	return parser.get_document()->get_root_node()->add_child_text(str);
-	// TODO: node's parent (root) should be inaccessible from AS code
 }
 
 void XMLBase::addDefaultNamespace(xmlpp::Element *root, const string& default_ns)
@@ -136,15 +138,25 @@
 	}
 }
 
-xmlpp::Node* XMLBase::buildCopy(const xmlpp::Node* src)
+xmlpp::Node* XMLBase::buildCopy(const xmlpp::Node* src, bool *hasParent)
 {
+	const xmlpp::ContentNode* contentnode;
 	const xmlpp::TextNode* textnode=dynamic_cast<const xmlpp::TextNode*>(src);
 	if(textnode)
 	{
-		return buildFromString(textnode->get_content(), false);
+		return buildFromString(textnode->get_content(), false,hasParent);
+	}
+	else if ((contentnode = dynamic_cast<const xmlpp::ContentNode*>(src)))
+	{
+		// ContentNode but not TextNode => comment, PI or CData
+		// These can't be root nodes so we add a dummy root.
+		*hasParent = false;
+		xmlpp::Element* root = parser.get_document()->create_root_node("dummy_root");
+		return root->import_node(contentnode);
 	}
 	else
 	{
+		*hasParent = true;
 		return parser.get_document()->create_root_node_by_import(src);
 	}
 }
diff -Nuar lightspark-0.7.2.orig/src/backends/xml_support.h lightspark-0.7.2/src/backends/xml_support.h
--- lightspark-0.7.2.orig/src/backends/xml_support.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/backends/xml_support.h	2013-11-09 19:23:31.000000000 +0200
@@ -57,16 +57,18 @@
 	LSDomParser parser;
 	xmlpp::Node* buildFromString(const std::string& str,
 				     bool ignoreEmptyTextnodes,
+				     bool *hasParent,
 				     const std::string& default_ns=std::string());
 	void addDefaultNamespace(xmlpp::Element *root, const std::string& default_ns);
 	void addDefaultNamespaceRecursive(xmlNodePtr node, xmlNsPtr ns);
 	// Set the root to be a copy of src. If src is a text node,
 	// create a new element node with the same content.
-	xmlpp::Node* buildCopy(const xmlpp::Node* node);
-	static std::string parserQuirks(const std::string& str);
+	xmlpp::Node* buildCopy(const xmlpp::Node* node, bool *hasParent);
 	static std::string quirkCData(const std::string& str);
 	static std::string quirkXMLDeclarationInMiddle(const std::string& str);
 	void removeWhitespaceNodes(xmlpp::Element *node);
+public:
+	static std::string parserQuirks(const std::string& str);
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/src/CMakeLists.txt lightspark-0.7.2/src/CMakeLists.txt
--- lightspark-0.7.2.orig/src/CMakeLists.txt	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/CMakeLists.txt	2013-11-09 19:23:31.000000000 +0200
@@ -47,6 +47,7 @@
   backends/rendering_context.cpp
   backends/rtmputils.cpp
   backends/security.cpp
+  backends/streamcache.cpp
   backends/urlutils.cpp
   backends/xml_support.cpp
   parsing/amf3_generator.cpp
@@ -72,6 +73,15 @@
   scripting/flash/display/IBitmapDrawable.cpp
   scripting/flash/display/flashdisplay.cpp
   scripting/flash/display/TokenContainer.cpp
+  scripting/flash/display/Graphics.cpp
+  scripting/flash/display/GraphicsBitmapFill.cpp
+  scripting/flash/display/GraphicsEndFill.cpp
+  scripting/flash/display/GraphicsGradientFill.cpp
+  scripting/flash/display/GraphicsPath.cpp
+  scripting/flash/display/GraphicsShaderFill.cpp
+  scripting/flash/display/GraphicsSolidFill.cpp
+  scripting/flash/display/GraphicsStroke.cpp
+  scripting/flash/display/GraphicsTrianglePath.cpp
   scripting/flash/events/flashevents.cpp
   scripting/flash/external/ExternalInterface.cpp
   scripting/flash/filters/flashfilters.cpp
@@ -87,7 +97,14 @@
   scripting/flash/text/flashtext.cpp
   scripting/flash/text/flashtextengine.cpp
   scripting/flash/utils/flashutils.cpp
+  scripting/flash/utils/ByteArray.cpp
+  scripting/flash/utils/Dictionary.cpp
+  scripting/flash/utils/Proxy.cpp
+  scripting/flash/utils/Timer.cpp
+  scripting/flash/utils/IntervalManager.cpp
+  scripting/flash/utils/IntervalRunner.cpp
   scripting/flash/ui/Keyboard.cpp
+  scripting/flash/ui/Mouse.cpp
   scripting/flash/xml/flashxml.cpp
   scripting/toplevel/Array.cpp
   scripting/toplevel/ASString.cpp
@@ -95,6 +112,7 @@
   scripting/toplevel/Date.cpp
   scripting/toplevel/Error.cpp
   scripting/toplevel/Integer.cpp
+  scripting/toplevel/JSON.cpp
   scripting/toplevel/Math.cpp
   scripting/toplevel/Number.cpp
   scripting/toplevel/RegExp.cpp
diff -Nuar lightspark-0.7.2.orig/src/compat.h lightspark-0.7.2/src/compat.h
--- lightspark-0.7.2.orig/src/compat.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/compat.h	2013-11-09 19:23:31.000000000 +0200
@@ -116,6 +116,7 @@
 
 //Boolean type with acquire release barrier semantics
 #define ACQUIRE_RELEASE_FLAG(x) std::atomic_bool x
+#define ACQUIRE_RELEASE_VARIABLE(t, x) std::atomic<t> x
 #define ACQUIRE_READ(x) x.load(std::memory_order_acquire)
 #define RELEASE_WRITE(x, v) x.store(v, std::memory_order_release)
 
diff -Nuar lightspark-0.7.2.orig/src/main.cpp lightspark-0.7.2/src/main.cpp
--- lightspark-0.7.2.orig/src/main.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/main.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -246,6 +246,7 @@
 #ifdef PROFILING_SUPPORT
 			" [--profiling-output|-o profiling-file]" <<
 #endif
+			" [--version|-v]" <<
 			" <file.swf>");
 		exit(1);
 	}
@@ -286,7 +287,12 @@
 	{
 		sys->mainClip->setOrigin(url, fileName);
 		sys->parseParametersFromURL(sys->mainClip->getOrigin());
-		sandboxType = SecurityManager::REMOTE;
+		if (sandboxType != SecurityManager::REMOTE &&
+		    sys->mainClip->getOrigin().getProtocol() != "file")
+		{
+			LOG(LOG_INFO, _("Switching to remote sandbox because of remote url"));
+			sandboxType = SecurityManager::REMOTE;
+		}
 	}
 #ifndef _WIN32
 	//When running in a local sandbox, set the root URL to the current working dir
diff -Nuar lightspark-0.7.2.orig/src/parsing/amf3_generator.cpp lightspark-0.7.2/src/parsing/amf3_generator.cpp
--- lightspark-0.7.2.orig/src/parsing/amf3_generator.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/parsing/amf3_generator.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -26,6 +26,7 @@
 #include "toplevel/XML.h"
 #include <iostream>
 #include <fstream>
+#include "scripting/flash/utils/ByteArray.h"
 
 using namespace std;
 using namespace lightspark;
diff -Nuar lightspark-0.7.2.orig/src/parsing/tags.cpp lightspark-0.7.2/src/parsing/tags.cpp
--- lightspark-0.7.2.orig/src/parsing/tags.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/parsing/tags.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -24,10 +24,16 @@
 #include <list>
 #include <algorithm>
 #include <sstream>
+#ifdef __MINGW32__
+#include <malloc.h>
+#else
+#include <alloca.h>
+#endif
 #include "scripting/abc.h"
 #include "parsing/tags.h"
 #include "backends/geometry.h"
 #include "backends/security.h"
+#include "backends/streamcache.h"
 #include "swftypes.h"
 #include "logger.h"
 #include "compat.h"
@@ -35,6 +41,7 @@
 #include "scripting/flash/display/BitmapData.h"
 #include "scripting/flash/text/flashtext.h"
 #include "scripting/flash/media/flashmedia.h"
+#include "backends/audio.h"
 
 #undef RGB
 
@@ -383,6 +390,7 @@
 			case SYMBOL_CLASS_TAG:
 			case ABC_TAG:
 			case CONTROL_TAG:
+			case ACTION_TAG:
 				delete tag;
 				throw ParseException("Control tag inside a sprite. Should not happen.");
 			case FRAMELABEL_TAG:
@@ -1436,6 +1444,7 @@
 			assert_and_throw(state);
 			//The matrix must be set before invoking the constructor
 			state->setLegacyMatrix(i->PlaceMatrix);
+			state->name = "";
 			/*
 			 * TODO: BlendMode, filerList, PlaceDepth, ColorTransfrom
 			 */
@@ -1532,7 +1541,7 @@
 	UB(24,bs);
 }
 
-DefineSoundTag::DefineSoundTag(RECORDHEADER h, std::istream& in,RootMovieClip* root):DictionaryTag(h,root)
+DefineSoundTag::DefineSoundTag(RECORDHEADER h, std::istream& in,RootMovieClip* root):DictionaryTag(h,root),SoundData(new MemoryStreamCache)
 {
 	LOG(LOG_TRACE,_("DefineSound Tag"));
 	in >> SoundId;
@@ -1542,8 +1551,13 @@
 	SoundSize=UB(1,bs);
 	SoundType=UB(1,bs);
 	in >> SoundSampleCount;
-	//TODO: read and parse actual sound data
-	ignore(in,h.getLength()-7);
+
+	//TODO: get rid of the temporary copy
+	unsigned int soundDataLength = h.getLength()-7;
+	unsigned char *tmp = (unsigned char *)alloca(soundDataLength);
+	in.read((char *)tmp, soundDataLength);
+	SoundData->append(tmp, in.gcount());
+	SoundData->markFinished();
 }
 
 ASObject* DefineSoundTag::instance(Class_base* c) const
@@ -1556,8 +1570,82 @@
 	else
 		retClass=Class<Sound>::getClass();
 
-	//TODO: use the tag sound data
-	return new (retClass->memoryAccount) Sound(retClass);
+	return new (retClass->memoryAccount) Sound(retClass, SoundData,
+		AudioFormat(getAudioCodec(), getSampleRate(), getChannels()));
+}
+
+LS_AUDIO_CODEC DefineSoundTag::getAudioCodec() const
+{
+	return (LS_AUDIO_CODEC)SoundFormat;
+}
+
+int DefineSoundTag::getSampleRate() const
+{
+	switch(SoundRate)
+	{
+		case 0:
+			return 5500;
+		case 1:
+			return 11000;
+		case 2:
+			return 22000;
+		case 3:
+			return 44000;
+	}
+
+	// not reached
+	assert(false && "invalid sample rate");
+	return 0;
+}
+
+int DefineSoundTag::getChannels() const
+{
+	return (int)SoundType + 1;
+}
+
+_R<MemoryStreamCache> DefineSoundTag::getSoundData() const
+{
+	return SoundData;
+}
+
+std::streambuf *DefineSoundTag::createSoundStream() const
+{
+	return SoundData->createReader();
+}
+
+StartSoundTag::StartSoundTag(RECORDHEADER h, std::istream& in):ActionTag(h)
+{
+	LOG(LOG_TRACE,_("StartSound Tag"));
+	in >> SoundId >> SoundInfo;
+}
+
+void StartSoundTag::execute(RootMovieClip* root) const
+{
+	DefineSoundTag *soundTag = \
+		dynamic_cast<DefineSoundTag *>(root->dictionaryLookup(SoundId));
+
+	if (SoundInfo.SyncStop || SoundInfo.HasEnvelope || SoundInfo.HasLoops ||
+	    SoundInfo.HasOutPoint || SoundInfo.HasInPoint)
+	{
+		LOG(LOG_NOT_IMPLEMENTED, "StartSoundTag: some modifiers not supported");
+		if (SoundInfo.SyncStop)
+			return;
+	}
+
+	play(soundTag);
+}
+
+void StartSoundTag::play(const DefineSoundTag *soundTag) const
+{
+	SoundChannel *schannel = Class<SoundChannel>::getInstanceS(
+		soundTag->getSoundData(),
+		AudioFormat(soundTag->getAudioCodec(),
+			    soundTag->getSampleRate(),
+			    soundTag->getChannels()));
+
+	// SoundChannel thread keeps one reference, which will be
+	// removed thread is finished
+	schannel->decRef();
 }
 
 ScriptLimitsTag::ScriptLimitsTag(RECORDHEADER h, std::istream& in):ControlTag(h)
diff -Nuar lightspark-0.7.2.orig/src/parsing/tags.h lightspark-0.7.2/src/parsing/tags.h
--- lightspark-0.7.2.orig/src/parsing/tags.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/parsing/tags.h	2013-11-09 19:23:31.000000000 +0200
@@ -31,7 +31,7 @@
 namespace lightspark
 {
 
-enum TAGTYPE {TAG=0,DISPLAY_LIST_TAG,SHOW_TAG,CONTROL_TAG,DICT_TAG,FRAMELABEL_TAG,SYMBOL_CLASS_TAG,ABC_TAG,END_TAG};
+enum TAGTYPE {TAG=0,DISPLAY_LIST_TAG,SHOW_TAG,CONTROL_TAG,DICT_TAG,FRAMELABEL_TAG,SYMBOL_CLASS_TAG,ACTION_TAG,ABC_TAG,END_TAG};
 
 void ignore(std::istream& i, int count);
 
@@ -94,6 +94,17 @@
 	virtual void execute(RootMovieClip* root) const=0;
 };
 
+/*
+ * Initiates an action. Action is executed after a frame is parsed.
+ */
+class ActionTag: public ControlTag
+{
+public:
+	ActionTag(RECORDHEADER h):ControlTag(h){}
+	virtual TAGTYPE getType()const{ return ACTION_TAG; }
+	virtual void execute(RootMovieClip* root) const=0;
+};
+
 class DefineShapeTag: public DictionaryTag
 {
 protected:
@@ -212,6 +223,8 @@
 	ASObject* instance(Class_base* c=NULL) const;
 };
 
+class MemoryStreamCache;
+
 class DefineSoundTag: public DictionaryTag
 {
 private:
@@ -221,16 +234,28 @@
 	char SoundSize;
 	char SoundType;
 	UI32_SWF SoundSampleCount;
+	_R<MemoryStreamCache> SoundData;
 public:
 	DefineSoundTag(RECORDHEADER h, std::istream& s, RootMovieClip* root);
 	virtual int getId() const { return SoundId; }
 	ASObject* instance(Class_base* c=NULL) const;
+	LS_AUDIO_CODEC getAudioCodec() const;
+	int getSampleRate() const;
+	int getChannels() const;
+	_R<MemoryStreamCache> getSoundData() const;
+	std::streambuf *createSoundStream() const;
 };
 
-class StartSoundTag: public Tag
+class StartSoundTag: public ActionTag
 {
+private:
+	UI16_SWF SoundId;
+	SOUNDINFO SoundInfo;
+
+	void play(const DefineSoundTag *soundTag) const;
 public:
 	StartSoundTag(RECORDHEADER h, std::istream& s);
+	virtual void execute(RootMovieClip* root) const;
 };
 
 class SoundStreamHeadTag: public Tag
diff -Nuar lightspark-0.7.2.orig/src/parsing/tags_stub.cpp lightspark-0.7.2/src/parsing/tags_stub.cpp
--- lightspark-0.7.2.orig/src/parsing/tags_stub.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/parsing/tags_stub.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -39,12 +39,6 @@
 	skip(in);
 }
 
-StartSoundTag::StartSoundTag(RECORDHEADER h, std::istream& in):Tag(h)
-{
-	LOG(LOG_NOT_IMPLEMENTED,_("StartSound Tag"));
-	skip(in);
-}
-
 SoundStreamHeadTag::SoundStreamHeadTag(RECORDHEADER h, std::istream& in):Tag(h)
 {
 	LOG(LOG_NOT_IMPLEMENTED,_("SoundStreamHead Tag"));
diff -Nuar lightspark-0.7.2.orig/src/platforms/engineutils.cpp lightspark-0.7.2/src/platforms/engineutils.cpp
--- lightspark-0.7.2.orig/src/platforms/engineutils.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/platforms/engineutils.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -99,3 +99,33 @@
 	gtk_widget_show(widget);
 	gtk_widget_map(widget);
 }
+
+void EngineData::showMouseCursor()
+{
+	if (!widget)
+		return;
+
+	gdk_threads_enter();
+	GdkWindow* gdkwindow = gtk_widget_get_window(widget);
+	if (gdkwindow)
+		gdk_window_set_cursor(gdkwindow, NULL);
+	gdk_threads_leave();
+}
+
+void EngineData::hideMouseCursor()
+{
+	if (!widget)
+		return;
+
+	gdk_threads_enter();
+	GdkCursor* cursor = gdk_cursor_new(GDK_BLANK_CURSOR);
+	if (cursor)
+	{
+		GdkWindow* gdkwindow = gtk_widget_get_window(widget);
+		if (gdkwindow)
+			gdk_window_set_cursor(gdkwindow, cursor);
+		gdk_cursor_unref(cursor);
+	}
+	gdk_threads_leave();
+}
+
diff -Nuar lightspark-0.7.2.orig/src/platforms/engineutils.h lightspark-0.7.2/src/platforms/engineutils.h
--- lightspark-0.7.2.orig/src/platforms/engineutils.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/platforms/engineutils.h	2013-11-09 19:23:31.000000000 +0200
@@ -99,8 +99,11 @@
 		assert(!inputHandlerId);
 		inputHandler = ic;
 		gtk_widget_set_can_focus(widget,TRUE);
-		gtk_widget_add_events(widget,GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK |
-						GDK_POINTER_MOTION_MASK | GDK_EXPOSURE_MASK);
+		gtk_widget_add_events(widget,
+			GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+			GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK |
+			GDK_POINTER_MOTION_MASK | GDK_EXPOSURE_MASK |
+			GDK_LEAVE_NOTIFY_MASK);
 		inputHandlerId = g_signal_connect(widget, "event", G_CALLBACK(inputDispatch), this);
 	}
 	void removeInputHandler()
@@ -141,6 +144,10 @@
 
 	static void startGTKMain();
 	static void quitGTKMain();
+
+	/* show/hide mouse cursor, must be called from the gtk thread */
+	void showMouseCursor();
+	void hideMouseCursor();
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/src/plugin/plugin.cpp lightspark-0.7.2/src/plugin/plugin.cpp
--- lightspark-0.7.2.orig/src/plugin/plugin.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/plugin/plugin.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -20,6 +20,7 @@
 
 #include "version.h"
 #include "backends/security.h"
+#include "backends/streamcache.h"
 #include "plugin/plugin.h"
 #include "logger.h"
 #include "compat.h"
@@ -63,18 +64,22 @@
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-lightspark::Downloader* NPDownloadManager::download(const lightspark::URLInfo& url, bool cached, lightspark::ILoadable* owner)
+lightspark::Downloader* NPDownloadManager::download(const lightspark::URLInfo& url, _R<StreamCache> cache, lightspark::ILoadable* owner)
 {
 	// Handle RTMP requests internally, not through NPAPI
 	if(url.isRTMP())
 	{
-		return StandaloneDownloadManager::download(url, cached, owner);
+		return StandaloneDownloadManager::download(url, cache, owner);
 	}
 
+	// FIXME: dynamic_cast fails because the linker doesn't find
+	// typeinfo for FileStreamCache
+	//bool cached = dynamic_cast<FileStreamCache *>(cache.getPtr()) != NULL;
+	bool cached = false;
 	LOG(LOG_INFO, _("NET: PLUGIN: DownloadManager::download '") << url.getParsedURL() << 
 			"'" << (cached ? _(" - cached") : ""));
 	//Register this download
-	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cached, instance, owner);
+	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cache, instance, owner);
 	addDownloader(downloader);
 	return downloader;
 }
@@ -88,18 +93,19 @@
  * \return A pointer to a newly created \c Downloader for the given URL.
  * \see DownloadManager::destroy()
  */
-lightspark::Downloader* NPDownloadManager::downloadWithData(const lightspark::URLInfo& url, const std::vector<uint8_t>& data, 
+lightspark::Downloader* NPDownloadManager::downloadWithData(const lightspark::URLInfo& url,
+		_R<StreamCache> cache, const std::vector<uint8_t>& data,
 		const std::list<tiny_string>& headers, lightspark::ILoadable* owner)
 {
 	// Handle RTMP requests internally, not through NPAPI
 	if(url.isRTMP())
 	{
-		return StandaloneDownloadManager::downloadWithData(url, data, headers, owner);
+		return StandaloneDownloadManager::downloadWithData(url, cache, data, headers, owner);
 	}
 
 	LOG(LOG_INFO, _("NET: PLUGIN: DownloadManager::downloadWithData '") << url.getParsedURL());
 	//Register this download
-	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), data, headers, instance, owner);
+	NPDownloader* downloader=new NPDownloader(url.getParsedURL(), cache, data, headers, instance, owner);
 	addDownloader(downloader);
 	return downloader;
 }
@@ -139,7 +145,7 @@
  * \param[in] _url The URL for the Downloader.
  */
 NPDownloader::NPDownloader(const lightspark::tiny_string& _url, lightspark::ILoadable* owner):
-	Downloader(_url, false, owner),instance(NULL),cleanupInDestroyStream(true),state(INIT)
+	Downloader(_url, _MR(new MemoryStreamCache), owner),instance(NULL),cleanupInDestroyStream(true),state(INIT)
 {
 }
 
@@ -151,8 +157,8 @@
  * \param[in] _instance The netscape plugin instance
  * \param[in] owner The \c LoaderInfo object that keeps track of this download
  */
-NPDownloader::NPDownloader(const lightspark::tiny_string& _url, bool _cached, NPP _instance, lightspark::ILoadable* owner):
-	Downloader(_url, _cached, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
+NPDownloader::NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> _cache, NPP _instance, lightspark::ILoadable* owner):
+	Downloader(_url, _cache, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
 {
 	NPN_PluginThreadAsyncCall(instance, dlStartCallback, this);
 }
@@ -165,9 +171,10 @@
  * \param[in] _instance The netscape plugin instance
  * \param[in] owner The \c LoaderInfo object that keeps track of this download
  */
-NPDownloader::NPDownloader(const lightspark::tiny_string& _url, const std::vector<uint8_t>& _data,
+NPDownloader::NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> _cache,
+		const std::vector<uint8_t>& _data,
 		const std::list<tiny_string>& headers, NPP _instance, lightspark::ILoadable* owner):
-	Downloader(_url, _data, headers, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
+	Downloader(_url, _cache, _data, headers, owner),instance(_instance),cleanupInDestroyStream(false),state(INIT)
 {
 	NPN_PluginThreadAsyncCall(instance, dlStartCallback, this);
 }
@@ -313,7 +320,8 @@
 //
 nsPluginInstance::nsPluginInstance(NPP aInstance, int16_t argc, char** argn, char** argv) : 
 	nsPluginInstanceBase(), mInstance(aInstance),mInitialized(FALSE),mWindow(0),
-	mainDownloaderStream(NULL),mainDownloader(NULL),scriptObject(NULL),m_pt(NULL)
+	mainDownloaderStreambuf(NULL),mainDownloaderStream(NULL),
+	mainDownloader(NULL),scriptObject(NULL),m_pt(NULL)
 {
 	LOG(LOG_INFO, "Lightspark version " << VERSION << " Copyright 2009-2013 Alessandro Pignotti and others");
 	setTLSSys( NULL );
@@ -366,6 +374,8 @@
 	setTLSSys(m_sys);
 	if(mainDownloader)
 		mainDownloader->stop();
+	if (mainDownloaderStreambuf)
+		delete mainDownloaderStreambuf;
 
 	// Kill all stuff relating to NPScriptObject which is still running
 	static_cast<NPScriptObject*>(m_sys->extScriptObject)->destroy();
@@ -644,7 +654,8 @@
 		dl=new NPDownloader(stream->url,m_sys->mainClip->loaderInfo.getPtr());
 		dl->setLength(stream->end);
 		mainDownloader=dl;
-		mainDownloaderStream.rdbuf(mainDownloader);
+		mainDownloaderStreambuf = mainDownloader->getCache()->createReader();
+		mainDownloaderStream.rdbuf(mainDownloaderStreambuf);
 		m_pt=new lightspark::ParseThread(mainDownloaderStream,m_sys->mainClip);
 		m_sys->addJob(m_pt);
 	}
diff -Nuar lightspark-0.7.2.orig/src/plugin/plugin.h lightspark-0.7.2/src/plugin/plugin.h
--- lightspark-0.7.2.orig/src/plugin/plugin.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/plugin/plugin.h	2013-11-09 19:23:31.000000000 +0200
@@ -44,8 +44,11 @@
 	NPP instance;
 public:
 	NPDownloadManager(NPP i);
-	lightspark::Downloader* download(const lightspark::URLInfo& url, bool cached, lightspark::ILoadable* owner);
-	lightspark::Downloader* downloadWithData(const lightspark::URLInfo& url, const std::vector<uint8_t>& data, 
+	lightspark::Downloader* download(const lightspark::URLInfo& url,
+					 _R<StreamCache> cache,
+					 lightspark::ILoadable* owner);
+	lightspark::Downloader* downloadWithData(const lightspark::URLInfo& url,
+			_R<StreamCache> cache, const std::vector<uint8_t>& data,
 			const std::list<tiny_string>& headers, lightspark::ILoadable* owner);
 	void destroy(lightspark::Downloader* downloader);
 };
@@ -63,8 +66,8 @@
 	STATE state;
 	//Constructor used for the main file
 	NPDownloader(const lightspark::tiny_string& _url, lightspark::ILoadable* owner);
-	NPDownloader(const lightspark::tiny_string& _url, bool _cached, NPP _instance, lightspark::ILoadable* owner);
-	NPDownloader(const lightspark::tiny_string& _url, const std::vector<uint8_t>& _data,
+	NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> cache, NPP _instance, lightspark::ILoadable* owner);
+	NPDownloader(const lightspark::tiny_string& _url, _R<StreamCache> cache, const std::vector<uint8_t>& _data,
 			const std::list<tiny_string>& headers, NPP _instance, lightspark::ILoadable* owner);
 };
 
@@ -135,6 +138,7 @@
 	GdkNativeWindow mWindow;
 	int mX, mY;
 
+	std::streambuf *mainDownloaderStreambuf;
 	std::istream mainDownloaderStream;
 	NPDownloader* mainDownloader;
 	NPScriptObjectGW* scriptObject;
diff -Nuar lightspark-0.7.2.orig/src/scripting/abc_codesynt.cpp lightspark-0.7.2/src/scripting/abc_codesynt.cpp
--- lightspark-0.7.2.orig/src/scripting/abc_codesynt.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/abc_codesynt.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -25,18 +25,29 @@
 #endif
 
 #include "compat.h"
-#include <llvm/Module.h>
-#include <llvm/DerivedTypes.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/PassManager.h>
-#include <llvm/Constants.h>
-#ifdef HAVE_IRBUILDER_H
+#ifdef HAVE_IR_DATALAYOUT_H
+#  include <llvm/IR/Constants.h>
+#  include <llvm/IR/DerivedTypes.h>
+#  include <llvm/IR/Module.h>
+#  include <llvm/IR/LLVMContext.h>
+#else
+#  include <llvm/Constants.h>
+#  include <llvm/DerivedTypes.h>
+#  include <llvm/Module.h>
+#  include <llvm/LLVMContext.h>
+#endif
+#ifdef HAVE_IR_DATALAYOUT_H
+#  include <llvm/IR/IRBuilder.h>
+#elif defined HAVE_IRBUILDER_H
 #  include <llvm/IRBuilder.h>
 #else
 #  include <llvm/Support/IRBuilder.h>
 #endif
-#include <llvm/LLVMContext.h>
-#ifdef HAVE_DATALAYOUT_H
+#ifdef HAVE_IR_DATALAYOUT_H
+#  include <llvm/IR/DataLayout.h>
+#elif defined HAVE_DATALAYOUT_H
 #  include <llvm/DataLayout.h>
 #else
 #  include <llvm/Target/TargetData.h>
@@ -279,7 +290,7 @@
 	llvm::FunctionType* FT=NULL;
 
 	//Create types
-#ifdef HAVE_DATALAYOUT_H
+#if defined HAVE_DATALAYOUT_H || defined HAVE_IR_DATALAYOUT_H
 	ptr_type=ex->getDataLayout()->getIntPtrType(llvm_context());
 #else
 	ptr_type=ex->getTargetData()->getIntPtrType(llvm_context());
diff -Nuar lightspark-0.7.2.orig/src/scripting/abc.cpp lightspark-0.7.2/src/scripting/abc.cpp
--- lightspark-0.7.2.orig/src/scripting/abc.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/abc.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -23,12 +23,19 @@
 
 #include "compat.h"
 
-#include <llvm/Module.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
 #include <llvm/PassManager.h>
-#include <llvm/LLVMContext.h>
-#ifdef HAVE_DATALAYOUT_H
+#ifdef HAVE_IR_DATALAYOUT_H
+#  include <llvm/IR/Module.h>
+#  include <llvm/IR/LLVMContext.h>
+#else
+#  include <llvm/Module.h>
+#  include <llvm/LLVMContext.h>
+#endif
+#ifdef HAVE_IR_DATALAYOUT_H
+#  include <llvm/IR/DataLayout.h>
+#elif defined HAVE_DATALAYOUT_H
 #  include <llvm/DataLayout.h>
 #else
 #  include <llvm/Target/TargetData.h>
@@ -49,6 +56,7 @@
 #include "swf.h"
 #include "scripting/toplevel/ASString.h"
 #include "scripting/toplevel/Date.h"
+#include "scripting/toplevel/JSON.h"
 #include "scripting/toplevel/Math.h"
 #include "scripting/toplevel/RegExp.h"
 #include "scripting/toplevel/Vector.h"
@@ -58,6 +66,19 @@
 #include "scripting/flash/desktop/flashdesktop.h"
 #include "scripting/flash/display/flashdisplay.h"
 #include "scripting/flash/display/BitmapData.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/flash/display/GraphicsBitmapFill.h"
+#include "scripting/flash/display/GraphicsEndFill.h"
+#include "scripting/flash/display/GraphicsGradientFill.h"
+#include "scripting/flash/display/GraphicsPath.h"
+#include "scripting/flash/display/GraphicsShaderFill.h"
+#include "scripting/flash/display/GraphicsSolidFill.h"
+#include "scripting/flash/display/GraphicsStroke.h"
+#include "scripting/flash/display/GraphicsTrianglePath.h"
+#include "scripting/flash/display/IGraphicsData.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsPath.h"
+#include "scripting/flash/display/IGraphicsStroke.h"
 #include "scripting/flash/events/flashevents.h"
 #include "scripting/flash/filters/flashfilters.h"
 #include "scripting/flash/net/flashnet.h"
@@ -67,6 +88,9 @@
 #include "scripting/flash/system/flashsystem.h"
 #include "scripting/flash/sensors/flashsensors.h"
 #include "scripting/flash/utils/flashutils.h"
+#include "scripting/flash/utils/Dictionary.h"
+#include "scripting/flash/utils/Proxy.h"
+#include "scripting/flash/utils/Timer.h"
 #include "scripting/flash/geom/flashgeom.h"
 #include "scripting/flash/external/ExternalInterface.h"
 #include "scripting/flash/media/flashmedia.h"
@@ -75,6 +99,7 @@
 #include "scripting/flash/text/flashtext.h"
 #include "scripting/flash/text/flashtextengine.h"
 #include "scripting/flash/ui/Keyboard.h"
+#include "scripting/flash/ui/Mouse.h"
 #include "scripting/class.h"
 #include "exceptions.h"
 #include "scripting/abc.h"
@@ -82,10 +107,10 @@
 using namespace std;
 using namespace lightspark;
 
-static GStaticPrivate is_vm_thread = G_STATIC_PRIVATE_INIT; /* TLS */
+DEFINE_AND_INITIALIZE_TLS(is_vm_thread);
 bool lightspark::isVmThread()
 {
-	return g_static_private_get(&is_vm_thread);
+	return GPOINTER_TO_INT(tls_get(&is_vm_thread));
 }
 
 DoABCTag::DoABCTag(RECORDHEADER h, std::istream& in):ControlTag(h)
@@ -196,6 +221,7 @@
 	builtin->registerBuiltin("Namespace","",Class<Namespace>::getRef());
 	builtin->registerBuiltin("AS3","",_MR(Class<Namespace>::getInstanceS(AS3)));
 	builtin->registerBuiltin("Date","",Class<Date>::getRef());
+	builtin->registerBuiltin("JSON","",Class<JSON>::getRef());
 	builtin->registerBuiltin("RegExp","",Class<RegExp>::getRef());
 	builtin->registerBuiltin("QName","",Class<ASQName>::getRef());
 	builtin->registerBuiltin("uint","",Class<UInteger>::getRef());
@@ -246,6 +272,20 @@
 	builtin->registerBuiltin("Shape","flash.display",Class<Shape>::getRef());
 	builtin->registerBuiltin("Stage","flash.display",Class<Stage>::getRef());
 	builtin->registerBuiltin("Graphics","flash.display",Class<Graphics>::getRef());
+	builtin->registerBuiltin("GraphicsBitmapFill","flash.display",Class<GraphicsBitmapFill>::getRef());
+	builtin->registerBuiltin("GraphicsEndFill","flash.display",Class<GraphicsEndFill>::getRef());
+	builtin->registerBuiltin("GraphicsGradientFill","flash.display",Class<GraphicsGradientFill>::getRef());
+	builtin->registerBuiltin("GraphicsPath","flash.display",Class<GraphicsPath>::getRef());
+	builtin->registerBuiltin("GraphicsPathCommand","flash.display",Class<GraphicsPathCommand>::getRef());
+	builtin->registerBuiltin("GraphicsPathWinding","flash.display",Class<GraphicsPathWinding>::getRef());
+	builtin->registerBuiltin("GraphicsShaderFill","flash.display",Class<GraphicsShaderFill>::getRef());
+	builtin->registerBuiltin("GraphicsSolidFill","flash.display",Class<GraphicsSolidFill>::getRef());
+	builtin->registerBuiltin("GraphicsStroke","flash.display",Class<GraphicsStroke>::getRef());
+	builtin->registerBuiltin("GraphicsTrianglePath","flash.display",Class<GraphicsTrianglePath>::getRef());
+	builtin->registerBuiltin("IGraphicsData","flash.display",InterfaceClass<IGraphicsData>::getRef());
+	builtin->registerBuiltin("IGraphicsFill","flash.display",InterfaceClass<IGraphicsFill>::getRef());
+	builtin->registerBuiltin("IGraphicsPath","flash.display",InterfaceClass<IGraphicsPath>::getRef());
+	builtin->registerBuiltin("IGraphicsStroke","flash.display",InterfaceClass<IGraphicsStroke>::getRef());
 	builtin->registerBuiltin("GradientType","flash.display",Class<GradientType>::getRef());
 	builtin->registerBuiltin("BlendMode","flash.display",Class<BlendMode>::getRef());
 	builtin->registerBuiltin("LineScaleMode","flash.display",Class<LineScaleMode>::getRef());
@@ -256,10 +296,6 @@
 	builtin->registerBuiltin("BitmapData","flash.display",Class<BitmapData>::getRef());
 	builtin->registerBuiltin("Bitmap","flash.display",Class<Bitmap>::getRef());
 	builtin->registerBuiltin("IBitmapDrawable","flash.display",InterfaceClass<IBitmapDrawable>::getRef());
-	builtin->registerBuiltin("GraphicsGradientFill","flash.display",
-			Class<ASObject>::getStubClass(QName("GraphicsGradientFill","flash.display")));
-	builtin->registerBuiltin("GraphicsPath","flash.display",
-			Class<ASObject>::getStubClass(QName("GraphicsPath","flash.display")));
 	builtin->registerBuiltin("MorphShape","flash.display",Class<MorphShape>::getRef());
 	builtin->registerBuiltin("SpreadMethod","flash.display",Class<SpreadMethod>::getRef());
 	builtin->registerBuiltin("InterpolationMethod","flash.display",Class<InterpolationMethod>::getRef());
@@ -270,6 +306,7 @@
 	builtin->registerBuiltin("BitmapDataChannel","flash.display",Class<BitmapDataChannel>::getRef());
 
 	builtin->registerBuiltin("BitmapFilter","flash.filters",Class<BitmapFilter>::getRef());
+	builtin->registerBuiltin("BitmapFilterQuality","flash.filters",Class<BitmapFilterQuality>::getRef());
 	builtin->registerBuiltin("DropShadowFilter","flash.filters",Class<DropShadowFilter>::getRef());
 	builtin->registerBuiltin("GlowFilter","flash.filters",Class<GlowFilter>::getRef());
 	builtin->registerBuiltin("GradientGlowFilter","flash.filters",
@@ -303,6 +340,7 @@
 	builtin->registerBuiltin("TextFormat","flash.text",Class<TextFormat>::getRef());
 	builtin->registerBuiltin("TextFormatAlign","flash.text",Class<TextFormatAlign>::getRef());
 	builtin->registerBuiltin("TextLineMetrics","flash.text",Class<TextLineMetrics>::getRef());
+	builtin->registerBuiltin("TextInteractionMode","flash.text",Class<TextInteractionMode>::getRef());
 	builtin->registerBuiltin("StaticText","flash.text",Class<StaticText>::getRef());
 
 	builtin->registerBuiltin("ContentElement","flash.text.engine",Class<ContentElement>::getRef());
@@ -413,6 +451,7 @@
 	builtin->registerBuiltin("KeyLocation","flash.ui",Class<KeyLocation>::getRef());
 	builtin->registerBuiltin("ContextMenu","flash.ui",Class<ASObject>::getStubClass(QName("ContextMenu","flash.ui")));
 	builtin->registerBuiltin("ContextMenuItem","flash.ui",Class<ASObject>::getStubClass(QName("ContextMenuItem","flash.ui")));
+	builtin->registerBuiltin("Mouse","flash.ui",Class<Mouse>::getRef());
 
 	builtin->registerBuiltin("Accelerometer", "flash.sensors",Class<Accelerometer>::getRef());
 
@@ -1460,7 +1499,7 @@
 	while(getVm()!=th);
 
 	/* set TLS variable for isVmThread() */
-        g_static_private_set(&is_vm_thread,(void*)1,NULL);
+        tls_set(&is_vm_thread, GINT_TO_POINTER(1));
 
 	if(th->m_sys->useJit)
 	{
@@ -1489,7 +1528,7 @@
 		assert_and_throw(th->ex);
 
 		th->FPM=new llvm::FunctionPassManager(th->module);
-#ifdef HAVE_DATALAYOUT_H
+#if defined HAVE_DATALAYOUT_H || defined HAVE_IR_DATALAYOUT_H
 		th->FPM->add(new llvm::DataLayout(*th->ex->getDataLayout()));
 #else
 		th->FPM->add(new llvm::TargetData(*th->ex->getTargetData()));
@@ -1938,9 +1977,9 @@
 				//do interfaces have cinit methods?
 				//TODO: call them, set constructor property, do something
 				if(classes[t->classi].cinit != 0)
-					LOG(LOG_NOT_IMPLEMENTED,"Interface cinit (static)");
+					LOG(LOG_NOT_IMPLEMENTED,"Interface cinit (static):"<<className);
 				if(instances[t->classi].init != 0)
-					LOG(LOG_NOT_IMPLEMENTED,"Interface cinit (constructor)");
+					LOG(LOG_NOT_IMPLEMENTED,"Interface cinit (constructor):"<<className);
 				ret = ci;
 			}
 			else
diff -Nuar lightspark-0.7.2.orig/src/scripting/abc.h lightspark-0.7.2/src/scripting/abc.h
--- lightspark-0.7.2.orig/src/scripting/abc.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/abc.h	2013-11-09 19:23:31.000000000 +0200
@@ -390,7 +390,10 @@
 
 	//Internal utilities
 	static void method_reset(method_info* th);
-	static void newClassRecursiveLink(Class_base* target, Class_base* c);
+
+	static void SetAllClassLinks();
+	static void AddClassLinks(Class_base* target);
+	static bool newClassRecursiveLink(Class_base* target, Class_base* c);
 	static ASObject* constructFunction(call_context* th, IFunction* f, ASObject** args, int argslen);
 	void parseRPCMessage(_R<ByteArray> message, _NR<ASObject> client, _NR<Responder> responder);
 
@@ -405,6 +408,7 @@
 	static typed_opcode_handler opcode_table_voidptr[];
 	static typed_opcode_handler opcode_table_bool_t[];
 
+
 	//Synchronization
 	Mutex event_queue_mutex;
 	Cond sem_event_cond;
diff -Nuar lightspark-0.7.2.orig/src/scripting/abc_interpreter.cpp lightspark-0.7.2/src/scripting/abc_interpreter.cpp
--- lightspark-0.7.2.orig/src/scripting/abc_interpreter.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/abc_interpreter.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -1244,7 +1244,7 @@
 				ASObject* v1=context->runtime_stack_pop();
 				ASObject* v2=context->runtime_stack_pop();
 
-				ASObject* ret=abstract_i(urShift(v1, v2));
+				ASObject* ret=abstract_ui(urShift(v1, v2));
 				context->runtime_stack_push(ret);
 				break;
 			}
diff -Nuar lightspark-0.7.2.orig/src/scripting/abc_opcodes.cpp lightspark-0.7.2/src/scripting/abc_opcodes.cpp
--- lightspark-0.7.2.orig/src/scripting/abc_opcodes.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/abc_opcodes.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -27,6 +27,7 @@
 #include "scripting/toplevel/RegExp.h"
 #include "scripting/toplevel/XML.h"
 #include "scripting/toplevel/XMLList.h"
+#include "scripting/flash/utils/Proxy.h"
 
 using namespace std;
 using namespace lightspark;
@@ -140,12 +141,9 @@
 
 ASObject* ABCVm::checkfilter(ASObject* o)
 {
-	Class_base* xmlClass=Class<XML>::getClass();
-	Class_base* xmlListClass=Class<XMLList>::getClass();
-
-	if (o->getClass()!=xmlClass && o->getClass()!=xmlListClass)
-		throw Class<TypeError>::getInstanceS();
-
+	LOG(LOG_CALLS, _("checkfilter") );
+	if (!o->is<XML>() && !o->is<XMLList>())
+		throwError<TypeError>(kFilterError, o->getClassName());
 	return o;
 }
 
@@ -588,31 +586,33 @@
 	if(f->inClass)
 		throwError<TypeError>(kCannotCallMethodAsConstructor, "");
 
-	assert(f->is<SyntheticFunction>());
-	SyntheticFunction* sf=f->as<SyntheticFunction>();
-	assert(sf->prototype);
-	ASObject* ret=new_functionObject(sf->prototype);
+	assert(f->prototype);
+	ASObject* ret=new_functionObject(f->prototype);
 #ifndef NDEBUG
 	ret->initialized=false;
 #endif
-	if (sf->mi->body)
+	if (f->is<SyntheticFunction>())
 	{
-		LOG(LOG_CALLS,_("Building method traits"));
-		for(unsigned int i=0;i<sf->mi->body->trait_count;i++)
-			th->context->buildTrait(ret,&sf->mi->body->traits[i],false);
+		SyntheticFunction* sf=f->as<SyntheticFunction>();
+		if (sf->mi->body)
+		{
+			LOG(LOG_CALLS,_("Building method traits"));
+			for(unsigned int i=0;i<sf->mi->body->trait_count;i++)
+				th->context->buildTrait(ret,&sf->mi->body->traits[i],false);
+		}
 	}
 #ifndef NDEBUG
 	ret->initialized=true;
 #endif
 
-	sf->incRef();
-	ret->setVariableByQName("constructor","",sf,DYNAMIC_TRAIT);
+	f->incRef();
+	ret->setVariableByQName("constructor","",f,DYNAMIC_TRAIT);
 
 	ret->incRef();
 
-	sf->incRef();
-	ASObject* ret2=sf->call(ret,args,argslen);
-	sf->decRef();
+	f->incRef();
+	ASObject* ret2=f->call(ret,args,argslen);
+	f->decRef();
 
 	//ECMA: "return ret2 if it is an object, else ret"
 	if(ret2 && !ret2->is<Undefined>())
@@ -655,15 +655,6 @@
 			break;
 		}
 
-		case T_UNDEFINED:
-		case T_NULL:
-		{
-			//Inc ref count to make up for decremnt later
-			obj->incRef();
-			ret=obj;
-			break;
-		}
-
 		case T_FUNCTION:
 		{
 			ret = constructFunction(th, obj->as<IFunction>(), args, m);
@@ -1922,18 +1913,42 @@
 	ret->incRef();
 	return ret.getPtr();
 }
+std::vector<Class_base*> classesToLinkInterfaces;
+void ABCVm::SetAllClassLinks()
+{
+	for (unsigned int i = 0; i < classesToLinkInterfaces.size(); i++)
+	{
+		Class_base* cls = classesToLinkInterfaces[i];
+		if (!cls)
+			continue;
+		if (ABCVm::newClassRecursiveLink(cls, cls))
+			classesToLinkInterfaces[i] = NULL;
+	}
+}
+void ABCVm::AddClassLinks(Class_base* target)
+{
+	classesToLinkInterfaces.push_back(target);
+}
 
-void ABCVm::newClassRecursiveLink(Class_base* target, Class_base* c)
+bool ABCVm::newClassRecursiveLink(Class_base* target, Class_base* c)
 {
 	if(c->super)
-		newClassRecursiveLink(target, c->super.getPtr());
-
-	const vector<Class_base*>& interfaces=c->getInterfaces();
+	{
+		if (!newClassRecursiveLink(target, c->super.getPtr()))
+			return false;
+	}
+	bool bAllDefined = false;
+	const vector<Class_base*>& interfaces=c->getInterfaces(&bAllDefined);
+	if (!bAllDefined)
+	{
+		return false;
+	}
 	for(unsigned int i=0;i<interfaces.size();i++)
 	{
 		LOG(LOG_CALLS,_("Linking with interface ") << interfaces[i]->class_name);
 		interfaces[i]->linkInterface(target);
 	}
+	return true;
 }
 
 void ABCVm::newClass(call_context* th, int n)
@@ -1957,6 +1972,9 @@
 		baseClass->decRef();
 		oldDefinition->incRef();
 		th->runtime_stack_push(oldDefinition);
+		// ensure that this interface is linked to all previously defined classes implementing this interface
+		if (th->context->instances[n].isInterface())
+			ABCVm::SetAllClassLinks();
 		return;
 	}
 
@@ -2056,9 +2074,16 @@
 	if(!th->context->instances[n].isInterface())
 	{
 		//Link all the interfaces for this class and all the bases
-		newClassRecursiveLink(ret, ret);
+		if (!newClassRecursiveLink(ret, ret))
+		{
+			// remember classes where not all interfaces are defined yet
+			ABCVm::AddClassLinks(ret);
+		}
 	}
-
+	// ensure that this interface is linked to all previously defined classes implementing this interface
+	if (th->context->instances[n].isInterface())
+		ABCVm::SetAllClassLinks();
+	
 	LOG(LOG_CALLS,_("Calling Class init ") << ret);
 	ret->incRef();
 	//Class init functions are called with global as this
diff -Nuar lightspark-0.7.2.orig/src/scripting/class.h lightspark-0.7.2/src/scripting/class.h
--- lightspark-0.7.2.orig/src/scripting/class.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/class.h	2013-11-09 19:23:31.000000000 +0200
@@ -149,7 +149,7 @@
 			ret->prototype = _MNR(new_objectPrototype());
 			T::sinit(ret);
 
-			ret->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
+			ret->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
 			ret->incRef();
 			ret->prototype->setVariableByQName("constructor","",ret,DYNAMIC_TRAIT);
 			if(ret->super)
@@ -257,7 +257,7 @@
 		ret->addPrototypeGetter();
 		ret->addLengthGetter();
 
-		ret->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
+		ret->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
 		getSys()->customClasses.insert(ret);
 		ret->incRef();
 		return _MR(ret);
@@ -278,7 +278,7 @@
 			ret->prototype = _MNR(new_objectPrototype());
 			ASObject::sinit(ret);
 
-			ret->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
+			ret->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
 			ret->incRef();
 			ret->prototype->setVariableByQName("constructor","",ret,DYNAMIC_TRAIT);
 			ret->addPrototypeGetter();
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/accessibility/flashaccessibility.cpp lightspark-0.7.2/src/scripting/flash/accessibility/flashaccessibility.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/accessibility/flashaccessibility.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/accessibility/flashaccessibility.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -23,25 +23,37 @@
 
 using namespace lightspark;
 
+AccessibilityProperties::AccessibilityProperties(Class_base* c):
+	ASObject(c), forceSimple(false), noAutoLabeling(false), silent(false)
+{
+}
+
 void AccessibilityProperties::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-	REGISTER_GETTER_SETTER(c,name);
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
+	REGISTER_GETTER_SETTER(c, description);
+	REGISTER_GETTER_SETTER(c, forceSimple);
+	REGISTER_GETTER_SETTER(c, name);
+	REGISTER_GETTER_SETTER(c, noAutoLabeling);
+	REGISTER_GETTER_SETTER(c, shortcut);
+	REGISTER_GETTER_SETTER(c, silent);
 }
 
 ASFUNCTIONBODY(AccessibilityProperties,_constructor)
 {
-	LOG(LOG_NOT_IMPLEMENTED, _("AccessibilityProperties class is unimplemented."));
 	return NULL;
 }
 
-ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties,name);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, description);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, forceSimple);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, name);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, noAutoLabeling);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, shortcut);
+ASFUNCTIONBODY_GETTER_SETTER(AccessibilityProperties, silent);
 
 void AccessibilityImplementation::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 }
 
 ASFUNCTIONBODY(AccessibilityImplementation,_constructor)
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/accessibility/flashaccessibility.h lightspark-0.7.2/src/scripting/flash/accessibility/flashaccessibility.h
--- lightspark-0.7.2.orig/src/scripting/flash/accessibility/flashaccessibility.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/accessibility/flashaccessibility.h	2013-11-09 19:23:31.000000000 +0200
@@ -28,9 +28,14 @@
 class AccessibilityProperties : public ASObject
 {
 private:
-	ASPROPERTY_GETTER_SETTER(tiny_string,name);
+	ASPROPERTY_GETTER_SETTER(tiny_string, description);
+	ASPROPERTY_GETTER_SETTER(bool, forceSimple);
+	ASPROPERTY_GETTER_SETTER(tiny_string, name);
+	ASPROPERTY_GETTER_SETTER(bool, noAutoLabeling);
+	ASPROPERTY_GETTER_SETTER(tiny_string, shortcut);
+	ASPROPERTY_GETTER_SETTER(bool, silent);
 public:
-	AccessibilityProperties(Class_base* c):ASObject(c){}
+	AccessibilityProperties(Class_base* c);
 	static void sinit(Class_base*);
 	ASFUNCTION(_constructor);
 };
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/desktop/flashdesktop.cpp lightspark-0.7.2/src/scripting/flash/desktop/flashdesktop.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/desktop/flashdesktop.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/desktop/flashdesktop.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -27,9 +27,7 @@
 
 void NativeApplication::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("nativeApplication", "", Class<IFunction>::getFunction(_getNativeApplication), GETTER_METHOD, false);
 	c->setDeclaredMethodByQName("addEventListener", "", Class<IFunction>::getFunction(addEventListener), NORMAL_METHOD, true);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/BitmapData.cpp lightspark-0.7.2/src/scripting/flash/display/BitmapData.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/BitmapData.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/BitmapData.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -24,6 +24,7 @@
 #include "scripting/flash/geom/flashgeom.h"
 #include "scripting/toplevel/Vector.h"
 #include "scripting/flash/errors/flasherrors.h"
+#include "scripting/flash/utils/ByteArray.h"
 #include "backends/rendering_context.h"
 
 using namespace lightspark;
@@ -55,8 +56,7 @@
 
 void BitmapData::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->addImplementedInterface(InterfaceClass<IBitmapDrawable>::getClass());
 	c->setDeclaredMethodByQName("draw","",Class<IFunction>::getFunction(draw),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("dispose","",Class<IFunction>::getFunction(dispose),NORMAL_METHOD,true);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/DisplayObject.cpp lightspark-0.7.2/src/scripting/flash/display/DisplayObject.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/DisplayObject.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/DisplayObject.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -118,8 +118,7 @@
 
 void DisplayObject::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructorNotInstantiatable, CLASS_SEALED);
 	c->setDeclaredMethodByQName("loaderInfo","",Class<IFunction>::getFunction(_getLoaderInfo),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(_getWidth),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(_setWidth),SETTER_METHOD,true);
@@ -634,14 +633,6 @@
 	return ret;
 }
 
-ASFUNCTIONBODY(DisplayObject,_constructor)
-{
-	//DisplayObject* th=static_cast<DisplayObject*>(obj->implementation);
-	EventDispatcher::_constructor(obj,NULL,0);
-
-	return NULL;
-}
-
 ASFUNCTIONBODY(DisplayObject,_getLoaderInfo)
 {
 	DisplayObject* th=static_cast<DisplayObject*>(obj);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/DisplayObject.h lightspark-0.7.2/src/scripting/flash/display/DisplayObject.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/DisplayObject.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/DisplayObject.h	2013-11-09 19:23:31.000000000 +0200
@@ -179,7 +179,6 @@
 	number_t getNominalHeight();
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
-	ASFUNCTION(_constructor);
 	ASFUNCTION(_getVisible);
 	ASFUNCTION(_setVisible);
 	ASFUNCTION(_getStage);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/flashdisplay.cpp lightspark-0.7.2/src/scripting/flash/display/flashdisplay.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/flashdisplay.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/flashdisplay.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -22,6 +22,7 @@
 #include "backends/security.h"
 #include "scripting/abc.h"
 #include "scripting/flash/display/flashdisplay.h"
+#include "scripting/flash/display/Graphics.h"
 #include "swf.h"
 #include "scripting/flash/geom/flashgeom.h"
 #include "scripting/flash/system/flashsystem.h"
@@ -66,8 +67,7 @@
 
 void LoaderInfo::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("loaderURL","",Class<IFunction>::getFunction(_getLoaderURL),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("loader","",Class<IFunction>::getFunction(_getLoader),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("content","",Class<IFunction>::getFunction(_getContent),GETTER_METHOD,true);
@@ -296,19 +296,23 @@
 	streambuf *sbuf = 0;
 	if(source==URL)
 	{
-		if(!createDownloader(false, loaderInfo, loaderInfo.getPtr(), false))
+		_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+		if(!createDownloader(cache, loaderInfo, loaderInfo.getPtr(), false))
 			return;
 
-		downloader->waitForData(); //Wait for some data, making sure our check for failure is working
-		if(downloader->hasFailed()) //Check to see if the download failed for some reason
+		sbuf = cache->createReader();
+		
+		// Wait for some data, making sure our check for failure is working
+		sbuf->sgetc(); // peek one byte
+		if(cache->hasFailed()) //Check to see if the download failed for some reason
 		{
 			LOG(LOG_ERROR, "Loader::execute(): Download of URL failed: " << url);
 			getVm()->addEvent(loaderInfo,_MR(Class<IOErrorEvent>::getInstanceS()));
+			delete sbuf;
 			// downloader will be deleted in jobFence
 			return;
 		}
 		getVm()->addEvent(loaderInfo,_MR(Class<Event>::getInstanceS("open")));
-		sbuf=downloader;
 	}
 	else if(source==BYTES)
 	{
@@ -324,19 +328,15 @@
 	ParseThread local_pt(s,loaderInfo->applicationDomain,loaderInfo->securityDomain,loader.getPtr(),url.getParsedURL());
 	local_pt.execute();
 
-	// Delete the bytes container (downloader or bytes_buf)
+	// Delete the bytes container (cache reader or bytes_buf)
+	delete sbuf;
+	sbuf = NULL;
 	if (source==URL) {
 		//Acquire the lock to ensure consistency in threadAbort
 		SpinlockLocker l(downloaderLock);
 		if(downloader)
 			getSys()->downloadManager->destroy(downloader);
 		downloader=NULL;
-		sbuf = NULL;
-	}
-	else if (source==BYTES)
-	{
-		delete sbuf;
-		sbuf = NULL;
 	}
 
 	bytes.reset();
@@ -402,12 +402,21 @@
 	//Check if a security domain has been manually set
 	_NR<SecurityDomain> secDomain;
 	_NR<SecurityDomain> curSecDomain=ABCVm::getCurrentSecurityDomain(getVm()->currentCallContext);
-	if(!context.isNull() && !context->securityDomain.isNull())
+	if(!context.isNull())
 	{
-		//The passed domain must be the current one. See Loader::load specs.
-		if(context->securityDomain!=curSecDomain)
-			throw Class<SecurityError>::getInstanceS("SecurityError: securityDomain must be current one");
-		secDomain=curSecDomain;
+		if (!context->securityDomain.isNull())
+		{
+			//The passed domain must be the current one. See Loader::load specs.
+			if(context->securityDomain!=curSecDomain)
+				throw Class<SecurityError>::getInstanceS("SecurityError: securityDomain must be current one");
+			secDomain=curSecDomain;
+		}
+
+		bool sameDomain = (secDomain == curSecDomain);
+		th->allowCodeImport = !sameDomain || context->getAllowCodeImport();
+
+		if (!context->parameters.isNull())
+			th->contentLoaderInfo->setParameters(context->parameters);
 	}
 	//Default is to create a child ApplicationDomain if the file is in the same security context
 	//otherwise create a child of the system domain. If the security domain is different
@@ -443,6 +452,19 @@
 	SecurityManager::checkURLStaticAndThrow(th->url, ~(SecurityManager::LOCAL_WITH_FILE),
 		SecurityManager::LOCAL_WITH_FILE | SecurityManager::LOCAL_TRUSTED, true);
 
+	if (!context.isNull() && context->getCheckPolicyFile())
+	{
+		//TODO: this should be async as it could block if invoked from ExternalInterface
+		SecurityManager::EVALUATIONRESULT evaluationResult;
+		evaluationResult = getSys()->securityManager->evaluatePoliciesURL(th->url, true);
+		if(evaluationResult == SecurityManager::NA_CROSSDOMAIN_POLICY)
+		{
+			// should this dispatch SecurityErrorEvent instead of throwing?
+			throw Class<SecurityError>::getInstanceS(
+				"SecurityError: connection to domain not allowed by securityManager");
+		}
+	}
+
 	th->incRef();
 	r->incRef();
 	LoaderThread *thread=new LoaderThread(_MR(r), _MR(th));
@@ -473,6 +495,11 @@
 	_NR<SecurityDomain> curSecDomain=ABCVm::getCurrentSecurityDomain(getVm()->currentCallContext);
 	th->contentLoaderInfo->securityDomain = curSecDomain;
 
+	th->allowCodeImport = context.isNull() || context->getAllowCodeImport();
+
+	if (!context.isNull() && !context->parameters.isNull())
+		th->contentLoaderInfo->setParameters(context->parameters);
+
 	if(bytes->getLength()!=0)
 	{
 		th->incRef();
@@ -526,7 +553,7 @@
 	contentLoaderInfo.reset();
 }
 
-Loader::Loader(Class_base* c):DisplayObjectContainer(c),content(NullRef),contentLoaderInfo(NullRef),loaded(false)
+Loader::Loader(Class_base* c):DisplayObjectContainer(c),content(NullRef),contentLoaderInfo(NullRef),loaded(false), allowCodeImport(true)
 {
 	incRef();
 	contentLoaderInfo=_MR(Class<LoaderInfo>::getInstanceS(_MR(this)));
@@ -538,8 +565,7 @@
 
 void Loader::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObjectContainer>::getRef());
+	CLASS_SETUP(c, DisplayObjectContainer, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("contentLoaderInfo","",Class<IFunction>::getFunction(_getContentLoaderInfo),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("content","",Class<IFunction>::getFunction(_getContent),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("close","",Class<IFunction>::getFunction(close),NORMAL_METHOD,true);
@@ -590,8 +616,7 @@
 
 void Sprite::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObjectContainer>::getRef());
+	CLASS_SETUP(c, DisplayObjectContainer, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("graphics","",Class<IFunction>::getFunction(_getGraphics),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("startDrag","",Class<IFunction>::getFunction(_startDrag),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("stopDrag","",Class<IFunction>::getFunction(_stopDrag),NORMAL_METHOD,true);
@@ -849,8 +874,7 @@
 
 void FrameLabel::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("frame","",Class<IFunction>::getFunction(_getFrame),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("name","",Class<IFunction>::getFunction(_getName),GETTER_METHOD,true);
 }
@@ -906,8 +930,7 @@
 
 void Scene::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("labels","",Class<IFunction>::getFunction(_getLabels),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("name","",Class<IFunction>::getFunction(_getName),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("numFrames","",Class<IFunction>::getFunction(_getNumFrames),GETTER_METHOD,true);
@@ -999,8 +1022,7 @@
 
 void MovieClip::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Sprite>::getRef());
+	CLASS_SETUP(c, Sprite, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 	c->setDeclaredMethodByQName("currentFrame","",Class<IFunction>::getFunction(_getCurrentFrame),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("totalFrames","",Class<IFunction>::getFunction(_getTotalFrames),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("framesLoaded","",Class<IFunction>::getFunction(_getFramesLoaded),GETTER_METHOD,true);
@@ -1345,8 +1367,7 @@
 
 void DisplayObjectContainer::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<InteractiveObject>::getRef());
+	CLASS_SETUP(c, InteractiveObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("numChildren","",Class<IFunction>::getFunction(_getNumChildren),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("getChildIndex","",Class<IFunction>::getFunction(_getChildIndex),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("setChildIndex","",Class<IFunction>::getFunction(_setChildIndex),NORMAL_METHOD,true);
@@ -1513,8 +1534,7 @@
 
 void InteractiveObject::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	CLASS_SETUP(c, DisplayObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("mouseEnabled","",Class<IFunction>::getFunction(_setMouseEnabled),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("mouseEnabled","",Class<IFunction>::getFunction(_getMouseEnabled),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("doubleClickEnabled","",Class<IFunction>::getFunction(_setDoubleClickEnabled),SETTER_METHOD,true);
@@ -1958,8 +1978,7 @@
 
 void Shape::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	CLASS_SETUP(c, DisplayObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("graphics","",Class<IFunction>::getFunction(_getGraphics),GETTER_METHOD,true);
 }
 
@@ -1984,8 +2003,9 @@
 
 void MorphShape::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	// FIXME: should use _constructorNotInstantiatable but then
+	// DefineMorphShapeTag::instance breaks
+	CLASS_SETUP_NO_CONSTRUCTOR(c, DisplayObject, CLASS_SEALED | CLASS_FINAL);
 }
 
 void MorphShape::buildTraits(ASObject* o)
@@ -1993,12 +2013,6 @@
 	//No traits
 }
 
-ASFUNCTIONBODY(MorphShape,_constructor)
-{
-	DisplayObject::_constructor(obj,NULL,0);
-	return NULL;
-}
-
 bool MorphShape::boundsRect(number_t& xmin, number_t& xmax, number_t& ymin, number_t& ymax) const
 {
 	LOG(LOG_NOT_IMPLEMENTED, "MorphShape::boundsRect is a stub");
@@ -2012,8 +2026,12 @@
 
 void Stage::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObjectContainer>::getRef());
+	CLASS_SETUP(c, DisplayObjectContainer, _constructor, CLASS_SEALED);
+	c->setDeclaredMethodByQName("allowFullScreen","",Class<IFunction>::getFunction(_getAllowFullScreen),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("allowFullScreenInteractive","",Class<IFunction>::getFunction(_getAllowFullScreenInteractive),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("colorCorrectionSupport","",Class<IFunction>::getFunction(_getColorCorrectionSupport),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("fullScreenHeight","",Class<IFunction>::getFunction(_getStageHeight),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("fullScreenWidth","",Class<IFunction>::getFunction(_getStageWidth),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("stageWidth","",Class<IFunction>::getFunction(_getStageWidth),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("stageWidth","",Class<IFunction>::getFunction(undefinedFunction),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("stageHeight","",Class<IFunction>::getFunction(_getStageHeight),GETTER_METHOD,true);
@@ -2026,23 +2044,62 @@
 	c->setDeclaredMethodByQName("stageVideos","",Class<IFunction>::getFunction(_getStageVideos),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("focus","",Class<IFunction>::getFunction(_getFocus),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("focus","",Class<IFunction>::getFunction(_setFocus),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("frameRate","",Class<IFunction>::getFunction(_getFrameRate),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("frameRate","",Class<IFunction>::getFunction(_setFrameRate),SETTER_METHOD,true);
 	// override the setter from DisplayObjectContainer
 	c->setDeclaredMethodByQName("tabChildren","",Class<IFunction>::getFunction(_setTabChildren),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("wmodeGPU","",Class<IFunction>::getFunction(_getWmodeGPU),GETTER_METHOD,true);
+	REGISTER_GETTER_SETTER(c,align);
+	REGISTER_GETTER_SETTER(c,colorCorrection);
 	REGISTER_GETTER_SETTER(c,displayState);
+	REGISTER_GETTER_SETTER(c,fullScreenSourceRect);
+	REGISTER_GETTER_SETTER(c,showDefaultContextMenu);
+	REGISTER_GETTER_SETTER(c,quality);
 }
 
+ASFUNCTIONBODY_GETTER_SETTER_CB(Stage,align,onAlign);
+ASFUNCTIONBODY_GETTER_SETTER_CB(Stage,colorCorrection,onColorCorrection);
+ASFUNCTIONBODY_GETTER_SETTER_CB(Stage,displayState,onDisplayState);
+ASFUNCTIONBODY_GETTER_SETTER(Stage,showDefaultContextMenu);  // stub
+ASFUNCTIONBODY_GETTER_SETTER_CB(Stage,fullScreenSourceRect,onFullScreenSourceRect);
+ASFUNCTIONBODY_GETTER_SETTER(Stage,quality);
+
 void Stage::onDisplayState(const tiny_string&)
 {
-	LOG(LOG_NOT_IMPLEMENTED,"Stage.displayState = " << displayState);
+	if (displayState != "normal")
+		LOG(LOG_NOT_IMPLEMENTED,"Stage.displayState = " << displayState);
+	displayState = "normal"; // until fullscreen support is implemented
 }
 
-ASFUNCTIONBODY_GETTER_SETTER_CB(Stage,displayState,onDisplayState);
+void Stage::onAlign(const tiny_string& /*oldValue*/)
+{
+	LOG(LOG_NOT_IMPLEMENTED, "Stage.align = " << align);
+}
+
+void Stage::onColorCorrection(const tiny_string& oldValue)
+{
+	if (colorCorrection != "default" && 
+	    colorCorrection != "on" && 
+	    colorCorrection != "off")
+	{
+		colorCorrection = oldValue;
+		throwError<ArgumentError>(kInvalidEnumError, "colorCorrection");
+	}
+}
+
+void Stage::onFullScreenSourceRect(_NR<Rectangle> /*oldValue*/)
+{
+	LOG(LOG_NOT_IMPLEMENTED, "Stage.fullScreenSourceRect");
+	fullScreenSourceRect.reset();
+}
 
 void Stage::buildTraits(ASObject* o)
 {
 }
 
-Stage::Stage(Class_base* c):DisplayObjectContainer(c)
+Stage::Stage(Class_base* c):
+	DisplayObjectContainer(c), colorCorrection("default"),
+	showDefaultContextMenu(true), quality("high")
 {
 	onStage = true;
 }
@@ -2207,639 +2264,50 @@
 	return NULL;
 }
 
-void Graphics::sinit(Class_base* c)
-{
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setDeclaredMethodByQName("clear","",Class<IFunction>::getFunction(clear),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("copyFrom","",Class<IFunction>::getFunction(copyFrom),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("drawRect","",Class<IFunction>::getFunction(drawRect),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("drawRoundRect","",Class<IFunction>::getFunction(drawRoundRect),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("drawCircle","",Class<IFunction>::getFunction(drawCircle),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("drawTriangles","",Class<IFunction>::getFunction(drawTriangles),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("moveTo","",Class<IFunction>::getFunction(moveTo),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("curveTo","",Class<IFunction>::getFunction(curveTo),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("cubicCurveTo","",Class<IFunction>::getFunction(cubicCurveTo),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("lineTo","",Class<IFunction>::getFunction(lineTo),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("lineStyle","",Class<IFunction>::getFunction(lineStyle),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("beginFill","",Class<IFunction>::getFunction(beginFill),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("beginGradientFill","",Class<IFunction>::getFunction(beginGradientFill),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("beginBitmapFill","",Class<IFunction>::getFunction(beginBitmapFill),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("endFill","",Class<IFunction>::getFunction(endFill),NORMAL_METHOD,true);
-}
-
-void Graphics::buildTraits(ASObject* o)
-{
-}
-
-ASFUNCTIONBODY(Graphics,_constructor)
-{
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,clear)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	th->checkAndSetScaling();
-	th->owner->tokens.clear();
-	th->owner->owner->requestInvalidation(getSys());
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,moveTo)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	th->checkAndSetScaling();
-	assert_and_throw(argslen==2);
-
-	th->curX=args[0]->toInt();
-	th->curY=args[1]->toInt();
-
-	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(th->curX, th->curY)));
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,lineTo)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==2);
-	th->checkAndSetScaling();
-
-	int x=args[0]->toInt();
-	int y=args[1]->toInt();
-
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y)));
-	th->owner->owner->requestInvalidation(getSys());
-
-	th->curX=x;
-	th->curY=y;
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,curveTo)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==4);
-	th->checkAndSetScaling();
-
-	int controlX=args[0]->toInt();
-	int controlY=args[1]->toInt();
-
-	int anchorX=args[2]->toInt();
-	int anchorY=args[3]->toInt();
-
-	th->owner->tokens.emplace_back(GeomToken(CURVE_QUADRATIC,
-	                        Vector2(controlX, controlY),
-	                        Vector2(anchorX, anchorY)));
-	th->owner->owner->requestInvalidation(getSys());
-
-	th->curX=anchorX;
-	th->curY=anchorY;
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,cubicCurveTo)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==6);
-	th->checkAndSetScaling();
-
-	int control1X=args[0]->toInt();
-	int control1Y=args[1]->toInt();
-
-	int control2X=args[2]->toInt();
-	int control2Y=args[3]->toInt();
-
-	int anchorX=args[4]->toInt();
-	int anchorY=args[5]->toInt();
-
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(control1X, control1Y),
-	                        Vector2(control2X, control2Y),
-	                        Vector2(anchorX, anchorY)));
-	th->owner->owner->requestInvalidation(getSys());
-
-	th->curX=anchorX;
-	th->curY=anchorY;
-	return NULL;
-}
-
-/* KAPPA = 4 * (sqrt2 - 1) / 3
- * This value was found in a Python prompt:
- *
- * >>> 4.0 * (2**0.5 - 1) / 3.0
- *
- * Source: http://whizkidtech.redprince.net/bezier/circle/
- */
-const double KAPPA = 0.55228474983079356;
-
-ASFUNCTIONBODY(Graphics,drawRoundRect)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==5 || argslen==6);
-	th->checkAndSetScaling();
-
-	double x=args[0]->toNumber();
-	double y=args[1]->toNumber();
-	double width=args[2]->toNumber();
-	double height=args[3]->toNumber();
-	double ellipseWidth=args[4]->toNumber();
-	double ellipseHeight;
-	if (argslen == 6)
-		ellipseHeight=args[5]->toNumber();
-
-	if (argslen == 5 || std::isnan(ellipseHeight))
-		ellipseHeight=ellipseWidth;
-
-	ellipseHeight /= 2;
-	ellipseWidth  /= 2;
-
-	double kappaW = KAPPA * ellipseWidth;
-	double kappaH = KAPPA * ellipseHeight;
-
-	/*
-	 *    A-----B
-	 *   /       \
-	 *  H         C
-	 *  |         |
-	 *  G         D
-	 *   \       /
-	 *    F-----E
-	 * 
-	 * Flash starts and stops the pen at 'D', so we will too.
-	 */
-
-	// D
-	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(x+width, y+height-ellipseHeight)));
-
-	// D -> E
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x+width, y+height-ellipseHeight+kappaH),
-	                        Vector2(x+width-ellipseWidth+kappaW, y+height),
-	                        Vector2(x+width-ellipseWidth, y+height)));
-
-	// E -> F
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+ellipseWidth, y+height)));
-
-	// F -> G
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x+ellipseWidth-kappaW, y+height),
-	                        Vector2(x, y+height-kappaH),
-	                        Vector2(x, y+height-ellipseHeight)));
-
-	// G -> H
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y+ellipseHeight)));
-
-	// H -> A
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x, y+ellipseHeight-kappaH),
-	                        Vector2(x+ellipseWidth-kappaW, y),
-	                        Vector2(x+ellipseWidth, y)));
-
-	// A -> B
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+width-ellipseWidth, y)));
-
-	// B -> C
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x+width-ellipseWidth+kappaW, y),
-	                        Vector2(x+width, y+kappaH),
-	                        Vector2(x+width, y+ellipseHeight)));
-
-	// C -> D
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+width, y+height-ellipseHeight)));
-
-	th->owner->owner->requestInvalidation(getSys());
-	
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,drawCircle)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==3);
-	th->checkAndSetScaling();
-
-	double x=args[0]->toNumber();
-	double y=args[1]->toNumber();
-	double radius=args[2]->toNumber();
-
-	double kappa = KAPPA*radius;
-
-	// right
-	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(x+radius, y)));
-
-	// bottom
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x+radius, y+kappa ),
-	                        Vector2(x+kappa , y+radius),
-	                        Vector2(x       , y+radius)));
-
-	// left
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x-kappa , y+radius),
-	                        Vector2(x-radius, y+kappa ),
-	                        Vector2(x-radius, y       )));
-
-	// top
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x-radius, y-kappa ),
-	                        Vector2(x-kappa , y-radius),
-	                        Vector2(x       , y-radius)));
-
-	// back to right
-	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
-	                        Vector2(x+kappa , y-radius),
-	                        Vector2(x+radius, y-kappa ),
-	                        Vector2(x+radius, y       )));
-
-	th->owner->owner->requestInvalidation(getSys());
-	
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,drawRect)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen==4);
-	th->checkAndSetScaling();
-
-	int x=args[0]->toInt();
-	int y=args[1]->toInt();
-	int width=args[2]->toInt();
-	int height=args[3]->toInt();
-
-	const Vector2 a(x,y);
-	const Vector2 b(x+width,y);
-	const Vector2 c(x+width,y+height);
-	const Vector2 d(x,y+height);
-
-	th->owner->tokens.emplace_back(GeomToken(MOVE, a));
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, b));
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, c));
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, d));
-	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, a));
-	th->owner->owner->requestInvalidation(getSys());
-	
-	return NULL;
-}
-
-/* Solve for c in the matrix equation
- *
- * [ 1 x1 y1 ] [ c[0] ]   [ u1 ]
- * [ 1 x2 y2 ] [ c[1] ] = [ u2 ]
- * [ 1 x3 y3 ] [ c[2] ]   [ u3 ]
- *
- * The result will be put in the output parameter c.
- */
-void Graphics::solveVertexMapping(double x1, double y1,
-				  double x2, double y2,
-				  double x3, double y3,
-				  double u1, double u2, double u3,
-				  double c[3])
-{
-	double eps = 1e-15;
-	double det = fabs(x2*y3 + x1*y2 + y1*x3 - y2*x3 - x1*y3 - y1*x2);
-
-	if (det < eps)
-	{
-		// Degenerate matrix
-		c[0] = c[1] = c[2] = 0;
-		return;
-	}
-
-	// Symbolic solution of the equation by Gaussian elimination
-	if (fabs(x1-x2) < eps)
-	{
-		c[2] = (u2-u1)/(y2-y1);
-		c[1] = (u3 - u1 - (y3-y1)*c[2])/(x3-x1);
-		c[0] = u1 - x1*c[1] - y1*c[2];
-	}
-	else
-	{
-		c[2] = ((x2-x1)*(u3-u1) - (x3-x1)*(u2-u1))/((y3-y1)*(x2-x1) - (x3-x1)*(y2-y1));
-		c[1] = (u2 - u1 - (y2-y1)*c[2])/(x2-x1);
-		c[0] = u1 - x1*c[1] - y1*c[2];
-	}
-}
-
-ASFUNCTIONBODY(Graphics,drawTriangles)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	_NR<Vector> vertices;
-	_NR<Vector> indices;
-	_NR<Vector> uvtData;
-	tiny_string culling;
-	ARG_UNPACK (vertices) (indices, NullRef) (uvtData, NullRef) (culling, "none");
-
-	if (culling != "none")
-		LOG(LOG_NOT_IMPLEMENTED, "Graphics.drawTriangles doesn't support culling");
-
-	// Validate the parameters
-	if ((indices.isNull() && (vertices->size() % 6 != 0)) || 
-	    (!indices.isNull() && (indices->size() % 3 != 0)))
-	{
-		throwError<ArgumentError>(kInvalidParamError);
-	}
-
-	unsigned int numvertices=vertices->size()/2;
-	unsigned int numtriangles;
-	bool has_uvt=false;
-	int uvtElemSize=2;
-	int texturewidth=0;
-	int textureheight=0;
-
-	if (indices.isNull())
-		numtriangles=numvertices/3;
-	else
-		numtriangles=indices->size()/3;
-
-	if (!uvtData.isNull())
-	{
-		if (uvtData->size()==2*numvertices)
-		{
-			has_uvt=true;
-			uvtElemSize=2; /* (u, v) */
-		}
-		else if (uvtData->size()==3*numvertices)
-		{
-			has_uvt=true;
-			uvtElemSize=3; /* (u, v, t), t is ignored */
-			LOG(LOG_NOT_IMPLEMENTED, "Graphics.drawTriangles doesn't support t in uvtData parameter");
-		}
-		else
-		{
-			throwError<ArgumentError>(kInvalidParamError);
-		}
-
-		th->owner->getTextureSize(&texturewidth, &textureheight);
-	}
-
-	// According to testing, drawTriangles first fills the current
-	// path and creates a new path, but keeps the source.
-	th->owner->tokens.emplace_back(FILL_KEEP_SOURCE);
-
-	if (has_uvt && (texturewidth==0 || textureheight==0))
-		return NULL;
-
-	// Construct the triangles
-	for (unsigned int i=0; i<numtriangles; i++)
-	{
-		double x[3], y[3], u[3]={0}, v[3]={0};
-		for (unsigned int j=0; j<3; j++)
-		{
-			unsigned int vertex;
-			if (indices.isNull())
-				vertex=3*i+j;
-			else
-				vertex=indices->at(3*i+j)->toInt();
-
-			x[j]=vertices->at(2*vertex)->toNumber();
-			y[j]=vertices->at(2*vertex+1)->toNumber();
-
-			if (has_uvt)
-			{
-				u[j]=uvtData->at(vertex*uvtElemSize)->toNumber()*texturewidth;
-				v[j]=uvtData->at(vertex*uvtElemSize+1)->toNumber()*textureheight;
-			}
-		}
-		
-		Vector2 a(x[0], y[0]);
-		Vector2 b(x[1], y[1]);
-		Vector2 c(x[2], y[2]);
-
-		th->owner->tokens.emplace_back(GeomToken(MOVE, a));
-		th->owner->tokens.emplace_back(GeomToken(STRAIGHT, b));
-		th->owner->tokens.emplace_back(GeomToken(STRAIGHT, c));
-		th->owner->tokens.emplace_back(GeomToken(STRAIGHT, a));
-
-		if (has_uvt)
-		{
-			double t[6];
-
-			// Use the known (x, y) and (u, v)
-			// correspondences to compute a transformation
-			// t from (x, y) space into (u, v) space
-			// (cairo needs the mapping in this
-			// direction).
-			//
-			// u = t[0] + t[1]*x + t[2]*y
-			// v = t[3] + t[4]*x + t[5]*y
-			//
-			// u and v parts can be solved separately.
-			th->solveVertexMapping(x[0], y[0], x[1], y[1], x[2], y[2],
-					       u[0], u[1], u[2], t);
-			th->solveVertexMapping(x[0], y[0], x[1], y[1], x[2], y[2],
-					       v[0], v[1], v[2], &t[3]);
-
-			MATRIX m(t[1], t[5], t[4], t[2], t[0], t[3]);
-			th->owner->tokens.emplace_back(GeomToken(FILL_TRANSFORM_TEXTURE, m));
-		}
-	}
-	
-	th->owner->owner->requestInvalidation(getSys());
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,lineStyle)
+ASFUNCTIONBODY(Stage,_getFrameRate)
 {
-	Graphics* th=static_cast<Graphics*>(obj);
-	th->checkAndSetScaling();
-
-	if (argslen == 0)
-	{
-		th->owner->tokens.emplace_back(CLEAR_STROKE);
-		return NULL;
-	}
-	uint32_t color = 0;
-	uint8_t alpha = 255;
-	UI16_SWF thickness = UI16_SWF(imax(args[0]->toNumber() * 20, 0));
-	if (argslen >= 2)
-		color = args[1]->toUInt();
-	if (argslen >= 3)
-		alpha = uint8_t(args[1]->toNumber() * 255);
-
-	// TODO: pixel hinting, scaling, caps, miter, joints
-	
-	LINESTYLE2 style(0xff);
-	style.Color = RGBA(color, alpha);
-	style.Width = thickness;
-	th->owner->tokens.emplace_back(GeomToken(SET_STROKE, style));
-	return NULL;
-}
-
-ASFUNCTIONBODY(Graphics,beginGradientFill)
-{
-	Graphics* th=static_cast<Graphics*>(obj);
-	assert_and_throw(argslen>=4);
-	th->checkAndSetScaling();
-
-	FILLSTYLE style(0xff);
-
-	assert_and_throw(args[1]->getObjectType()==T_ARRAY);
-	Array* colors=Class<Array>::cast(args[1]);
-
-	assert_and_throw(args[2]->getObjectType()==T_ARRAY);
-	Array* alphas=Class<Array>::cast(args[2]);
-
-	//assert_and_throw(args[3]->getObjectType()==T_ARRAY);
-	//Work around for bug in YouTube player of July 13 2011
-	if(args[3]->getObjectType()==T_UNDEFINED)
-		return NULL;
-	Array* ratios=Class<Array>::cast(args[3]);
-
-	int NumGradient = colors->size();
-	if (NumGradient != (int)alphas->size() || NumGradient != (int)ratios->size())
-		return NULL;
-
-	if (NumGradient < 1 || NumGradient > 15)
-		return NULL;
-
-	const tiny_string& type=args[0]->toString();
-
-	if(type == "linear")
-		style.FillStyleType=LINEAR_GRADIENT;
-	else if(type == "radial")
-		style.FillStyleType=RADIAL_GRADIENT;
+	Stage* th=obj->as<Stage>();
+	_NR<RootMovieClip> root = th->getRoot();
+	if (root.isNull())
+		return abstract_d(0.);
 	else
-		return NULL;
-
-	// Don't support FOCALGRADIENT for now.
-	GRADIENT grad(0xff);
-	for(int i = 0; i < NumGradient; i ++)
-	{
-		GRADRECORD record(0xff);
-		record.Color = RGBA(colors->at(i)->toUInt(), (int)alphas->at(i)->toNumber()*255);
-		record.Ratio = UI8(ratios->at(i)->toUInt());
-		grad.GradientRecords.push_back(record);
-	}
-
-	if(argslen > 4 && args[4]->getClass()==Class<Matrix>::getClass())
-	{
-		style.Matrix = static_cast<Matrix*>(args[4])->getMATRIX();
-		//Conversion from twips to pixels
-		cairo_matrix_scale(&style.Matrix, 1.0f/20.0f, 1.0f/20.0f);
-	}
-	else
-	{
-		cairo_matrix_scale(&style.Matrix, 100.0/16384.0, 100.0/16384.0);
-	}
-
-	if(argslen > 5)
-	{
-		const tiny_string& spread=args[5]->toString();
-		if (spread == "pad")
-			grad.SpreadMode = 0;
-		else if (spread == "reflect")
-			grad.SpreadMode = 1;
-		else if (spread == "repeat")
-			grad.SpreadMode = 2;
-	}
-	else
-	{
-		//default is pad
-		grad.SpreadMode = 0;
-	}
-
-
-	if(argslen > 6)
-	{
-		const tiny_string& interp=args[6]->toString();
-		if (interp == "rgb")
-			grad.InterpolationMode = 0;
-		else if (interp == "linearRGB")
-			grad.InterpolationMode = 1;
-	}
-	else
-	{
-		//default is rgb
-		grad.InterpolationMode = 0;
-	}
-
-	style.Gradient = grad;
-	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
-	return NULL;
+		return abstract_d(root->getFrameRate());
 }
 
-ASFUNCTIONBODY(Graphics,beginBitmapFill)
+ASFUNCTIONBODY(Stage,_setFrameRate)
 {
-	Graphics* th = obj->as<Graphics>();
-	_NR<BitmapData> bitmap;
-	_NR<Matrix> matrix;
-	bool repeat, smooth;
-	ARG_UNPACK (bitmap) (matrix, NullRef) (repeat, true) (smooth, false);
-
-	if(bitmap.isNull())
-		return NULL;
-
-	th->checkAndSetScaling();
-	FILLSTYLE style(0xff);
-	if(repeat && smooth)
-		style.FillStyleType = REPEATING_BITMAP;
-	else if(repeat && !smooth)
-		style.FillStyleType = NON_SMOOTHED_REPEATING_BITMAP;
-	else if(!repeat && smooth)
-		style.FillStyleType = CLIPPED_BITMAP;
-	else
-		style.FillStyleType = NON_SMOOTHED_CLIPPED_BITMAP;
-
-	if(!matrix.isNull())
-		style.Matrix = matrix->getMATRIX();
-
-	style.bitmap = bitmap->getBitmapContainer();
-	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
+	Stage* th=obj->as<Stage>();
+	number_t frameRate;
+	ARG_UNPACK(frameRate);
+	_NR<RootMovieClip> root = th->getRoot();
+	if (!root.isNull())
+		root->setFrameRate(frameRate);
 	return NULL;
 }
 
-ASFUNCTIONBODY(Graphics,beginFill)
+ASFUNCTIONBODY(Stage,_getAllowFullScreen)
 {
-	Graphics* th=static_cast<Graphics*>(obj);
-	th->checkAndSetScaling();
-	uint32_t color=0;
-	uint8_t alpha=255;
-	if(argslen>=1)
-		color=args[0]->toUInt();
-	if(argslen>=2)
-		alpha=(uint8_t(args[1]->toNumber()*0xff));
-	FILLSTYLE style(0xff);
-	style.FillStyleType = SOLID_FILL;
-	style.Color         = RGBA(color, alpha);
-	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
-	return NULL;
+	return abstract_b(false); // until fullscreen support is implemented
 }
 
-ASFUNCTIONBODY(Graphics,endFill)
+ASFUNCTIONBODY(Stage,_getAllowFullScreenInteractive)
 {
-	Graphics* th=static_cast<Graphics*>(obj);
-	th->checkAndSetScaling();
-	th->owner->tokens.emplace_back(CLEAR_FILL);
-	return NULL;
+	return abstract_b(false);
 }
 
-ASFUNCTIONBODY(Graphics,copyFrom)
+ASFUNCTIONBODY(Stage,_getColorCorrectionSupport)
 {
-	Graphics* th=static_cast<Graphics*>(obj);
-	_NR<Graphics> source;
-	ARG_UNPACK(source);
-	if (source.isNull())
-		return NULL;
-
-	th->owner->tokens.assign(source->owner->tokens.begin(),
-				 source->owner->tokens.end());
-	return NULL;
+	return abstract_b(false); // until color correction is implemented
 }
 
-void LineScaleMode::sinit(Class_base* c)
+ASFUNCTIONBODY(Stage,_getWmodeGPU)
 {
-	c->setConstructor(NULL);
-	c->setVariableByQName("HORIZONTAL","",Class<ASString>::getInstanceS("horizontal"),DECLARED_TRAIT);
-	c->setVariableByQName("NONE","",Class<ASString>::getInstanceS("none"),DECLARED_TRAIT);
-	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),DECLARED_TRAIT);
-	c->setVariableByQName("VERTICAL","",Class<ASString>::getInstanceS("vertical"),DECLARED_TRAIT);
+	return abstract_b(false);
 }
 
 void StageScaleMode::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("EXACT_FIT","",Class<ASString>::getInstanceS("exactFit"),DECLARED_TRAIT);
 	c->setVariableByQName("NO_BORDER","",Class<ASString>::getInstanceS("noBorder"),DECLARED_TRAIT);
 	c->setVariableByQName("NO_SCALE","",Class<ASString>::getInstanceS("noScale"),DECLARED_TRAIT);
@@ -2848,13 +2316,20 @@
 
 void StageAlign::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
+	c->setVariableByQName("BOTTOM","",Class<ASString>::getInstanceS("B"),DECLARED_TRAIT);
+	c->setVariableByQName("BOTTOM_LEFT","",Class<ASString>::getInstanceS("BL"),DECLARED_TRAIT);
+	c->setVariableByQName("BOTTOM_RIGHT","",Class<ASString>::getInstanceS("BR"),DECLARED_TRAIT);
+	c->setVariableByQName("LEFT","",Class<ASString>::getInstanceS("L"),DECLARED_TRAIT);
+	c->setVariableByQName("RIGHT","",Class<ASString>::getInstanceS("R"),DECLARED_TRAIT);
+	c->setVariableByQName("TOP","",Class<ASString>::getInstanceS("T"),DECLARED_TRAIT);
 	c->setVariableByQName("TOP_LEFT","",Class<ASString>::getInstanceS("TL"),DECLARED_TRAIT);
+	c->setVariableByQName("TOP_RIGHT","",Class<ASString>::getInstanceS("TR"),DECLARED_TRAIT);
 }
 
 void StageQuality::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("BEST","",Class<ASString>::getInstanceS("best"),DECLARED_TRAIT);
 	c->setVariableByQName("HIGH","",Class<ASString>::getInstanceS("high"),DECLARED_TRAIT);
 	c->setVariableByQName("LOW","",Class<ASString>::getInstanceS("low"),DECLARED_TRAIT);
@@ -2863,8 +2338,9 @@
 
 void StageDisplayState::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("FULL_SCREEN","",Class<ASString>::getInstanceS("fullScreen"),DECLARED_TRAIT);
+	c->setVariableByQName("FULL_SCREEN_INTERACTIVE","",Class<ASString>::getInstanceS("fullScreenInteractive"),DECLARED_TRAIT);
 	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),DECLARED_TRAIT);
 }
 
@@ -2934,8 +2410,7 @@
 
 void Bitmap::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	CLASS_SETUP(c, DisplayObject, _constructor, CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c,bitmapData);
 	REGISTER_GETTER_SETTER(c,smoothing);
 }
@@ -3027,8 +2502,7 @@
 
 void SimpleButton::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<InteractiveObject>::getRef());
+	CLASS_SETUP(c, InteractiveObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("upState","",Class<IFunction>::getFunction(_getUpState),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("upState","",Class<IFunction>::getFunction(_setUpState),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("downState","",Class<IFunction>::getFunction(_getDownState),GETTER_METHOD,true);
@@ -3039,6 +2513,8 @@
 	c->setDeclaredMethodByQName("hitTestState","",Class<IFunction>::getFunction(_setHitTestState),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("enabled","",Class<IFunction>::getFunction(_getEnabled),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("enabled","",Class<IFunction>::getFunction(_setEnabled),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("useHandCursor","",Class<IFunction>::getFunction(_getUseHandCursor),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("useHandCursor","",Class<IFunction>::getFunction(_setUseHandCursor),SETTER_METHOD,true);
 }
 
 void SimpleButton::buildTraits(ASObject* o)
@@ -3273,14 +2749,14 @@
 
 void GradientType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("LINEAR","",Class<ASString>::getInstanceS("linear"),DECLARED_TRAIT);
 	c->setVariableByQName("RADIAL","",Class<ASString>::getInstanceS("radial"),DECLARED_TRAIT);
 }
 
 void BlendMode::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("ADD","",Class<ASString>::getInstanceS("add"),DECLARED_TRAIT);
 	c->setVariableByQName("ALPHA","",Class<ASString>::getInstanceS("alpha"),DECLARED_TRAIT);
 	c->setVariableByQName("DARKEN","",Class<ASString>::getInstanceS("darken"),DECLARED_TRAIT);
@@ -3299,7 +2775,7 @@
 
 void SpreadMethod::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("PAD","",Class<ASString>::getInstanceS("pad"),DECLARED_TRAIT);
 	c->setVariableByQName("REFLECT","",Class<ASString>::getInstanceS("reflect"),DECLARED_TRAIT);
 	c->setVariableByQName("REPEAT","",Class<ASString>::getInstanceS("repeat"),DECLARED_TRAIT);
@@ -3307,11 +2783,30 @@
 
 void InterpolationMethod::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("RGB","",Class<ASString>::getInstanceS("rgb"),DECLARED_TRAIT);
 	c->setVariableByQName("LINEAR_RGB","",Class<ASString>::getInstanceS("linearRGB"),DECLARED_TRAIT);
 }
 
+void GraphicsPathCommand::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
+	c->setVariableByQName("CUBIC_CURVE_TO","",abstract_i(6),DECLARED_TRAIT);
+	c->setVariableByQName("CURVE_TO","",abstract_i(3),DECLARED_TRAIT);
+	c->setVariableByQName("LINE_TO","",abstract_i(2),DECLARED_TRAIT);
+	c->setVariableByQName("MOVE_TO","",abstract_i(1),DECLARED_TRAIT);
+	c->setVariableByQName("NO_OP","",abstract_i(0),DECLARED_TRAIT);
+	c->setVariableByQName("WIDE_LINE_TO","",abstract_i(5),DECLARED_TRAIT);
+	c->setVariableByQName("WIDE_MOVE_TO","",abstract_i(4),DECLARED_TRAIT);
+}
+
+void GraphicsPathWinding::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
+	c->setVariableByQName("EVEN_ODD","",Class<ASString>::getInstanceS("evenOdd"),DECLARED_TRAIT);
+	c->setVariableByQName("NON_ZERO","",Class<ASString>::getInstanceS("nonZero"),DECLARED_TRAIT);
+}
+
 /* Go through the hierarchy and add all
  * legacy objects which are new in the current
  * frame top-down. At the same time, call their
@@ -3456,8 +2951,7 @@
 
 void AVM1Movie::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	CLASS_SETUP(c, DisplayObject, _constructor, CLASS_SEALED);
 }
 
 void AVM1Movie::buildTraits(ASObject* o)
@@ -3473,8 +2967,7 @@
 
 void Shader::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 }
 
 ASFUNCTIONBODY(Shader,_constructor)
@@ -3485,8 +2978,7 @@
 
 void BitmapDataChannel::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("ALPHA","",abstract_ui(8),DECLARED_TRAIT);
 	c->setVariableByQName("BLUE","",abstract_ui(4),DECLARED_TRAIT);
 	c->setVariableByQName("GREEN","",abstract_ui(2),DECLARED_TRAIT);
@@ -3515,3 +3007,12 @@
 
 	return shift;
 }
+
+void LineScaleMode::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
+	c->setVariableByQName("HORIZONTAL","",Class<ASString>::getInstanceS("horizontal"),DECLARED_TRAIT);
+	c->setVariableByQName("NONE","",Class<ASString>::getInstanceS("none"),DECLARED_TRAIT);
+	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),DECLARED_TRAIT);
+	c->setVariableByQName("VERTICAL","",Class<ASString>::getInstanceS("vertical"),DECLARED_TRAIT);
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/flashdisplay.h lightspark-0.7.2/src/scripting/flash/display/flashdisplay.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/flashdisplay.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/flashdisplay.h	2013-11-09 19:23:31.000000000 +0200
@@ -43,6 +43,10 @@
 class ApplicationDomain;
 class SecurityDomain;
 class BitmapData;
+class Matrix;
+class Vector;
+class Graphics;
+class Rectangle;
 
 class InteractiveObject: public DisplayObject
 {
@@ -171,55 +175,6 @@
 	ASFUNCTION(_setUseHandCursor);
 };
 
-/* This objects paints to its owners tokens */
-class Graphics: public ASObject
-{
-private:
-	int curX, curY;
-	TokenContainer *const owner;
-	//TODO: Add spinlock
-	void checkAndSetScaling()
-	{
-		if(owner->scaling != 1.0f)
-		{
-			owner->scaling = 1.0f;
-			owner->tokens.clear();
-			assert(curX == 0 && curY == 0);
-		}
-	}
-	static void solveVertexMapping(double x1, double y1,
-				       double x2, double y2,
-				       double x3, double y3,
-				       double u1, double u2, double u3,
-				       double c[3]);
-public:
-	Graphics(Class_base* c):ASObject(c),curX(0),curY(0),owner(NULL)
-	{
-		throw RunTimeException("Cannot instantiate a Graphics object");
-	}
-	Graphics(Class_base* c, TokenContainer* _o)
-		: ASObject(c),curX(0),curY(0),owner(_o) {}
-	static void sinit(Class_base* c);
-	static void buildTraits(ASObject* o);
-	ASFUNCTION(_constructor);
-	ASFUNCTION(lineStyle);
-	ASFUNCTION(beginFill);
-	ASFUNCTION(beginGradientFill);
-	ASFUNCTION(beginBitmapFill);
-	ASFUNCTION(endFill);
-	ASFUNCTION(drawRect);
-	ASFUNCTION(drawRoundRect);
-	ASFUNCTION(drawCircle);
-	ASFUNCTION(drawTriangles);
-	ASFUNCTION(moveTo);
-	ASFUNCTION(lineTo);
-	ASFUNCTION(curveTo);
-	ASFUNCTION(cubicCurveTo);
-	ASFUNCTION(clear);
-	ASFUNCTION(copyFrom);
-};
-
-
 class Shape: public DisplayObject, public TokenContainer
 {
 protected:
@@ -253,7 +208,6 @@
 	MorphShape(Class_base* c):DisplayObject(c){}
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
-	ASFUNCTION(_constructor);
 };
 
 class Loader;
@@ -318,6 +272,7 @@
 	void setBytesLoaded(uint32_t b);
 	void setURL(const tiny_string& _url, bool setParameters=true);
 	void setLoaderURL(const tiny_string& _url) { loaderURL=_url; }
+	void setParameters(_NR<ASObject> p) { parameters = p; }
 	void resetState();
 };
 
@@ -349,6 +304,7 @@
 	_NR<LoaderInfo> contentLoaderInfo;
 	void unload();
 	bool loaded;
+	bool allowCodeImport;
 public:
 	Loader(Class_base* c);
 	~Loader();
@@ -370,6 +326,7 @@
 	void setContent(_R<DisplayObject> o);
 	_NR<DisplayObject> getContent() { return content; }
 	_R<LoaderInfo> getContentLoaderInfo() { return contentLoaderInfo; }
+	bool allowLoadingSWF() { return allowCodeImport; };
 };
 
 class Sprite: public DisplayObjectContainer, public TokenContainer
@@ -550,6 +507,9 @@
 	uint32_t internalGetHeight() const;
 	uint32_t internalGetWidth() const;
 	void onDisplayState(const tiny_string&);
+	void onAlign(const tiny_string&);
+	void onColorCorrection(const tiny_string&);
+	void onFullScreenSourceRect(_NR<Rectangle>);
 	// Keyboard focus object is accessed from the VM thread (AS
 	// code) and the input thread and is protected focusSpinlock
 	Spinlock focusSpinlock;
@@ -564,6 +524,9 @@
 	_NR<InteractiveObject> getFocusTarget();
 	void setFocusTarget(_NR<InteractiveObject> focus);
 	ASFUNCTION(_constructor);
+	ASFUNCTION(_getAllowFullScreen);
+	ASFUNCTION(_getAllowFullScreenInteractive);
+	ASFUNCTION(_getColorCorrectionSupport);
 	ASFUNCTION(_getStageWidth);
 	ASFUNCTION(_getStageHeight);
 	ASFUNCTION(_getScaleMode);
@@ -573,7 +536,15 @@
 	ASFUNCTION(_getFocus);
 	ASFUNCTION(_setFocus);
 	ASFUNCTION(_setTabChildren);
+	ASFUNCTION(_getFrameRate);
+	ASFUNCTION(_setFrameRate);
+	ASFUNCTION(_getWmodeGPU);
+	ASPROPERTY_GETTER_SETTER(tiny_string,align);
+	ASPROPERTY_GETTER_SETTER(tiny_string,colorCorrection);
 	ASPROPERTY_GETTER_SETTER(tiny_string,displayState);
+	ASPROPERTY_GETTER_SETTER(_NR<Rectangle>,fullScreenSourceRect);
+	ASPROPERTY_GETTER_SETTER(bool,showDefaultContextMenu);
+	ASPROPERTY_GETTER_SETTER(tiny_string,quality);
 };
 
 class StageScaleMode: public ASObject
@@ -645,6 +616,22 @@
 	static void sinit(Class_base* c);
 };
 
+class GraphicsPathCommand: public ASObject
+{
+public:
+	enum {NO_OP=0, MOVE_TO, LINE_TO, CURVE_TO, WIDE_MOVE_TO, WIDE_LINE_TO, CUBIC_CURVE_TO};
+	GraphicsPathCommand(Class_base* c):ASObject(c){}
+	static void sinit(Class_base* c);
+};
+
+class GraphicsPathWinding: public ASObject
+{
+public:
+	GraphicsPathWinding(Class_base* c):ASObject(c){}
+	static void sinit(Class_base* c);
+
+};
+
 class IntSize
 {
 public:
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsBitmapFill.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsBitmapFill.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsBitmapFill.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsBitmapFill.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,70 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsBitmapFill.h"
+#include "scripting/flash/display/BitmapData.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/flash/geom/flashgeom.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+
+using namespace lightspark;
+
+GraphicsBitmapFill::GraphicsBitmapFill(Class_base* c):
+	ASObject(c), repeat(true), smooth(false)
+{
+}
+
+void GraphicsBitmapFill::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, bitmapData);
+	REGISTER_GETTER_SETTER(c, matrix);
+	REGISTER_GETTER_SETTER(c, repeat);
+	REGISTER_GETTER_SETTER(c, smooth);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsFill>::getClass());
+	IGraphicsFill::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+ASFUNCTIONBODY(GraphicsBitmapFill, _constructor)
+{
+	GraphicsBitmapFill* th = obj->as<GraphicsBitmapFill>();
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->bitmapData, NullRef) (th->matrix, NullRef) (th->repeat, true) (th->smooth, false);
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsBitmapFill, bitmapData);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsBitmapFill, matrix);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsBitmapFill, repeat);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsBitmapFill, smooth);
+
+FILLSTYLE GraphicsBitmapFill::toFillStyle()
+{
+	return Graphics::createBitmapFill(bitmapData, matrix, repeat, smooth);
+}
+
+void GraphicsBitmapFill::appendToTokens(std::vector<GeomToken>& tokens)
+{
+
+	tokens.emplace_back(GeomToken(SET_FILL, toFillStyle()));
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsBitmapFill.h lightspark-0.7.2/src/scripting/flash/display/GraphicsBitmapFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsBitmapFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsBitmapFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,49 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSBITMAPFILL_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSBITMAPFILL_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class BitmapData;
+class Matrix;
+
+class GraphicsBitmapFill: public ASObject, public IGraphicsFill, public IGraphicsData
+{
+public:
+	GraphicsBitmapFill(Class_base* c);
+	static void sinit(Class_base* c);
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(_NR<BitmapData>, bitmapData);
+	ASPROPERTY_GETTER_SETTER(_NR<Matrix>, matrix);
+	ASPROPERTY_GETTER_SETTER(bool, repeat);
+	ASPROPERTY_GETTER_SETTER(bool, smooth);
+	FILLSTYLE toFillStyle();
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSBITMAPFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/Graphics.cpp lightspark-0.7.2/src/scripting/flash/display/Graphics.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/Graphics.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/Graphics.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,923 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/flash/display/TokenContainer.h"
+#include "scripting/flash/display/BitmapData.h"
+#include "scripting/flash/display/flashdisplay.h"
+#include "scripting/flash/display/IGraphicsData.h"
+#include "scripting/toplevel/Array.h"
+#include "scripting/toplevel/Vector.h"
+#include "scripting/toplevel/Number.h"
+#include "scripting/toplevel/ASString.h"
+#include "scripting/flash/geom/flashgeom.h"
+#include "scripting/argconv.h"
+#include "swf.h"
+
+using namespace std;
+using namespace lightspark;
+
+void Graphics::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	c->setDeclaredMethodByQName("clear","",Class<IFunction>::getFunction(clear),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("copyFrom","",Class<IFunction>::getFunction(copyFrom),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawRect","",Class<IFunction>::getFunction(drawRect),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawRoundRect","",Class<IFunction>::getFunction(drawRoundRect),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawCircle","",Class<IFunction>::getFunction(drawCircle),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawEllipse","",Class<IFunction>::getFunction(drawEllipse),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawPath","",Class<IFunction>::getFunction(drawPath),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawTriangles","",Class<IFunction>::getFunction(drawTriangles),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("drawGraphicsData","",Class<IFunction>::getFunction(drawGraphicsData),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("moveTo","",Class<IFunction>::getFunction(moveTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("curveTo","",Class<IFunction>::getFunction(curveTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("cubicCurveTo","",Class<IFunction>::getFunction(cubicCurveTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lineTo","",Class<IFunction>::getFunction(lineTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lineBitmapStyle","",Class<IFunction>::getFunction(lineBitmapStyle),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lineGradientStyle","",Class<IFunction>::getFunction(lineGradientStyle),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lineStyle","",Class<IFunction>::getFunction(lineStyle),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("beginFill","",Class<IFunction>::getFunction(beginFill),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("beginGradientFill","",Class<IFunction>::getFunction(beginGradientFill),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("beginBitmapFill","",Class<IFunction>::getFunction(beginBitmapFill),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("endFill","",Class<IFunction>::getFunction(endFill),NORMAL_METHOD,true);
+}
+
+void Graphics::buildTraits(ASObject* o)
+{
+}
+
+//TODO: Add spinlock
+void Graphics::checkAndSetScaling()
+{
+	if(owner->scaling != 1.0f)
+	{
+		owner->scaling = 1.0f;
+		owner->tokens.clear();
+	}
+}
+
+ASFUNCTIONBODY(Graphics,_constructor)
+{
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,clear)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+	th->owner->tokens.clear();
+	th->owner->owner->requestInvalidation(getSys());
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,moveTo)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+	assert_and_throw(argslen==2);
+
+	int32_t x=args[0]->toInt();
+	int32_t y=args[1]->toInt();
+
+	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(x, y)));
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,lineTo)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==2);
+	th->checkAndSetScaling();
+
+	int x=args[0]->toInt();
+	int y=args[1]->toInt();
+
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y)));
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,curveTo)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==4);
+	th->checkAndSetScaling();
+
+	int controlX=args[0]->toInt();
+	int controlY=args[1]->toInt();
+
+	int anchorX=args[2]->toInt();
+	int anchorY=args[3]->toInt();
+
+	th->owner->tokens.emplace_back(GeomToken(CURVE_QUADRATIC,
+	                        Vector2(controlX, controlY),
+	                        Vector2(anchorX, anchorY)));
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,cubicCurveTo)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==6);
+	th->checkAndSetScaling();
+
+	int control1X=args[0]->toInt();
+	int control1Y=args[1]->toInt();
+
+	int control2X=args[2]->toInt();
+	int control2Y=args[3]->toInt();
+
+	int anchorX=args[4]->toInt();
+	int anchorY=args[5]->toInt();
+
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(control1X, control1Y),
+	                        Vector2(control2X, control2Y),
+	                        Vector2(anchorX, anchorY)));
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+/* KAPPA = 4 * (sqrt2 - 1) / 3
+ * This value was found in a Python prompt:
+ *
+ * >>> 4.0 * (2**0.5 - 1) / 3.0
+ *
+ * Source: http://whizkidtech.redprince.net/bezier/circle/
+ */
+const double KAPPA = 0.55228474983079356;
+
+ASFUNCTIONBODY(Graphics,drawRoundRect)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==5 || argslen==6);
+	th->checkAndSetScaling();
+
+	double x=args[0]->toNumber();
+	double y=args[1]->toNumber();
+	double width=args[2]->toNumber();
+	double height=args[3]->toNumber();
+	double ellipseWidth=args[4]->toNumber();
+	double ellipseHeight;
+	if (argslen == 6)
+		ellipseHeight=args[5]->toNumber();
+
+	if (argslen == 5 || std::isnan(ellipseHeight))
+		ellipseHeight=ellipseWidth;
+
+	ellipseHeight /= 2;
+	ellipseWidth  /= 2;
+
+	double kappaW = KAPPA * ellipseWidth;
+	double kappaH = KAPPA * ellipseHeight;
+
+	/*
+	 *    A-----B
+	 *   /       \
+	 *  H         C
+	 *  |         |
+	 *  G         D
+	 *   \       /
+	 *    F-----E
+	 * 
+	 * Flash starts and stops the pen at 'D', so we will too.
+	 */
+
+	// D
+	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(x+width, y+height-ellipseHeight)));
+
+	// D -> E
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x+width, y+height-ellipseHeight+kappaH),
+	                        Vector2(x+width-ellipseWidth+kappaW, y+height),
+	                        Vector2(x+width-ellipseWidth, y+height)));
+
+	// E -> F
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+ellipseWidth, y+height)));
+
+	// F -> G
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x+ellipseWidth-kappaW, y+height),
+	                        Vector2(x, y+height-kappaH),
+	                        Vector2(x, y+height-ellipseHeight)));
+
+	// G -> H
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y+ellipseHeight)));
+
+	// H -> A
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x, y+ellipseHeight-kappaH),
+	                        Vector2(x+ellipseWidth-kappaW, y),
+	                        Vector2(x+ellipseWidth, y)));
+
+	// A -> B
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+width-ellipseWidth, y)));
+
+	// B -> C
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x+width-ellipseWidth+kappaW, y),
+	                        Vector2(x+width, y+kappaH),
+	                        Vector2(x+width, y+ellipseHeight)));
+
+	// C -> D
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x+width, y+height-ellipseHeight)));
+
+	th->owner->owner->requestInvalidation(getSys());
+	
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,drawCircle)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==3);
+	th->checkAndSetScaling();
+
+	double x=args[0]->toNumber();
+	double y=args[1]->toNumber();
+	double radius=args[2]->toNumber();
+
+	double kappa = KAPPA*radius;
+
+	// right
+	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(x+radius, y)));
+
+	// bottom
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x+radius, y+kappa ),
+	                        Vector2(x+kappa , y+radius),
+	                        Vector2(x       , y+radius)));
+
+	// left
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x-kappa , y+radius),
+	                        Vector2(x-radius, y+kappa ),
+	                        Vector2(x-radius, y       )));
+
+	// top
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x-radius, y-kappa ),
+	                        Vector2(x-kappa , y-radius),
+	                        Vector2(x       , y-radius)));
+
+	// back to right
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(x+kappa , y-radius),
+	                        Vector2(x+radius, y-kappa ),
+	                        Vector2(x+radius, y       )));
+
+	th->owner->owner->requestInvalidation(getSys());
+	
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,drawEllipse)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==4);
+	th->checkAndSetScaling();
+
+	double left=args[0]->toNumber();
+	double top=args[1]->toNumber();
+	double width=args[2]->toNumber();
+	double height=args[3]->toNumber();
+
+	double xkappa = KAPPA*width/2;
+	double ykappa = KAPPA*height/2;
+
+	// right
+	th->owner->tokens.emplace_back(GeomToken(MOVE, Vector2(left+width, top+height/2)));
+	
+	// bottom
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(left+width , top+height/2+ykappa),
+	                        Vector2(left+width/2+xkappa, top+height),
+	                        Vector2(left+width/2, top+height)));
+
+	// left
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(left+width/2-xkappa, top+height),
+	                        Vector2(left, top+height/2+ykappa),
+	                        Vector2(left, top+height/2)));
+
+	// top
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(left, top+height/2-ykappa),
+	                        Vector2(left+width/2-xkappa, top),
+	                        Vector2(left+width/2, top)));
+
+	// back to right
+	th->owner->tokens.emplace_back(GeomToken(CURVE_CUBIC,
+	                        Vector2(left+width/2+xkappa, top),
+	                        Vector2(left+width, top+height/2-ykappa),
+	                        Vector2(left+width, top+height/2)));
+
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,drawRect)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	assert_and_throw(argslen==4);
+	th->checkAndSetScaling();
+
+	int x=args[0]->toInt();
+	int y=args[1]->toInt();
+	int width=args[2]->toInt();
+	int height=args[3]->toInt();
+
+	const Vector2 a(x,y);
+	const Vector2 b(x+width,y);
+	const Vector2 c(x+width,y+height);
+	const Vector2 d(x,y+height);
+
+	th->owner->tokens.emplace_back(GeomToken(MOVE, a));
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, b));
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, c));
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, d));
+	th->owner->tokens.emplace_back(GeomToken(STRAIGHT, a));
+	th->owner->owner->requestInvalidation(getSys());
+	
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,drawPath)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	_NR<Vector> commands;
+	_NR<Vector> data;
+	tiny_string winding;
+	ARG_UNPACK (commands) (data) (winding, "evenOdd");
+
+	if (commands.isNull() || data.isNull())
+		throwError<ArgumentError>(kInvalidParamError);
+
+	pathToTokens(commands, data, winding, th->owner->tokens);
+
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+void Graphics::pathToTokens(_NR<Vector> commands, _NR<Vector> data,
+			    tiny_string winding, std::vector<GeomToken>& tokens)
+{
+	if (commands.isNull() || data.isNull())
+		return;
+
+	if (winding != "evenOdd")
+		LOG(LOG_NOT_IMPLEMENTED, "Only event-odd winding implemented in Graphics.drawPath");
+
+	_R<Number> zeroRef = _MR(Class<Number>::getInstanceS(0));
+	Number *zero = zeroRef.getPtr();
+
+	int k = 0;
+	for (unsigned int i=0; i<commands->size(); i++)
+	{
+		switch (commands->at(i)->toInt())
+		{
+			case GraphicsPathCommand::MOVE_TO:
+			{
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(MOVE, Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::LINE_TO:
+			{
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::CURVE_TO:
+			{
+				number_t cx = data->at(k++, zero)->toNumber();
+				number_t cy = data->at(k++, zero)->toNumber();
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(CURVE_QUADRATIC,
+							      Vector2(cx, cy),
+							      Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::WIDE_MOVE_TO:
+			{
+				k+=2;
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(MOVE, Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::WIDE_LINE_TO:
+			{
+				k+=2;
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(STRAIGHT, Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::CUBIC_CURVE_TO:
+			{
+				number_t c1x = data->at(k++, zero)->toNumber();
+				number_t c1y = data->at(k++, zero)->toNumber();
+				number_t c2x = data->at(k++, zero)->toNumber();
+				number_t c2y = data->at(k++, zero)->toNumber();
+				number_t x = data->at(k++, zero)->toNumber();
+				number_t y = data->at(k++, zero)->toNumber();
+				tokens.emplace_back(GeomToken(CURVE_CUBIC,
+							      Vector2(c1x, c1y),
+							      Vector2(c2x, c2y),
+							      Vector2(x, y)));
+				break;
+			}
+
+			case GraphicsPathCommand::NO_OP:
+			default:
+				break;
+		}
+	}
+}
+
+/* Solve for c in the matrix equation
+ *
+ * [ 1 x1 y1 ] [ c[0] ]   [ u1 ]
+ * [ 1 x2 y2 ] [ c[1] ] = [ u2 ]
+ * [ 1 x3 y3 ] [ c[2] ]   [ u3 ]
+ *
+ * The result will be put in the output parameter c.
+ */
+void Graphics::solveVertexMapping(double x1, double y1,
+				  double x2, double y2,
+				  double x3, double y3,
+				  double u1, double u2, double u3,
+				  double c[3])
+{
+	double eps = 1e-15;
+	double det = fabs(x2*y3 + x1*y2 + y1*x3 - y2*x3 - x1*y3 - y1*x2);
+
+	if (det < eps)
+	{
+		// Degenerate matrix
+		c[0] = c[1] = c[2] = 0;
+		return;
+	}
+
+	// Symbolic solution of the equation by Gaussian elimination
+	if (fabs(x1-x2) < eps)
+	{
+		c[2] = (u2-u1)/(y2-y1);
+		c[1] = (u3 - u1 - (y3-y1)*c[2])/(x3-x1);
+		c[0] = u1 - x1*c[1] - y1*c[2];
+	}
+	else
+	{
+		c[2] = ((x2-x1)*(u3-u1) - (x3-x1)*(u2-u1))/((y3-y1)*(x2-x1) - (x3-x1)*(y2-y1));
+		c[1] = (u2 - u1 - (y2-y1)*c[2])/(x2-x1);
+		c[0] = u1 - x1*c[1] - y1*c[2];
+	}
+}
+
+ASFUNCTIONBODY(Graphics,drawTriangles)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	_NR<Vector> vertices;
+	_NR<Vector> indices;
+	_NR<Vector> uvtData;
+	tiny_string culling;
+	ARG_UNPACK (vertices) (indices, NullRef) (uvtData, NullRef) (culling, "none");
+
+	drawTrianglesToTokens(vertices, indices, uvtData, culling, th->owner->tokens);
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+void Graphics::drawTrianglesToTokens(_NR<Vector> vertices, _NR<Vector> indices, _NR<Vector> uvtData, tiny_string culling, std::vector<GeomToken>& tokens)
+{
+	if (culling != "none")
+		LOG(LOG_NOT_IMPLEMENTED, "Graphics.drawTriangles doesn't support culling");
+
+	// Validate the parameters
+	if (vertices.isNull())
+		return;
+
+	if ((indices.isNull() && (vertices->size() % 6 != 0)) || 
+	    (!indices.isNull() && (indices->size() % 3 != 0)))
+	{
+		throwError<ArgumentError>(kInvalidParamError);
+	}
+
+	unsigned int numvertices=vertices->size()/2;
+	unsigned int numtriangles;
+	bool has_uvt=false;
+	int uvtElemSize=2;
+	int texturewidth=0;
+	int textureheight=0;
+
+	if (indices.isNull())
+		numtriangles=numvertices/3;
+	else
+		numtriangles=indices->size()/3;
+
+	if (!uvtData.isNull())
+	{
+		if (uvtData->size()==2*numvertices)
+		{
+			has_uvt=true;
+			uvtElemSize=2; /* (u, v) */
+		}
+		else if (uvtData->size()==3*numvertices)
+		{
+			has_uvt=true;
+			uvtElemSize=3; /* (u, v, t), t is ignored */
+			LOG(LOG_NOT_IMPLEMENTED, "Graphics.drawTriangles doesn't support t in uvtData parameter");
+		}
+		else
+		{
+			throwError<ArgumentError>(kInvalidParamError);
+		}
+
+		TokenContainer::getTextureSize(tokens, &texturewidth, &textureheight);
+	}
+
+	// According to testing, drawTriangles first fills the current
+	// path and creates a new path, but keeps the source.
+	tokens.emplace_back(FILL_KEEP_SOURCE);
+
+	if (has_uvt && (texturewidth==0 || textureheight==0))
+		return;
+
+	// Construct the triangles
+	for (unsigned int i=0; i<numtriangles; i++)
+	{
+		double x[3], y[3], u[3]={0}, v[3]={0};
+		for (unsigned int j=0; j<3; j++)
+		{
+			unsigned int vertex;
+			if (indices.isNull())
+				vertex=3*i+j;
+			else
+				vertex=indices->at(3*i+j)->toInt();
+
+			x[j]=vertices->at(2*vertex)->toNumber();
+			y[j]=vertices->at(2*vertex+1)->toNumber();
+
+			if (has_uvt)
+			{
+				u[j]=uvtData->at(vertex*uvtElemSize)->toNumber()*texturewidth;
+				v[j]=uvtData->at(vertex*uvtElemSize+1)->toNumber()*textureheight;
+			}
+		}
+		
+		Vector2 a(x[0], y[0]);
+		Vector2 b(x[1], y[1]);
+		Vector2 c(x[2], y[2]);
+
+		tokens.emplace_back(GeomToken(MOVE, a));
+		tokens.emplace_back(GeomToken(STRAIGHT, b));
+		tokens.emplace_back(GeomToken(STRAIGHT, c));
+		tokens.emplace_back(GeomToken(STRAIGHT, a));
+
+		if (has_uvt)
+		{
+			double t[6];
+
+			// Use the known (x, y) and (u, v)
+			// correspondences to compute a transformation
+			// t from (x, y) space into (u, v) space
+			// (cairo needs the mapping in this
+			// direction).
+			//
+			// u = t[0] + t[1]*x + t[2]*y
+			// v = t[3] + t[4]*x + t[5]*y
+			//
+			// u and v parts can be solved separately.
+			solveVertexMapping(x[0], y[0], x[1], y[1], x[2], y[2],
+					   u[0], u[1], u[2], t);
+			solveVertexMapping(x[0], y[0], x[1], y[1], x[2], y[2],
+					   v[0], v[1], v[2], &t[3]);
+
+			MATRIX m(t[1], t[5], t[4], t[2], t[0], t[3]);
+			tokens.emplace_back(GeomToken(FILL_TRANSFORM_TEXTURE, m));
+		}
+	}
+}
+
+ASFUNCTIONBODY(Graphics,drawGraphicsData)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	_NR<Vector> graphicsData;
+	ARG_UNPACK(graphicsData);
+
+	for (unsigned int i=0; i<graphicsData->size(); i++)
+	{
+		IGraphicsData *graphElement = dynamic_cast<IGraphicsData *>(graphicsData->at(i));
+		if (!graphElement)
+		{
+			LOG(LOG_ERROR, "Invalid type in Graphics::drawGraphicsData()");
+			continue;
+		}
+
+		graphElement->appendToTokens(th->owner->tokens);
+	}
+
+	th->owner->owner->requestInvalidation(getSys());
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,lineStyle)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	if (argslen == 0)
+	{
+		th->owner->tokens.emplace_back(CLEAR_STROKE);
+		return NULL;
+	}
+	uint32_t color = 0;
+	uint8_t alpha = 255;
+	UI16_SWF thickness = UI16_SWF(imax(args[0]->toNumber() * 20, 0));
+	if (argslen >= 2)
+		color = args[1]->toUInt();
+	if (argslen >= 3)
+		alpha = uint8_t(args[1]->toNumber() * 255);
+
+	// TODO: pixel hinting, scaling, caps, miter, joints
+	
+	LINESTYLE2 style(0xff);
+	style.Color = RGBA(color, alpha);
+	style.Width = thickness;
+	th->owner->tokens.emplace_back(GeomToken(SET_STROKE, style));
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,lineBitmapStyle)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	_NR<BitmapData> bitmap;
+	_NR<Matrix> matrix;
+	bool repeat, smooth;
+	ARG_UNPACK (bitmap) (matrix, NullRef) (repeat, true) (smooth, false);
+
+	if (bitmap.isNull())
+		return NULL;
+
+	LINESTYLE2 style(0xff);
+	style.Width = th->owner->getCurrentLineWidth();
+	style.HasFillFlag = true;
+	style.FillType = createBitmapFill(bitmap, matrix, repeat, smooth);
+	
+	th->owner->tokens.emplace_back(GeomToken(SET_STROKE, style));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,lineGradientStyle)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	tiny_string type;
+	_NR<Array> colors;
+	_NR<Array> alphas;
+	_NR<Array> ratios;
+	_NR<Matrix> matrix;
+	tiny_string spreadMethod;
+	tiny_string interpolationMethod;
+	number_t focalPointRatio;
+	ARG_UNPACK (type) (colors) (alphas) (ratios) (matrix, NullRef)
+		(spreadMethod, "pad") (interpolationMethod, "rgb") (focalPointRatio, 0);
+
+	LINESTYLE2 style(0xff);
+	style.Width = th->owner->getCurrentLineWidth();
+	style.HasFillFlag = true;
+	style.FillType = createGradientFill(type, colors, alphas, ratios, matrix,
+					    spreadMethod, interpolationMethod,
+					    focalPointRatio);
+
+	th->owner->tokens.emplace_back(GeomToken(SET_STROKE, style));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,beginGradientFill)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+
+	tiny_string type;
+	_NR<Array> colors;
+	_NR<Array> alphas;
+	_NR<ASObject> ratiosParam;
+	_NR<Matrix> matrix;
+	tiny_string spreadMethod;
+	tiny_string interpolationMethod;
+	number_t focalPointRatio;
+	ARG_UNPACK (type) (colors) (alphas) (ratiosParam) (matrix, NullRef)
+		(spreadMethod, "pad") (interpolationMethod, "rgb") (focalPointRatio, 0);
+
+	//Work around for bug in YouTube player of July 13 2011
+	if (!ratiosParam->is<Array>())
+		return NULL;
+	if (ratiosParam.isNull())
+		return NULL;
+
+	ratiosParam->incRef();
+	_NR<Array> ratios = _MNR(ratiosParam->as<Array>());
+
+	FILLSTYLE style = createGradientFill(type, colors, alphas, ratios, matrix,
+					     spreadMethod, interpolationMethod,
+					     focalPointRatio);
+	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
+
+	return NULL;
+}
+
+FILLSTYLE Graphics::createGradientFill(const tiny_string& type,
+				       _NR<Array> colors,
+				       _NR<Array> alphas,
+				       _NR<Array> ratios,
+				       _NR<Matrix> matrix,
+				       const tiny_string& spreadMethod,
+				       const tiny_string& interpolationMethod,
+				       number_t focalPointRatio)
+{
+	FILLSTYLE style(0xff);
+
+	if (colors.isNull() || alphas.isNull() || ratios.isNull())
+		return style;
+
+	int NumGradient = colors->size();
+	if (NumGradient != (int)alphas->size() || NumGradient != (int)ratios->size())
+		return style;
+
+	if (NumGradient < 1 || NumGradient > 15)
+		return style;
+
+	if(type == "linear")
+		style.FillStyleType=LINEAR_GRADIENT;
+	else if(type == "radial")
+		style.FillStyleType=RADIAL_GRADIENT;
+	else
+		return style;
+
+	// Don't support FOCALGRADIENT for now.
+	GRADIENT grad(0xff);
+	for(int i = 0; i < NumGradient; i ++)
+	{
+		GRADRECORD record(0xff);
+		record.Color = RGBA(colors->at(i)->toUInt(), (int)alphas->at(i)->toNumber()*255);
+		record.Ratio = UI8(ratios->at(i)->toUInt());
+		grad.GradientRecords.push_back(record);
+	}
+
+	if(matrix.isNull())
+	{
+		cairo_matrix_scale(&style.Matrix, 100.0/16384.0, 100.0/16384.0);
+	}
+	else
+	{
+		style.Matrix = matrix->getMATRIX();
+		//Conversion from twips to pixels
+		cairo_matrix_scale(&style.Matrix, 1.0f/20.0f, 1.0f/20.0f);
+	}
+
+	if (spreadMethod == "pad")
+		grad.SpreadMode = 0;
+	else if (spreadMethod == "reflect")
+		grad.SpreadMode = 1;
+	else if (spreadMethod == "repeat")
+		grad.SpreadMode = 2;
+	else
+		grad.SpreadMode = 0; // should not be reached
+
+	if (interpolationMethod == "rgb")
+		grad.InterpolationMode = 0;
+	else if (interpolationMethod == "linearRGB")
+		grad.InterpolationMode = 1;
+	else
+		grad.InterpolationMode = 0; // should not be reached
+
+	style.Gradient = grad;
+	return style;
+}
+
+FILLSTYLE Graphics::createBitmapFill(_R<BitmapData> bitmap, _NR<Matrix> matrix, bool repeat, bool smooth)
+{
+	FILLSTYLE style(0xff);
+	if(repeat && smooth)
+		style.FillStyleType = REPEATING_BITMAP;
+	else if(repeat && !smooth)
+		style.FillStyleType = NON_SMOOTHED_REPEATING_BITMAP;
+	else if(!repeat && smooth)
+		style.FillStyleType = CLIPPED_BITMAP;
+	else
+		style.FillStyleType = NON_SMOOTHED_CLIPPED_BITMAP;
+
+	if(!matrix.isNull())
+		style.Matrix = matrix->getMATRIX();
+
+	style.bitmap = bitmap->getBitmapContainer();
+
+	return style;
+}
+
+FILLSTYLE Graphics::createSolidFill(uint32_t color, uint8_t alpha)
+{
+	FILLSTYLE style(0xff);
+	style.FillStyleType = SOLID_FILL;
+	style.Color = RGBA(color, alpha);
+	return style;
+}
+
+ASFUNCTIONBODY(Graphics,beginBitmapFill)
+{
+	Graphics* th = obj->as<Graphics>();
+	_NR<BitmapData> bitmap;
+	_NR<Matrix> matrix;
+	bool repeat, smooth;
+	ARG_UNPACK (bitmap) (matrix, NullRef) (repeat, true) (smooth, false);
+
+	if(bitmap.isNull())
+		return NULL;
+
+	th->checkAndSetScaling();
+
+	FILLSTYLE style = createBitmapFill(bitmap, matrix, repeat, smooth);
+	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,beginFill)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+	uint32_t color=0;
+	uint8_t alpha=255;
+	if(argslen>=1)
+		color=args[0]->toUInt();
+	if(argslen>=2)
+		alpha=(uint8_t(args[1]->toNumber()*0xff));
+	FILLSTYLE style = Graphics::createSolidFill(color, alpha);
+	th->owner->tokens.emplace_back(GeomToken(SET_FILL, style));
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,endFill)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	th->checkAndSetScaling();
+	th->owner->tokens.emplace_back(CLEAR_FILL);
+	return NULL;
+}
+
+ASFUNCTIONBODY(Graphics,copyFrom)
+{
+	Graphics* th=static_cast<Graphics*>(obj);
+	_NR<Graphics> source;
+	ARG_UNPACK(source);
+	if (source.isNull())
+		return NULL;
+
+	th->owner->tokens.assign(source->owner->tokens.begin(),
+				 source->owner->tokens.end());
+	return NULL;
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsEndFill.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsEndFill.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsEndFill.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsEndFill.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,47 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsEndFill.h"
+#include "scripting/class.h"
+
+using namespace lightspark;
+
+GraphicsEndFill::GraphicsEndFill(Class_base* c):
+	ASObject(c)
+{
+}
+
+void GraphicsEndFill::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	c->addImplementedInterface(InterfaceClass<IGraphicsFill>::getClass());
+	IGraphicsFill::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+FILLSTYLE GraphicsEndFill::toFillStyle()
+{
+	return FILLSTYLE(0xff);
+}
+
+void GraphicsEndFill::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	tokens.emplace_back(CLEAR_FILL);
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsEndFill.h lightspark-0.7.2/src/scripting/flash/display/GraphicsEndFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsEndFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsEndFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,41 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSENDFILL_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSENDFILL_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class GraphicsEndFill: public ASObject, public IGraphicsFill, public IGraphicsData
+{
+public:
+	GraphicsEndFill(Class_base* c);
+	static void sinit(Class_base* c);
+        FILLSTYLE toFillStyle();
+        void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSENDFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsGradientFill.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsGradientFill.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsGradientFill.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsGradientFill.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,96 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsGradientFill.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/flash/geom/flashgeom.h"
+#include "scripting/toplevel/toplevel.h"
+#include "scripting/toplevel/Array.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+
+using namespace lightspark;
+
+GraphicsGradientFill::GraphicsGradientFill(Class_base* c):
+	ASObject(c), focalPointRatio(0), interpolationMethod("rgb"),
+	spreadMethod("pad"), type("linear")
+{
+}
+
+void GraphicsGradientFill::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, alphas);
+	REGISTER_GETTER_SETTER(c, colors);
+	REGISTER_GETTER_SETTER(c, focalPointRatio);
+	REGISTER_GETTER_SETTER(c, interpolationMethod);
+	REGISTER_GETTER_SETTER(c, matrix);
+	REGISTER_GETTER_SETTER(c, ratios);
+	REGISTER_GETTER_SETTER(c, spreadMethod);
+	REGISTER_GETTER_SETTER(c, type);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsFill>::getClass());
+	IGraphicsFill::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+void GraphicsGradientFill::finalize()
+{
+	ASObject::finalize();
+	alphas.reset();
+	colors.reset();
+	matrix.reset();
+	ratios.reset();
+}
+
+ASFUNCTIONBODY(GraphicsGradientFill, _constructor)
+{
+	GraphicsGradientFill* th = obj->as<GraphicsGradientFill>();
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->type, "linear")
+		(th->colors, NullRef)
+		(th->alphas, NullRef)
+		(th->ratios, NullRef)
+		(th->matrix, NullRef)
+		(th->spreadMethod, "pad")
+		(th->interpolationMethod, "rgb")
+		(th->focalPointRatio, 0);
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, alphas);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, colors);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, focalPointRatio);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, interpolationMethod);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, matrix);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, ratios);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, spreadMethod);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsGradientFill, type);
+
+FILLSTYLE GraphicsGradientFill::toFillStyle()
+{
+	return Graphics::createGradientFill(type, colors, alphas, ratios,
+		matrix, spreadMethod, interpolationMethod, focalPointRatio);
+}
+
+void GraphicsGradientFill::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	tokens.emplace_back(GeomToken(SET_FILL, toFillStyle()));
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsGradientFill.h lightspark-0.7.2/src/scripting/flash/display/GraphicsGradientFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsGradientFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsGradientFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,55 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSGRADIENTFILL_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSGRADIENTFILL_H 1
+
+#include "asobject.h"
+#include "tiny_string.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class Array;
+class Matrix;
+
+class GraphicsGradientFill: public ASObject, public IGraphicsFill, public IGraphicsData
+{
+public:
+	GraphicsGradientFill(Class_base* c);
+	static void sinit(Class_base* c);
+	void finalize();
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(_NR<Array>, alphas);
+	ASPROPERTY_GETTER_SETTER(_NR<Array>, colors);
+	ASPROPERTY_GETTER_SETTER(number_t, focalPointRatio);
+	ASPROPERTY_GETTER_SETTER(tiny_string, interpolationMethod);
+	ASPROPERTY_GETTER_SETTER(_NR<Matrix>, matrix);
+	ASPROPERTY_GETTER_SETTER(_NR<Array>, ratios);
+	ASPROPERTY_GETTER_SETTER(tiny_string, spreadMethod);
+	ASPROPERTY_GETTER_SETTER(tiny_string, type);
+	FILLSTYLE toFillStyle();
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSGRADIENTFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/Graphics.h lightspark-0.7.2/src/scripting/flash/display/Graphics.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/Graphics.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/Graphics.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,103 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICS_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICS_H 1
+
+#include <vector>
+#include "asobject.h"
+#include "backends/geometry.h"
+
+namespace lightspark
+{
+
+class TokenContainer;
+class Array;
+class Matrix;
+class BitmapData;
+class Vector;
+
+/* This objects paints to its owners tokens */
+class Graphics: public ASObject
+{
+private:
+	TokenContainer *const owner;
+	void checkAndSetScaling();
+	static void solveVertexMapping(double x1, double y1,
+				       double x2, double y2,
+				       double x3, double y3,
+				       double u1, double u2, double u3,
+				       double c[3]);
+public:
+	Graphics(Class_base* c):ASObject(c),owner(NULL)
+	{
+		throw RunTimeException("Cannot instantiate a Graphics object");
+	}
+	Graphics(Class_base* c, TokenContainer* _o)
+		: ASObject(c),owner(_o) {}
+	static void sinit(Class_base* c);
+	static void buildTraits(ASObject* o);
+	static FILLSTYLE createGradientFill(const tiny_string& type,
+					    _NR<Array> colors,
+					    _NR<Array> alphas,
+					    _NR<Array> ratios,
+					    _NR<Matrix> matrix,
+					    const tiny_string& spreadMethod,
+					    const tiny_string& interpolationMethod,
+					    number_t focalPointRatio);
+	static FILLSTYLE createBitmapFill(_R<BitmapData> bitmap,
+					  _NR<Matrix> matrix,
+					  bool repeat,
+					  bool smooth);
+	static FILLSTYLE createSolidFill(uint32_t color, uint8_t alpha);
+	static void pathToTokens(_NR<Vector> commands,
+				 _NR<Vector> data,
+				 tiny_string windings,
+				 std::vector<GeomToken>& tokens);
+	static void drawTrianglesToTokens(_NR<Vector> vertices,
+					  _NR<Vector> indices,
+					  _NR<Vector> uvtData,
+					  tiny_string culling,
+					  std::vector<GeomToken>& tokens);
+	ASFUNCTION(_constructor);
+	ASFUNCTION(lineBitmapStyle);
+	ASFUNCTION(lineGradientStyle);
+	ASFUNCTION(lineStyle);
+	ASFUNCTION(beginFill);
+	ASFUNCTION(beginGradientFill);
+	ASFUNCTION(beginBitmapFill);
+	ASFUNCTION(endFill);
+	ASFUNCTION(drawRect);
+	ASFUNCTION(drawRoundRect);
+	ASFUNCTION(drawCircle);
+	ASFUNCTION(drawEllipse);
+	ASFUNCTION(drawGraphicsData);
+	ASFUNCTION(drawPath);
+	ASFUNCTION(drawTriangles);
+	ASFUNCTION(moveTo);
+	ASFUNCTION(lineTo);
+	ASFUNCTION(curveTo);
+	ASFUNCTION(cubicCurveTo);
+	ASFUNCTION(clear);
+	ASFUNCTION(copyFrom);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICS_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsPath.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsPath.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsPath.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsPath.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,173 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/toplevel/Vector.h"
+#include "scripting/flash/display/GraphicsPath.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/argconv.h"
+#include "scripting/class.h"
+
+using namespace lightspark;
+
+GraphicsPath::GraphicsPath(Class_base* c):
+	ASObject(c), winding("evenOdd")
+{
+}
+
+void GraphicsPath::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, commands);
+	REGISTER_GETTER_SETTER(c, data);
+	REGISTER_GETTER_SETTER(c, winding);
+	c->setDeclaredMethodByQName("curveTo","",Class<IFunction>::getFunction(curveTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lineTo","",Class<IFunction>::getFunction(lineTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("moveTo","",Class<IFunction>::getFunction(moveTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("wideLineTo","",Class<IFunction>::getFunction(wideLineTo),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("wideMoveTo","",Class<IFunction>::getFunction(wideMoveTo),NORMAL_METHOD,true);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsPath>::getClass());
+	IGraphicsPath::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsPath, commands);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsPath, data);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsPath, winding);
+
+ASFUNCTIONBODY(GraphicsPath, _constructor)
+{
+	_NR<Vector> commands;
+	_NR<Vector> data;
+	GraphicsPath* th = obj->as<GraphicsPath>();
+	ARG_UNPACK(commands, NullRef)(data, NullRef)(th->winding, "evenOdd");
+
+	ASObject::_constructor(obj,NULL,0);
+
+	if (!commands.isNull())
+		th->commands = commands;
+	if (!data.isNull())
+		th->data = data;
+
+	return NULL;
+}
+
+void GraphicsPath::finalize()
+{
+	ASObject::finalize();
+	commands.reset();
+	data.reset();
+}
+
+void GraphicsPath::ensureValid()
+{
+	if (commands.isNull())
+		commands = _MNR(Class<Vector>::getInstanceS(Class<Integer>::getClass()));
+	if (data.isNull())
+		data = _MNR(Class<Vector>::getInstanceS(Class<Number>::getClass()));
+}
+
+ASFUNCTIONBODY(GraphicsPath, curveTo)
+{
+	GraphicsPath* th=obj->as<GraphicsPath>();
+	number_t cx;
+	number_t cy;
+	number_t ax;
+	number_t ay;
+	ARG_UNPACK (cx) (cy) (ax) (ay);
+
+	th->ensureValid();
+	th->commands->append(abstract_i(GraphicsPathCommand::CURVE_TO));
+	th->data->append(abstract_d(ax));
+	th->data->append(abstract_d(ay));
+	th->data->append(abstract_d(cx));
+	th->data->append(abstract_d(cy));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(GraphicsPath, lineTo)
+{
+	GraphicsPath* th=obj->as<GraphicsPath>();
+	number_t x;
+	number_t y;
+	ARG_UNPACK (x) (y);
+
+	th->ensureValid();
+	th->commands->append(abstract_i(GraphicsPathCommand::LINE_TO));
+	th->data->append(abstract_d(x));
+	th->data->append(abstract_d(y));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(GraphicsPath, moveTo)
+{
+	GraphicsPath* th=obj->as<GraphicsPath>();
+	number_t x;
+	number_t y;
+	ARG_UNPACK (x) (y);
+
+	th->ensureValid();
+	th->commands->append(abstract_i(GraphicsPathCommand::MOVE_TO));
+	th->data->append(abstract_d(x));
+	th->data->append(abstract_d(y));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(GraphicsPath, wideLineTo)
+{
+	GraphicsPath* th=obj->as<GraphicsPath>();
+	number_t x;
+	number_t y;
+	ARG_UNPACK (x) (y);
+
+	th->ensureValid();
+	th->commands->append(abstract_i(GraphicsPathCommand::LINE_TO));
+	th->data->append(abstract_d(0));
+	th->data->append(abstract_d(0));
+	th->data->append(abstract_d(x));
+	th->data->append(abstract_d(y));
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(GraphicsPath, wideMoveTo)
+{
+	GraphicsPath* th=obj->as<GraphicsPath>();
+	number_t x;
+	number_t y;
+	ARG_UNPACK (x) (y);
+
+	th->ensureValid();
+	th->commands->append(abstract_i(GraphicsPathCommand::MOVE_TO));
+	th->data->append(abstract_d(0));
+	th->data->append(abstract_d(0));
+	th->data->append(abstract_d(x));
+	th->data->append(abstract_d(y));
+
+	return NULL;
+}
+
+void GraphicsPath::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	Graphics::pathToTokens(commands, data, winding, tokens);
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsPath.h lightspark-0.7.2/src/scripting/flash/display/GraphicsPath.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsPath.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsPath.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,55 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSPATH_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSPATH_H 1
+
+#include "asobject.h"
+#include "tiny_string.h"
+#include "scripting/flash/display/IGraphicsPath.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class Vector;
+
+class GraphicsPath: public ASObject, public IGraphicsPath, public IGraphicsData
+{
+private:
+	void ensureValid();
+public:
+	GraphicsPath(Class_base* c);
+	static void sinit(Class_base* c);
+	void finalize();
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(_NR<Vector>, commands);
+	ASPROPERTY_GETTER_SETTER(_NR<Vector>, data);
+	ASPROPERTY_GETTER_SETTER(tiny_string, winding);
+	ASFUNCTION(curveTo);
+	ASFUNCTION(lineTo);
+	ASFUNCTION(moveTo);
+	ASFUNCTION(wideLineTo);
+	ASFUNCTION(wideMoveTo);
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSPATH_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsShaderFill.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsShaderFill.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsShaderFill.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsShaderFill.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,73 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsShaderFill.h"
+#include "scripting/flash/display/flashdisplay.h"
+#include "scripting/flash/geom/flashgeom.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+
+using namespace lightspark;
+
+GraphicsShaderFill::GraphicsShaderFill(Class_base* c):
+	ASObject(c)
+{
+}
+
+void GraphicsShaderFill::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, matrix);
+	REGISTER_GETTER_SETTER(c, shader);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsFill>::getClass());
+	IGraphicsFill::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+void GraphicsShaderFill::finalize()
+{
+	ASObject::finalize();
+	matrix.reset();
+	shader.reset();
+}
+
+ASFUNCTIONBODY(GraphicsShaderFill, _constructor)
+{
+	GraphicsShaderFill* th = obj->as<GraphicsShaderFill>();
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->shader, NullRef) (th->matrix, NullRef);
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsShaderFill, matrix);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsShaderFill, shader);
+
+FILLSTYLE GraphicsShaderFill::toFillStyle()
+{
+	LOG(LOG_NOT_IMPLEMENTED, "GraphicsShaderFill::toFillStyle()");
+	return FILLSTYLE(0xff);
+}
+
+void GraphicsShaderFill::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	LOG(LOG_NOT_IMPLEMENTED, "GraphicsShaderFill::appendToTokens()");
+	return;
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsShaderFill.h lightspark-0.7.2/src/scripting/flash/display/GraphicsShaderFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsShaderFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsShaderFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,48 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSSHADERFILL_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSSHADERFILL_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class Matrix;
+class Shader;
+
+class GraphicsShaderFill: public ASObject, public IGraphicsFill, public IGraphicsData
+{
+public:
+	GraphicsShaderFill(Class_base* c);
+	static void sinit(Class_base* c);
+	void finalize();
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(_NR<Matrix>, matrix);
+	ASPROPERTY_GETTER_SETTER(_NR<Shader>, shader);
+	FILLSTYLE toFillStyle();
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSSHADERFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsSolidFill.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsSolidFill.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsSolidFill.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsSolidFill.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,63 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsSolidFill.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+
+using namespace lightspark;
+
+GraphicsSolidFill::GraphicsSolidFill(Class_base* c):
+	ASObject(c), alpha(1.0), color(0)
+{
+}
+
+void GraphicsSolidFill::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, alpha);
+	REGISTER_GETTER_SETTER(c, color);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsFill>::getClass());
+	IGraphicsFill::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+ASFUNCTIONBODY(GraphicsSolidFill, _constructor)
+{
+	GraphicsSolidFill* th = obj->as<GraphicsSolidFill>();
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->color, 0) (th->alpha, 1.0);
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsSolidFill, alpha);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsSolidFill, color);
+
+FILLSTYLE GraphicsSolidFill::toFillStyle()
+{
+	return Graphics::createSolidFill(color, static_cast<uint8_t>(255*alpha));
+}
+
+void GraphicsSolidFill::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	tokens.emplace_back(GeomToken(SET_FILL, toFillStyle()));
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsSolidFill.h lightspark-0.7.2/src/scripting/flash/display/GraphicsSolidFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsSolidFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsSolidFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,44 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSSOLIDFILL_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSSOLIDFILL_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class GraphicsSolidFill: public ASObject, public IGraphicsFill, public IGraphicsData
+{
+public:
+	GraphicsSolidFill(Class_base* c);
+	static void sinit(Class_base* c);
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(number_t, alpha);
+	ASPROPERTY_GETTER_SETTER(uint32_t, color);
+	FILLSTYLE toFillStyle();
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSSOLIDFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsStroke.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsStroke.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsStroke.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsStroke.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,109 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include <limits>
+#include "scripting/flash/display/GraphicsStroke.h"
+#include "scripting/flash/display/IGraphicsFill.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+#include "swftypes.h"
+
+using namespace lightspark;
+
+GraphicsStroke::GraphicsStroke(Class_base* c):
+	ASObject(c), caps("none"), joints("round"), miterLimit(3.0),
+	pixelHinting(false), scaleMode("normal"),
+	thickness(std::numeric_limits<double>::quiet_NaN())
+{
+}
+
+void GraphicsStroke::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, caps);
+	REGISTER_GETTER_SETTER(c, fill);
+	REGISTER_GETTER_SETTER(c, joints);
+	REGISTER_GETTER_SETTER(c, miterLimit);
+	REGISTER_GETTER_SETTER(c, pixelHinting);
+	REGISTER_GETTER_SETTER(c, scaleMode);
+	REGISTER_GETTER_SETTER(c, thickness);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsStroke>::getClass());
+	IGraphicsStroke::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+void GraphicsStroke::finalize()
+{
+	ASObject::finalize();
+	fill.reset();
+}
+
+ASFUNCTIONBODY(GraphicsStroke, _constructor)
+{
+	GraphicsStroke* th = obj->as<GraphicsStroke>();
+	_NR<ASObject> fill;
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->thickness, std::numeric_limits<double>::quiet_NaN())
+		(th->pixelHinting, false)
+		(th->scaleMode, "normal")
+		(th->caps, "none")
+		(th->joints, "rounds")
+		(th->miterLimit, 3.0)
+		(th->fill, NullRef);
+	th->validateFill(NullRef);
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, caps);
+ASFUNCTIONBODY_GETTER_SETTER_CB(GraphicsStroke, fill, validateFill);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, joints);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, miterLimit);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, pixelHinting);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, scaleMode);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsStroke, thickness);
+
+void GraphicsStroke::validateFill(_NR<ASObject> oldValue)
+{
+	if (!fill.isNull() && !fill->is<IGraphicsFill>())
+	{
+		tiny_string wrongClass = fill->getClassName();
+		fill = oldValue;
+		throwError<TypeError>(kCheckTypeFailedError, wrongClass, "IGraphicsFill");
+	}
+}
+
+void GraphicsStroke::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	LINESTYLE2 style(0xff);
+	style.Width = thickness;
+
+	// TODO: pixel hinting, scaling, caps, miter, joints
+
+	if (!fill.isNull())
+	{
+		IGraphicsFill *gfill = dynamic_cast<IGraphicsFill*>(fill.getPtr());
+		assert(gfill);
+		style.HasFillFlag = true;
+		style.FillType = gfill->toFillStyle();
+	}
+
+	tokens.emplace_back(GeomToken(SET_STROKE, style));
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsStroke.h lightspark-0.7.2/src/scripting/flash/display/GraphicsStroke.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsStroke.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsStroke.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,51 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSSTROKE_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSSTROKE_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsStroke.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class GraphicsStroke: public ASObject, public IGraphicsStroke, public IGraphicsData
+{
+protected:
+	void validateFill(_NR<ASObject> oldValue);
+public:
+	GraphicsStroke(Class_base* c);
+	static void sinit(Class_base* c);
+	void finalize();
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(tiny_string, caps);
+	ASPROPERTY_GETTER_SETTER(_NR<ASObject>, fill); // really IGraphicsFill
+	ASPROPERTY_GETTER_SETTER(tiny_string, joints);
+	ASPROPERTY_GETTER_SETTER(number_t, miterLimit);
+	ASPROPERTY_GETTER_SETTER(bool, pixelHinting);
+	ASPROPERTY_GETTER_SETTER(tiny_string, scaleMode);
+	ASPROPERTY_GETTER_SETTER(number_t, thickness);
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSSTROKE_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsTrianglePath.cpp lightspark-0.7.2/src/scripting/flash/display/GraphicsTrianglePath.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsTrianglePath.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsTrianglePath.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,74 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/display/GraphicsTrianglePath.h"
+#include "scripting/flash/display/Graphics.h"
+#include "scripting/toplevel/Vector.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+
+using namespace lightspark;
+
+GraphicsTrianglePath::GraphicsTrianglePath(Class_base* c):
+	ASObject(c), culling("none")
+{
+}
+
+void GraphicsTrianglePath::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, culling);
+	REGISTER_GETTER_SETTER(c, indices);
+	REGISTER_GETTER_SETTER(c, uvtData);
+	REGISTER_GETTER_SETTER(c, vertices);
+
+	c->addImplementedInterface(InterfaceClass<IGraphicsPath>::getClass());
+	IGraphicsPath::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IGraphicsData>::getClass());
+	IGraphicsData::linkTraits(c);
+}
+
+void GraphicsTrianglePath::finalize()
+{
+	ASObject::finalize();
+	indices.reset();
+	uvtData.reset();
+	vertices.reset();
+}
+
+ASFUNCTIONBODY(GraphicsTrianglePath, _constructor)
+{
+	GraphicsTrianglePath* th = obj->as<GraphicsTrianglePath>();
+	ASObject::_constructor(obj,NULL,0);
+	ARG_UNPACK (th->vertices, NullRef)
+		(th->indices, NullRef)
+		(th->uvtData, NullRef)
+		(th->culling, "none");
+	return NULL;
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsTrianglePath, culling);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsTrianglePath, indices);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsTrianglePath, uvtData);
+ASFUNCTIONBODY_GETTER_SETTER(GraphicsTrianglePath, vertices);
+
+void GraphicsTrianglePath::appendToTokens(std::vector<GeomToken>& tokens)
+{
+	Graphics::drawTrianglesToTokens(vertices, indices, uvtData, culling, tokens);
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsTrianglePath.h lightspark-0.7.2/src/scripting/flash/display/GraphicsTrianglePath.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/GraphicsTrianglePath.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/GraphicsTrianglePath.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,48 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_GRAPHICSTRIANGLEPATH_H
+#define SCRIPTING_FLASH_DISPLAY_GRAPHICSTRIANGLEPATH_H 1
+
+#include "asobject.h"
+#include "scripting/flash/display/IGraphicsPath.h"
+#include "scripting/flash/display/IGraphicsData.h"
+
+namespace lightspark
+{
+
+class Vector;
+
+class GraphicsTrianglePath: public ASObject, public IGraphicsPath, public IGraphicsData
+{
+public:
+	GraphicsTrianglePath(Class_base* c);
+	static void sinit(Class_base* c);
+	void finalize();
+	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(tiny_string, culling);
+	ASPROPERTY_GETTER_SETTER(_NR<Vector>, indices);
+	ASPROPERTY_GETTER_SETTER(_NR<Vector>, uvtData);
+	ASPROPERTY_GETTER_SETTER(_NR<Vector>, vertices);
+	void appendToTokens(std::vector<GeomToken>& tokens);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_DISPLAY_GRAPHICSTRIANGLEPATH_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsData.h lightspark-0.7.2/src/scripting/flash/display/IGraphicsData.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsData.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/IGraphicsData.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,42 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_IGRAPHICSDATA_H
+#define SCRIPTING_FLASH_DISPLAY_IGRAPHICSDATA_H 1
+
+#include <vector>
+#include "backends/geometry.h"
+
+namespace lightspark
+{
+
+class Class_base;
+
+class IGraphicsData
+{
+protected:
+	virtual ~IGraphicsData() {}
+public:
+	static void linkTraits(Class_base* c) {};
+	// Appends GeomTokens for drawing this object into tokens
+	virtual void appendToTokens(std::vector<GeomToken>& tokens) = 0;
+};
+
+};
+#endif /* SCRIPTING_FLASH_DISPLAY_IGRAPHICSDATA_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsFill.h lightspark-0.7.2/src/scripting/flash/display/IGraphicsFill.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsFill.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/IGraphicsFill.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,40 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_IGRAPHICSFILL_H
+#define SCRIPTING_FLASH_DISPLAY_IGRAPHICSFILL_H 1
+
+#include "swftypes.h"
+
+namespace lightspark
+{
+
+class Class_base;
+
+class IGraphicsFill
+{
+protected:
+	virtual ~IGraphicsFill() {}
+public:
+	static void linkTraits(Class_base* c) {};
+	virtual FILLSTYLE toFillStyle() = 0;
+};
+
+};
+#endif /* SCRIPTING_FLASH_DISPLAY_IGRAPHICSFILL_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsPath.h lightspark-0.7.2/src/scripting/flash/display/IGraphicsPath.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsPath.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/IGraphicsPath.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,35 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_IGRAPHICSPATH_H
+#define SCRIPTING_FLASH_DISPLAY_IGRAPHICSPATH_H 1
+
+namespace lightspark
+{
+
+class Class_base;
+
+class IGraphicsPath
+{
+public:
+	static void linkTraits(Class_base* c) {};
+};
+
+};
+#endif /* SCRIPTING_FLASH_DISPLAY_IGRAPHICSPATH_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsStroke.h lightspark-0.7.2/src/scripting/flash/display/IGraphicsStroke.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/IGraphicsStroke.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/IGraphicsStroke.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,35 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_DISPLAY_IGRAPHICSSTROKE_H
+#define SCRIPTING_FLASH_DISPLAY_IGRAPHICSSTROKE_H 1
+
+namespace lightspark
+{
+
+class Class_base;
+
+class IGraphicsStroke
+{
+public:
+	static void linkTraits(Class_base* c) {};
+};
+
+};
+#endif /* SCRIPTING_FLASH_DISPLAY_IGRAPHICSSTROKE_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/TokenContainer.cpp lightspark-0.7.2/src/scripting/flash/display/TokenContainer.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/display/TokenContainer.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/TokenContainer.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -230,17 +230,16 @@
 }
 
 /* Find the size of the active texture (bitmap set by the latest SET_FILL). */
-void TokenContainer::getTextureSize(int *width, int *height) const
+void TokenContainer::getTextureSize(std::vector<GeomToken>& tokens, int *width, int *height)
 {
 	*width=0;
 	*height=0;
 
-	unsigned int len=tokens.size();
-	for(unsigned int i=0;i<len;i++)
+	for(int i=tokens.size()-1;i>=0;i--)
 	{
-		const FILLSTYLE& style=tokens[len-i-1].fillStyle;
+		const FILLSTYLE& style=tokens[i].fillStyle;
 		const FILL_STYLE_TYPE& fstype=style.FillStyleType;
-		if(tokens[len-i-1].type==SET_FILL && 
+		if(tokens[i].type==SET_FILL && 
 		   (fstype==REPEATING_BITMAP ||
 		    fstype==NON_SMOOTHED_REPEATING_BITMAP ||
 		    fstype==CLIPPED_BITMAP ||
@@ -255,3 +254,17 @@
 		}
 	}
 }
+
+/* Return the width of the latest SET_STROKE */
+uint16_t TokenContainer::getCurrentLineWidth() const
+{
+	for(int i=tokens.size()-1;i>=0;i--)
+	{
+		if(tokens[i].type==SET_STROKE)
+		{
+			return tokens[i].lineStyle.Width;
+		}
+	}
+
+	return 0;
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/display/TokenContainer.h lightspark-0.7.2/src/scripting/flash/display/TokenContainer.h
--- lightspark-0.7.2.orig/src/scripting/flash/display/TokenContainer.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/display/TokenContainer.h	2013-11-09 19:23:31.000000000 +0200
@@ -24,6 +24,7 @@
 #include "backends/geometry.h"
 #include "backends/graphics.h"
 #include "scripting/flash/display/DisplayObject.h"
+#include "scripting/flash/display/Graphics.h"
 
 namespace lightspark
 {
@@ -49,7 +50,8 @@
 	static void FromShaperecordListToShapeVector(const std::vector<SHAPERECORD>& shapeRecords,
 					 tokensVector& tokens, const std::list<FILLSTYLE>& fillStyles,
 					 const MATRIX& matrix = MATRIX());
-	void getTextureSize(int *width, int *height) const;
+	static void getTextureSize(std::vector<GeomToken>& tokens, int *width, int *height);
+	uint16_t getCurrentLineWidth() const;
 	float scaling;
 protected:
 	TokenContainer(DisplayObject* _o);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/errors/flasherrors.cpp lightspark-0.7.2/src/scripting/flash/errors/flasherrors.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/errors/flasherrors.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/errors/flasherrors.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -32,8 +32,7 @@
 
 void IOError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void IOError::buildTraits(ASObject* o)
@@ -49,8 +48,7 @@
 
 void EOFError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<IOError>::getRef());
+	CLASS_SETUP(c, IOError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void EOFError::buildTraits(ASObject* o)
@@ -66,8 +64,7 @@
 
 void IllegalOperationError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void IllegalOperationError::buildTraits(ASObject* o)
@@ -85,8 +82,7 @@
 
 void InvalidSWFError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void InvalidSWFError::buildTraits(ASObject* o)
@@ -102,8 +98,7 @@
 
 void MemoryError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void MemoryError::buildTraits(ASObject* o)
@@ -119,8 +114,7 @@
 
 void ScriptTimeoutError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void ScriptTimeoutError::buildTraits(ASObject* o)
@@ -136,8 +130,7 @@
 
 void StackOverflowError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void StackOverflowError::buildTraits(ASObject* o)
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/events/flashevents.cpp lightspark-0.7.2/src/scripting/flash/events/flashevents.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/events/flashevents.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/events/flashevents.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -49,9 +49,7 @@
 
 void Event::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->setVariableByQName("ACTIVATE","",Class<ASString>::getInstanceS("activate"),DECLARED_TRAIT);
 	c->setVariableByQName("ADDED","",Class<ASString>::getInstanceS("added"),DECLARED_TRAIT);
 	c->setVariableByQName("ADDED_TO_STAGE","",Class<ASString>::getInstanceS("addedToStage"),DECLARED_TRAIT);
@@ -189,8 +187,7 @@
 
 void EventPhase::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("CAPTURING_PHASE","",abstract_i(CAPTURING_PHASE),DECLARED_TRAIT);
 	c->setVariableByQName("BUBBLING_PHASE","",abstract_i(BUBBLING_PHASE),DECLARED_TRAIT);
 	c->setVariableByQName("AT_TARGET","",abstract_i(AT_TARGET),DECLARED_TRAIT);
@@ -201,10 +198,8 @@
 }
 
 void FocusEvent::sinit(Class_base* c)
-{
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+{	
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("FOCUS_IN","",Class<ASString>::getInstanceS("focusIn"),DECLARED_TRAIT);
 	c->setVariableByQName("FOCUS_OUT","",Class<ASString>::getInstanceS("focusOut"),DECLARED_TRAIT);
 	c->setVariableByQName("MOUSE_FOCUS_CHANGE","",Class<ASString>::getInstanceS("mouseFocusChange"),DECLARED_TRAIT);
@@ -249,9 +244,7 @@
 
 void ProgressEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("PROGRESS","",Class<ASString>::getInstanceS("progress"),DECLARED_TRAIT);
 	REGISTER_GETTER_SETTER(c,bytesLoaded);
 	REGISTER_GETTER_SETTER(c,bytesTotal);
@@ -279,18 +272,14 @@
 
 void TimerEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("TIMER","",Class<ASString>::getInstanceS("timer"),DECLARED_TRAIT);
 	c->setVariableByQName("TIMER_COMPLETE","",Class<ASString>::getInstanceS("timerComplete"),DECLARED_TRAIT);
 }
 
 void MouseEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("CLICK","",Class<ASString>::getInstanceS("click"),DECLARED_TRAIT);
 	c->setVariableByQName("DOUBLE_CLICK","",Class<ASString>::getInstanceS("doubleClick"),DECLARED_TRAIT);
 	c->setVariableByQName("MOUSE_DOWN","",Class<ASString>::getInstanceS("mouseDown"),DECLARED_TRAIT);
@@ -488,9 +477,7 @@
 
 void IOErrorEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ErrorEvent>::getRef());
-
+	CLASS_SETUP(c, ErrorEvent, _constructor, CLASS_SEALED);
 	c->setVariableByQName("DISK_ERROR","",Class<ASString>::getInstanceS("diskError"),DECLARED_TRAIT);
 	c->setVariableByQName("IO_ERROR","",Class<ASString>::getInstanceS("ioError"),DECLARED_TRAIT);
 	c->setVariableByQName("NETWORK_ERROR","",Class<ASString>::getInstanceS("networkError"),DECLARED_TRAIT);
@@ -510,9 +497,8 @@
 
 void EventDispatcher::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->addImplementedInterface(InterfaceClass<IEventDispatcher>::getClass());
-	c->setSuper(Class<ASObject>::getRef());
 
 	c->setDeclaredMethodByQName("addEventListener","",Class<IFunction>::getFunction(addEventListener),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("hasEventListener","",Class<IFunction>::getFunction(_hasEventListener),NORMAL_METHOD,true);
@@ -731,7 +717,6 @@
 
 NetStatusEvent::NetStatusEvent(Class_base* cb, const tiny_string& level, const tiny_string& code):Event(cb, "netStatus")
 {
-	//The object has been initialized internally
 	ASObject* info=Class<ASObject>::getInstanceS();
 	info->setVariableByQName("level","",Class<ASString>::getInstanceS(level),DECLARED_TRAIT);
 	info->setVariableByQName("code","",Class<ASString>::getInstanceS(code),DECLARED_TRAIT);
@@ -740,9 +725,7 @@
 
 void NetStatusEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("NET_STATUS","",Class<ASString>::getInstanceS("netStatus"),DECLARED_TRAIT);
 }
 
@@ -769,7 +752,12 @@
 		//Uninitialized info
 		info=getSys()->getNullRef();
 	}
-	obj->setVariableByQName("info","",info,DECLARED_TRAIT);
+	multiname infoName(NULL);
+	infoName.name_type=multiname::NAME_STRING;
+	infoName.name_s_id=getSys()->getUniqueStringId("info");
+	infoName.ns.push_back(nsNameAndKind("",NAMESPACE));
+	infoName.isAttribute = false;
+	obj->setVariableByMultiname(infoName, info, CONST_NOT_ALLOWED);
 	return NULL;
 }
 
@@ -800,9 +788,7 @@
 
 void FullScreenEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("FULL_SCREEN","",Class<ASString>::getInstanceS("fullScreen"),DECLARED_TRAIT);
 }
 
@@ -820,9 +806,7 @@
 
 void KeyboardEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c, altKey);
 	REGISTER_GETTER_SETTER(c, charCode);
 	REGISTER_GETTER_SETTER(c, commandKey);
@@ -959,11 +943,8 @@
 
 void TextEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("TEXT_INPUT","",Class<ASString>::getInstanceS("textInput"),DECLARED_TRAIT);
-
 	REGISTER_GETTER_SETTER(c,text);
 }
 
@@ -985,9 +966,7 @@
 
 void ErrorEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<TextEvent>::getRef());
-
+	CLASS_SETUP(c, TextEvent, _constructor, CLASS_SEALED);
 	c->setVariableByQName("ERROR","",Class<ASString>::getInstanceS("error"),DECLARED_TRAIT);
 }
 
@@ -1008,9 +987,7 @@
 
 void SecurityErrorEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ErrorEvent>::getRef());
-
+	CLASS_SETUP(c, ErrorEvent, _constructor, CLASS_SEALED);
 	c->setVariableByQName("SECURITY_ERROR","",Class<ASString>::getInstanceS("securityError"),DECLARED_TRAIT);
 }
 
@@ -1020,9 +997,7 @@
 
 void AsyncErrorEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ErrorEvent>::getRef());
-
+	CLASS_SETUP(c, ErrorEvent, _constructor, CLASS_SEALED);
 	c->setVariableByQName("ASYNC_ERROR","",Class<ASString>::getInstanceS("asyncError"),DECLARED_TRAIT);
 }
 
@@ -1043,9 +1018,7 @@
 
 void HTTPStatusEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("HTTP_STATUS","",Class<ASString>::getInstanceS("httpStatus"),DECLARED_TRAIT);
 }
 
@@ -1109,18 +1082,14 @@
 
 void StatusEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	/* TODO: dispatch this event */
 	c->setVariableByQName("STATUS","",Class<ASString>::getInstanceS("status"),DECLARED_TRAIT);
 }
 
 void DataEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<TextEvent>::getRef());
-
+	CLASS_SETUP(c, TextEvent, _constructor, CLASS_SEALED);
 	/* TODO: dispatch this event */
 	c->setVariableByQName("DATA","",Class<ASString>::getInstanceS("data"),DECLARED_TRAIT);
 	/* TODO: dispatch this event */
@@ -1160,9 +1129,7 @@
 
 void InvokeEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("INVOKE","",Class<ASString>::getInstanceS("invoke"),DECLARED_TRAIT);
 }
 
@@ -1179,9 +1146,7 @@
 
 void DRMErrorEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ErrorEvent>::getRef());
-
+	CLASS_SETUP(c, ErrorEvent, _constructor, CLASS_SEALED);
 	c->setVariableByQName("DRM_ERROR","",Class<ASString>::getInstanceS("drmError"),DECLARED_TRAIT);
 	c->setVariableByQName("DRM_LOAD_DEVICEID_ERROR","",Class<ASString>::getInstanceS("drmLoadDeviceIdError"),DECLARED_TRAIT);
 }
@@ -1201,9 +1166,7 @@
 
 void DRMStatusEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("DRM_STATUS","",Class<ASString>::getInstanceS("drmStatus"),DECLARED_TRAIT);
 }
 
@@ -1223,11 +1186,8 @@
 
 void StageVideoEvent::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<Event>::getRef());
-	
+	CLASS_SETUP(c, Event, _constructor, CLASS_SEALED);
 	c->setVariableByQName("RENDER_STATE","",Class<ASString>::getInstanceS("renderState"),DECLARED_TRAIT);
-
 	REGISTER_GETTER(c,colorSpace);
 	REGISTER_GETTER(c,status);
 }
@@ -1273,6 +1233,7 @@
 
 void StageVideoAvailabilityEvent::sinit(Class_base* c)
 {
+	CLASS_SETUP_NO_CONSTRUCTOR(c, Event, CLASS_SEALED);
 	c->setVariableByQName("STAGE_VIDEO_AVAILABILITY","",Class<ASString>::getInstanceS("stageVideoAvailability"),DECLARED_TRAIT);
 	REGISTER_GETTER(c, availability);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/events/flashevents.h lightspark-0.7.2/src/scripting/flash/events/flashevents.h
--- lightspark-0.7.2.orig/src/scripting/flash/events/flashevents.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/events/flashevents.h	2013-11-09 19:23:31.000000000 +0200
@@ -145,8 +145,7 @@
 private:
 	virtual Event* cloneImpl() const;
 public:
-	NetStatusEvent(Class_base* c):Event(c, "netStatus"){}
-	NetStatusEvent(Class_base* cb, const tiny_string& l, const tiny_string& c);
+	NetStatusEvent(Class_base* cb, const tiny_string& l="", const tiny_string& c="");
 	static void sinit(Class_base*);
 	static void buildTraits(ASObject* o)
 	{
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/external/ExternalInterface.cpp lightspark-0.7.2/src/scripting/flash/external/ExternalInterface.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/external/ExternalInterface.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/external/ExternalInterface.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -26,7 +26,7 @@
 
 void ExternalInterface::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("available","",Class<IFunction>::getFunction(_getAvailable),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("objectID","",Class<IFunction>::getFunction(_getObjectID),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("marshallExceptions","",Class<IFunction>::getFunction(_getMarshallExceptions),GETTER_METHOD,false);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/filters/flashfilters.cpp lightspark-0.7.2/src/scripting/flash/filters/flashfilters.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/filters/flashfilters.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/filters/flashfilters.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -19,14 +19,14 @@
 
 #include "scripting/flash/filters/flashfilters.h"
 #include "scripting/class.h"
+#include "scripting/argconv.h"
 
 using namespace std;
 using namespace lightspark;
 
 void BitmapFilter::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED);
 	c->setDeclaredMethodByQName("clone","",Class<IFunction>::getFunction(clone),NORMAL_METHOD,true);
 }
 
@@ -41,24 +41,135 @@
 	return th->cloneImpl();
 }
 
-void GlowFilter::sinit(Class_base* c)
+GlowFilter::GlowFilter(Class_base* c):
+	BitmapFilter(c), alpha(1.0), blurX(6.0), blurY(6.0), color(0xFF0000),
+	inner(false), knockout(false), quality(1), strength(2.0)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<BitmapFilter>::getRef());
 }
 
-GlowFilter* GlowFilter::cloneImpl() const
+void GlowFilter::sinit(Class_base* c)
 {
-	return Class<GlowFilter>::getInstanceS();
-}
-
-void DropShadowFilter::sinit(Class_base* c)
+	CLASS_SETUP(c, BitmapFilter, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, alpha);
+	REGISTER_GETTER_SETTER(c, blurX);
+	REGISTER_GETTER_SETTER(c, blurY);
+	REGISTER_GETTER_SETTER(c, color);
+	REGISTER_GETTER_SETTER(c, inner);
+	REGISTER_GETTER_SETTER(c, knockout);
+	REGISTER_GETTER_SETTER(c, quality);
+	REGISTER_GETTER_SETTER(c, strength);
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, alpha);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, blurX);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, blurY);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, color);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, inner);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, knockout);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, quality);
+ASFUNCTIONBODY_GETTER_SETTER(GlowFilter, strength);
+
+ASFUNCTIONBODY(GlowFilter, _constructor)
+{
+	GlowFilter *th = obj->as<GlowFilter>();
+	ARG_UNPACK (th->color, 0xFF0000)
+		(th->alpha, 1.0)
+		(th->blurX, 6.0)
+		(th->blurY, 6.0)
+		(th->strength, 2.0)
+		(th->quality, 1)
+		(th->inner, false)
+		(th->knockout, false);
+	return NULL;
+}
+
+BitmapFilter* GlowFilter::cloneImpl() const
+{
+	GlowFilter *cloned = Class<GlowFilter>::getInstanceS();
+	cloned->alpha = alpha;
+	cloned->blurX = blurX;
+	cloned->blurY = blurY;
+	cloned->color = color;
+	cloned->inner = inner;
+	cloned->knockout = knockout;
+	cloned->quality = quality;
+	cloned->strength = strength;
+	return cloned;
+}
+
+DropShadowFilter::DropShadowFilter(Class_base* c):
+	BitmapFilter(c), alpha(1.0), angle(45), blurX(4.0), blurY(4.0),
+	color(0), distance(4.0), hideObject(false), inner(false),
+	knockout(false), quality(1), strength(1.0)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<BitmapFilter>::getRef());
 }
 
-DropShadowFilter* DropShadowFilter::cloneImpl() const
+void DropShadowFilter::sinit(Class_base* c)
 {
-	return Class<DropShadowFilter>::getInstanceS();
+	CLASS_SETUP(c, BitmapFilter, _constructor, CLASS_SEALED | CLASS_FINAL);
+	REGISTER_GETTER_SETTER(c, alpha);
+	REGISTER_GETTER_SETTER(c, angle);
+	REGISTER_GETTER_SETTER(c, blurX);
+	REGISTER_GETTER_SETTER(c, blurY);
+	REGISTER_GETTER_SETTER(c, color);
+	REGISTER_GETTER_SETTER(c, distance);
+	REGISTER_GETTER_SETTER(c, hideObject);
+	REGISTER_GETTER_SETTER(c, inner);
+	REGISTER_GETTER_SETTER(c, knockout);
+	REGISTER_GETTER_SETTER(c, quality);
+	REGISTER_GETTER_SETTER(c, strength);
+}
+
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, alpha);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, angle);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, blurX);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, blurY);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, color);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, distance);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, hideObject);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, inner);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, knockout);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, quality);
+ASFUNCTIONBODY_GETTER_SETTER(DropShadowFilter, strength);
+
+ASFUNCTIONBODY(DropShadowFilter, _constructor)
+{
+	DropShadowFilter *th = obj->as<DropShadowFilter>();
+	ARG_UNPACK (th->distance, 4.0)
+		(th->angle, 45)
+		(th->color, 0)
+		(th->alpha, 1.0)
+		(th->blurX, 4.0)
+		(th->blurY, 4.0)
+		(th->strength, 1.0)
+		(th->quality, 1)
+		(th->inner, false)
+		(th->knockout, false)
+		(th->hideObject, false);
+	return NULL;
+}
+
+BitmapFilter* DropShadowFilter::cloneImpl() const
+{
+	DropShadowFilter *cloned = Class<DropShadowFilter>::getInstanceS();
+	cloned->alpha = alpha;
+	cloned->angle = angle;
+	cloned->blurX = blurX;
+	cloned->blurY = blurY;
+	cloned->color = color;
+	cloned->distance = distance;
+	cloned->hideObject = hideObject;
+	cloned->inner = inner;
+	cloned->knockout = knockout;
+	cloned->quality = quality;
+	cloned->strength = strength;
+	return cloned;
+}
+
+void BitmapFilterQuality::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED | CLASS_FINAL);
+	c->setVariableByQName("HIGH","",abstract_i(3),DECLARED_TRAIT);
+	c->setVariableByQName("LOW","",abstract_i(1),DECLARED_TRAIT);
+	c->setVariableByQName("MEDIUM","",abstract_i(3),DECLARED_TRAIT);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/filters/flashfilters.h lightspark-0.7.2/src/scripting/flash/filters/flashfilters.h
--- lightspark-0.7.2.orig/src/scripting/flash/filters/flashfilters.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/filters/flashfilters.h	2013-11-09 19:23:31.000000000 +0200
@@ -40,21 +40,49 @@
 class GlowFilter: public BitmapFilter
 {
 private:
-	virtual GlowFilter* cloneImpl() const;
+	ASPROPERTY_GETTER_SETTER(number_t, alpha);
+	ASPROPERTY_GETTER_SETTER(number_t, blurX);
+	ASPROPERTY_GETTER_SETTER(number_t, blurY);
+	ASPROPERTY_GETTER_SETTER(uint32_t, color);
+	ASPROPERTY_GETTER_SETTER(bool, inner);
+	ASPROPERTY_GETTER_SETTER(bool, knockout);
+	ASPROPERTY_GETTER_SETTER(int32_t, quality);
+	ASPROPERTY_GETTER_SETTER(number_t, strength);
+	virtual BitmapFilter* cloneImpl() const;
 public:
-	GlowFilter(Class_base* c):BitmapFilter(c){}
+	GlowFilter(Class_base* c);
 	static void sinit(Class_base* c);
 //	static void buildTraits(ASObject* o);
+	ASFUNCTION(_constructor);
 };
 
 class DropShadowFilter: public BitmapFilter
 {
 private:
-	virtual DropShadowFilter* cloneImpl() const;
+	ASPROPERTY_GETTER_SETTER(number_t, alpha);
+	ASPROPERTY_GETTER_SETTER(number_t, angle);
+	ASPROPERTY_GETTER_SETTER(number_t, blurX);
+	ASPROPERTY_GETTER_SETTER(number_t, blurY);
+	ASPROPERTY_GETTER_SETTER(uint32_t, color);
+	ASPROPERTY_GETTER_SETTER(number_t, distance);
+	ASPROPERTY_GETTER_SETTER(bool, hideObject);
+	ASPROPERTY_GETTER_SETTER(bool, inner);
+	ASPROPERTY_GETTER_SETTER(bool, knockout);
+	ASPROPERTY_GETTER_SETTER(int32_t, quality);
+	ASPROPERTY_GETTER_SETTER(number_t, strength);
+	virtual BitmapFilter* cloneImpl() const;
 public:
-	DropShadowFilter(Class_base* c):BitmapFilter(c){}
+	DropShadowFilter(Class_base* c);
 	static void sinit(Class_base* c);
 //	static void buildTraits(ASObject* o);
+	ASFUNCTION(_constructor);
+};
+
+class BitmapFilterQuality: public ASObject
+{
+public:
+	BitmapFilterQuality(Class_base* c):ASObject(c) {}
+	static void sinit(Class_base* c);
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/geom/flashgeom.cpp lightspark-0.7.2/src/scripting/flash/geom/flashgeom.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/geom/flashgeom.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/geom/flashgeom.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -26,7 +26,7 @@
 
 void Rectangle::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	IFunction* gleft=Class<IFunction>::getFunction(_getLeft);
 	c->setDeclaredMethodByQName("left","",gleft,GETTER_METHOD,true);
 	gleft->incRef();
@@ -490,7 +490,7 @@
 
 void ColorTransform::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 
 	// properties
 	c->setDeclaredMethodByQName("color","",Class<IFunction>::getFunction(getColor),GETTER_METHOD,true);
@@ -582,7 +582,6 @@
 
 ASFUNCTIONBODY(ColorTransform,getColor)
 {
-	assert_and_throw(argslen==1);
 	ColorTransform* th=static_cast<ColorTransform*>(obj);
 
 	int ao, ro, go, bo;
@@ -738,7 +737,7 @@
 
 void Point::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("x","",Class<IFunction>::getFunction(_getX),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("y","",Class<IFunction>::getFunction(_getY),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_getlength),GETTER_METHOD,true);
@@ -930,7 +929,7 @@
 
 void Transform::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("colorTransform","",Class<IFunction>::getFunction(_getColorTransform),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("colorTransform","",Class<IFunction>::getFunction(_setColorTransform),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("matrix","",Class<IFunction>::getFunction(_setMatrix),SETTER_METHOD,true);
@@ -999,7 +998,7 @@
 
 void Matrix::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	
 	//Properties
 	c->setDeclaredMethodByQName("a","",Class<IFunction>::getFunction(_get_a),GETTER_METHOD,true);
@@ -1318,7 +1317,7 @@
 
 void Vector3D::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 
 	// constants
 	Vector3D* tx = new (c->memoryAccount) Vector3D(c);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/geom/flashgeom.h lightspark-0.7.2/src/scripting/flash/geom/flashgeom.h
--- lightspark-0.7.2.orig/src/scripting/flash/geom/flashgeom.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/geom/flashgeom.h	2013-11-09 19:23:31.000000000 +0200
@@ -184,6 +184,7 @@
 	ASFUNCTION(_set_ty);
 };
 
+class DisplayObject;
 class Transform: public ASObject
 {
 private:
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/media/flashmedia.cpp lightspark-0.7.2/src/scripting/flash/media/flashmedia.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/media/flashmedia.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/media/flashmedia.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -24,6 +24,7 @@
 #include <iostream>
 #include "backends/audio.h"
 #include "backends/rendering.h"
+#include "backends/streamcache.h"
 #include "scripting/argconv.h"
 
 using namespace lightspark;
@@ -31,8 +32,7 @@
 
 void SoundTransform::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	REGISTER_GETTER_SETTER(c,volume);
 	REGISTER_GETTER_SETTER(c,pan);
 }
@@ -55,8 +55,7 @@
 
 void Video::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObject>::getRef());
+	CLASS_SETUP(c, DisplayObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("videoWidth","",Class<IFunction>::getFunction(_getVideoWidth),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("videoHeight","",Class<IFunction>::getFunction(_getVideoHeight),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(Video::_getWidth),GETTER_METHOD,true);
@@ -64,8 +63,13 @@
 	c->setDeclaredMethodByQName("height","",Class<IFunction>::getFunction(Video::_getHeight),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("height","",Class<IFunction>::getFunction(Video::_setHeight),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("attachNetStream","",Class<IFunction>::getFunction(attachNetStream),NORMAL_METHOD,true);
+	REGISTER_GETTER_SETTER(c, deblocking);
+	REGISTER_GETTER_SETTER(c, smoothing);
 }
 
+ASFUNCTIONBODY_GETTER_SETTER(Video, deblocking);
+ASFUNCTIONBODY_GETTER_SETTER(Video, smoothing);
+
 void Video::buildTraits(ASObject* o)
 {
 }
@@ -77,7 +81,8 @@
 }
 
 Video::Video(Class_base* c, uint32_t w, uint32_t h)
-	: DisplayObject(c),width(w),height(h),videoWidth(0),videoHeight(0),initialized(false),netStream(NullRef)
+	: DisplayObject(c),width(w),height(h),videoWidth(0),videoHeight(0),
+	  initialized(false),netStream(NullRef),deblocking(0),smoothing(false)
 {
 }
 
@@ -215,7 +220,16 @@
 }
 
 Sound::Sound(Class_base* c)
- :EventDispatcher(c),downloader(NULL),soundChannelCreated(false),bytesLoaded(0),bytesTotal(0),length(60*1000)
+	:EventDispatcher(c),downloader(NULL),soundData(new MemoryStreamCache),
+	 container(true),format(CODEC_NONE, 0, 0),bytesLoaded(0),bytesTotal(0),length(60*1000)
+{
+}
+
+Sound::Sound(Class_base* c, _R<StreamCache> data, AudioFormat _format)
+	:EventDispatcher(c),downloader(NULL),soundData(data),
+	 container(false),format(_format),
+	 bytesLoaded(soundData->getReceivedLength()),
+	 bytesTotal(soundData->getReceivedLength()),length(60*1000)
 {
 }
 
@@ -227,8 +241,7 @@
 
 void Sound::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("load","",Class<IFunction>::getFunction(load),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("play","",Class<IFunction>::getFunction(play),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("close","",Class<IFunction>::getFunction(close),NORMAL_METHOD,true);
@@ -261,6 +274,9 @@
 	th->url = urlRequest->getRequestURL();
 	urlRequest->getPostData(th->postData);
 
+	_R<StreamCache> c(_MR(new MemoryStreamCache()));
+	th->soundData = c;
+
 	if(!th->url.isValid())
 	{
 		//Notify an error during loading
@@ -275,13 +291,13 @@
 	{
 		//This is a GET request
 		//Use disk cache our downloaded files
-		th->downloader=getSys()->downloadManager->download(th->url, true, th);
+		th->downloader=getSys()->downloadManager->download(th->url, th->soundData, th);
 	}
 	else
 	{
 		list<tiny_string> headers=urlRequest->getHeaders();
-		th->downloader=getSys()->downloadManager->downloadWithData(th->url, th->postData,
-				headers, th);
+		th->downloader=getSys()->downloadManager->downloadWithData(th->url,
+				th->soundData, th->postData, headers, th);
 		//Clean up the postData for the next load
 		th->postData.clear();
 	}
@@ -302,19 +318,11 @@
 	if(startTime!=0)
 		LOG(LOG_NOT_IMPLEMENTED,"startTime not supported in Sound::play");
 
-	if (!th->soundChannelCreated)
-	{
-		th->soundChannelCreated = true;
-		th->incRef();
-		return Class<SoundChannel>::getInstanceS(th->downloader, _MNR(th));
-	}
+	th->incRef();
+	if (th->container)
+		return Class<SoundChannel>::getInstanceS(th->soundData);
 	else
-	{
-		LOG(LOG_NOT_IMPLEMENTED,"Sound::play called more than once");
-		// should return a new independent SoundChannel for
-		// the same downloaded data
-		return getSys()->getUndefinedRef();
-	}
+		return Class<SoundChannel>::getInstanceS(th->soundData, th->format);
 }
 
 ASFUNCTIONBODY(Sound,close)
@@ -352,8 +360,7 @@
 
 void SoundLoaderContext::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c,bufferTime);
 	REGISTER_GETTER_SETTER(c,checkPolicyFile);
 }
@@ -374,10 +381,11 @@
 ASFUNCTIONBODY_GETTER_SETTER(SoundLoaderContext,bufferTime);
 ASFUNCTIONBODY_GETTER_SETTER(SoundLoaderContext,checkPolicyFile);
 
-SoundChannel::SoundChannel(Class_base* c, std::streambuf *s, _NR<Sound> _owner)
-  : EventDispatcher(c),stream(s),owner(_owner),stopped(false),audioDecoder(NULL),audioStream(NULL),position(0)
+SoundChannel::SoundChannel(Class_base* c, _NR<StreamCache> _stream, AudioFormat _format)
+: EventDispatcher(c),stream(_stream),stopped(false),audioDecoder(NULL),audioStream(NULL),
+  format(_format),position(0),soundTransform(_MR(Class<SoundTransform>::getInstanceS()))
 {
-	if(s)
+	if (!stream.isNull())
 	{
 		// Start playback
 		incRef();
@@ -392,19 +400,35 @@
 
 void SoundChannel::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("stop","",Class<IFunction>::getFunction(stop),NORMAL_METHOD,true);
 
 	REGISTER_GETTER(c,position);
+	REGISTER_GETTER_SETTER(c,soundTransform);
 }
 
 ASFUNCTIONBODY_GETTER(SoundChannel,position);
+ASFUNCTIONBODY_GETTER_SETTER_CB(SoundChannel,soundTransform,validateSoundTransform);
 
 void SoundChannel::buildTraits(ASObject* o)
 {
 }
 
+void SoundChannel::finalize()
+{
+	EventDispatcher::finalize();
+	soundTransform.reset();
+}
+
+void SoundChannel::validateSoundTransform(_NR<SoundTransform> oldValue)
+{
+	if (soundTransform.isNull())
+	{
+		soundTransform = oldValue;
+		throwError<TypeError>(kNullPointerError, "soundTransform");
+	}
+}
+
 ASFUNCTIONBODY(SoundChannel, _constructor)
 {
 	EventDispatcher::_constructor(obj, NULL, 0);
@@ -421,7 +445,18 @@
 
 void SoundChannel::execute()
 {
-	stream.exceptions ( istream::eofbit | istream::failbit | istream::badbit );
+	if (format.codec == CODEC_NONE)
+		playStream();
+	else
+		playRaw();
+}
+
+void SoundChannel::playStream()
+{
+	assert(!stream.isNull());
+	std::streambuf *sbuf = stream->createReader();
+	istream s(sbuf);
+	s.exceptions ( istream::eofbit | istream::failbit | istream::badbit );
 
 	bool waitForFlush=true;
 	StreamDecoder* streamDecoder=NULL;
@@ -429,7 +464,7 @@
 	try
 	{
 #ifdef ENABLE_LIBAVCODEC
-		streamDecoder=new FFMpegStreamDecoder(stream);
+		streamDecoder=new FFMpegStreamDecoder(s);
 		if(!streamDecoder->isValid())
 			threadAbort();
 
@@ -486,6 +521,45 @@
 		audioStream=NULL;
 	}
 	delete streamDecoder;
+	delete sbuf;
+
+	if (!ACQUIRE_READ(stopped))
+	{
+		incRef();
+		getVm()->addEvent(_MR(this),_MR(Class<Event>::getInstanceS("soundComplete")));
+	}
+}
+
+void SoundChannel::playRaw()
+{
+	assert(!stream.isNull());
+	FFMpegAudioDecoder *decoder = new FFMpegAudioDecoder(format.codec,
+							     format.sampleRate,
+							     format.channels,
+							     true);
+	if (!decoder)
+		return;
+	if(!getSys()->audioManager->pluginLoaded())
+		return;
+
+	AudioStream *audioStream = NULL;
+	std::streambuf *sbuf = stream->createReader();
+	istream stream(sbuf);
+	do
+	{
+		decoder->decodeStreamSomePackets(stream, 0);
+		if (decoder->isValid())
+			audioStream=getSys()->audioManager->createStreamPlugin(decoder);
+	}
+	while (!ACQUIRE_READ(stopped) && !stream.eof() && !stream.fail() && !stream.bad());
+
+	decoder->setFlushing();
+	decoder->waitFlushed();
+	sleep(1);
+	
+	delete audioStream;
+	delete decoder;
+	delete sbuf;
 
 	if (!ACQUIRE_READ(stopped))
 	{
@@ -513,8 +587,7 @@
 
 void StageVideo::sinit(Class_base *c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 }
 
 ASFUNCTIONBODY(StageVideo,_constructor)
@@ -525,14 +598,14 @@
 
 void StageVideoAvailability::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("AVAILABLE","",Class<ASString>::getInstanceS("available"),DECLARED_TRAIT);
 	c->setVariableByQName("UNAVAILABLE","",Class<ASString>::getInstanceS("unavailable"),DECLARED_TRAIT);
 }
 
 void VideoStatus::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("ACCELERATED","",Class<ASString>::getInstanceS("accelerated"),DECLARED_TRAIT);
 	c->setVariableByQName("SOFTWARE","",Class<ASString>::getInstanceS("software"),DECLARED_TRAIT);
 	c->setVariableByQName("UNAVAILABLE","",Class<ASString>::getInstanceS("unavailable"),DECLARED_TRAIT);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/media/flashmedia.h lightspark-0.7.2/src/scripting/flash/media/flashmedia.h
--- lightspark-0.7.2.orig/src/scripting/flash/media/flashmedia.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/media/flashmedia.h	2013-11-09 19:23:31.000000000 +0200
@@ -34,6 +34,16 @@
 
 class AudioDecoder;
 class NetStream;
+class StreamCache;
+
+class AudioFormat
+{
+public:
+	AudioFormat(LS_AUDIO_CODEC co, int sr, int ch):codec(co),sampleRate(sr),channels(ch) {}
+	LS_AUDIO_CODEC codec;
+	int sampleRate;
+	int channels;
+};
 
 class Sound: public EventDispatcher, public ILoadable
 {
@@ -41,7 +51,12 @@
 	URLInfo url;
 	std::vector<uint8_t> postData;
 	Downloader* downloader;
-	bool soundChannelCreated;
+	_R<StreamCache> soundData;
+	// If container is true, audio format is parsed from
+	// soundData. If container is false, soundData is raw samples
+	// and format is defined by format member.
+	bool container;
+	AudioFormat format;
 	ASPROPERTY_GETTER(uint32_t,bytesLoaded);
 	ASPROPERTY_GETTER(uint32_t,bytesTotal);
 	ASPROPERTY_GETTER(number_t,length);
@@ -50,6 +65,7 @@
 	void setBytesLoaded(uint32_t b);
 public:
 	Sound(Class_base* c);
+	Sound(Class_base* c, _R<StreamCache> soundData, AudioFormat format);
 	~Sound();
 	static void sinit(Class_base*);
 	static void buildTraits(ASObject* o);
@@ -72,20 +88,23 @@
 class SoundChannel : public EventDispatcher, public IThreadJob
 {
 private:
-	std::istream stream;
-	// owner keeps reference to the Sound object that owns the
-	// streambuf. TODO: ugly, get rid of this
-	_NR<Sound> owner;
+        _NR<StreamCache> stream;
 	Mutex mutex;
 	ACQUIRE_RELEASE_FLAG(stopped);
 	AudioDecoder* audioDecoder;
 	AudioStream* audioStream;
+	AudioFormat format;
 	ASPROPERTY_GETTER_SETTER(uint32_t,position);
+	ASPROPERTY_GETTER_SETTER(_NR<SoundTransform>,soundTransform);
+	void validateSoundTransform(_NR<SoundTransform>);
+	void playStream();
+	void playRaw();
 public:
-	SoundChannel(Class_base* c, std::streambuf *s=NULL, _NR<Sound> owner=NullRef);
+	SoundChannel(Class_base* c, _NR<StreamCache> stream=NullRef, AudioFormat format=AudioFormat(CODEC_NONE,0,0));
 	~SoundChannel();
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
+	void finalize();
 	ASFUNCTION(_constructor);
 	ASFUNCTION(stop);
 
@@ -103,6 +122,8 @@
 	mutable uint32_t videoWidth, videoHeight;
 	bool initialized;
 	_NR<NetStream> netStream;
+	ASPROPERTY_GETTER_SETTER(int32_t, deblocking);
+	ASPROPERTY_GETTER_SETTER(bool, smoothing);
 public:
 	Video(Class_base* c, uint32_t w=320, uint32_t h=240);
 	void finalize();
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/flashnet.cpp lightspark-0.7.2/src/scripting/flash/net/flashnet.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/net/flashnet.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/flashnet.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -29,6 +29,7 @@
 #include "backends/audio.h"
 #include "backends/builtindecoder.h"
 #include "backends/rendering.h"
+#include "backends/streamcache.h"
 #include "scripting/argconv.h"
 
 using namespace std;
@@ -41,14 +42,15 @@
 
 void URLRequest::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("url","",Class<IFunction>::getFunction(_setURL),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("url","",Class<IFunction>::getFunction(_getURL),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("method","",Class<IFunction>::getFunction(_setMethod),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("method","",Class<IFunction>::getFunction(_getMethod),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("data","",Class<IFunction>::getFunction(_setData),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("data","",Class<IFunction>::getFunction(_getData),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("digest","",Class<IFunction>::getFunction(_setDigest),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("digest","",Class<IFunction>::getFunction(_getDigest),GETTER_METHOD,true);
 	REGISTER_GETTER_SETTER(c,contentType);
 	REGISTER_GETTER_SETTER(c,requestHeaders);
 }
@@ -283,12 +285,51 @@
 	return NULL;
 }
 
+ASFUNCTIONBODY(URLRequest,_getDigest)
+{
+	URLRequest* th=obj->as<URLRequest>();
+	if (th->digest.numChars() == 0)
+		return getSys()->getNullRef();
+	else
+		return Class<ASString>::getInstanceS(th->digest);
+}
+
+ASFUNCTIONBODY(URLRequest,_setDigest)
+{
+	URLRequest* th=obj->as<URLRequest>();
+	tiny_string value;
+	ARG_UNPACK(value);
+
+	int numHexChars = 0;
+	bool validChars = true;
+	for (CharIterator it=value.begin(); it!=value.end(); ++it)
+	{
+		if (((*it >= 'A') && (*it <= 'F')) ||
+		    ((*it >= 'a') && (*it <= 'f')) ||
+		    ((*it >= '0') && (*it <= '9')))
+		{
+			numHexChars++;
+		}
+		else
+		{
+			validChars = false;
+			break;
+		}
+	}
+
+	if (!validChars || numHexChars != 64)
+		throw Class<ArgumentError>::getInstanceS("An invalid digest was supplied", 2034);
+
+	th->digest = value;
+	return NULL;
+}
+
 ASFUNCTIONBODY_GETTER_SETTER(URLRequest,contentType);
 ASFUNCTIONBODY_GETTER_SETTER(URLRequest,requestHeaders);
 
 void URLRequestMethod::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("GET","",Class<ASString>::getInstanceS("GET"),DECLARED_TRAIT);
 	c->setVariableByQName("POST","",Class<ASString>::getInstanceS("POST"),DECLARED_TRAIT);
 }
@@ -304,7 +345,8 @@
 
 	//TODO: support httpStatus, progress events
 
-	if(!createDownloader(false, loader, loader.getPtr()))
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	if(!createDownloader(cache, loader, loader.getPtr()))
 		return;
 
 	_NR<ASObject> data;
@@ -312,10 +354,12 @@
 	if(!downloader->hasFailed())
 	{
 		getVm()->addEvent(loader,_MR(Class<Event>::getInstanceS("open")));
-		downloader->waitForTermination();
+
+		cache->waitForTermination();
 		if(!downloader->hasFailed() && !threadAborting)
 		{
-			istream s(downloader);
+			std::streambuf *sbuf = cache->createReader();
+			istream s(sbuf);
 			uint8_t* buf=new uint8_t[downloader->getLength()+1];
 			//TODO: avoid this useless copy
 			s.read((char*)buf,downloader->getLength());
@@ -344,6 +388,7 @@
 				assert(false && "invalid dataFormat");
 			}
 
+			delete sbuf;
 			success=true;
 		}
 	}
@@ -381,8 +426,7 @@
 
 void URLLoader::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("dataFormat","",Class<IFunction>::getFunction(_getDataFormat),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("data","",Class<IFunction>::getFunction(_getData),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("data","",Class<IFunction>::getFunction(_setData),SETTER_METHOD,true);
@@ -539,7 +583,7 @@
 
 void URLLoaderDataFormat::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("VARIABLES","",Class<ASString>::getInstanceS("variables"),DECLARED_TRAIT);
 	c->setVariableByQName("TEXT","",Class<ASString>::getInstanceS("text"),DECLARED_TRAIT);
 	c->setVariableByQName("BINARY","",Class<ASString>::getInstanceS("binary"),DECLARED_TRAIT);
@@ -552,7 +596,9 @@
 
 void SharedObject::sinit(Class_base* c)
 {
-	c->setSuper(Class<EventDispatcher>::getRef());
+	// TODO: Use _constructorNotInstantiatable after getLocal is
+	// implemented
+	CLASS_SETUP_NO_CONSTRUCTOR(c, EventDispatcher, CLASS_SEALED);
 	c->setDeclaredMethodByQName("getLocal","",Class<IFunction>::getFunction(getLocal),NORMAL_METHOD,false);
 	REGISTER_GETTER(c,data);
 };
@@ -567,20 +613,21 @@
 
 void ObjectEncoding::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("AMF0","",abstract_i(AMF0),DECLARED_TRAIT);
 	c->setVariableByQName("AMF3","",abstract_i(AMF3),DECLARED_TRAIT);
 	c->setVariableByQName("DEFAULT","",abstract_i(DEFAULT),DECLARED_TRAIT);
 };
 
-NetConnection::NetConnection(Class_base* c):EventDispatcher(c),_connected(false),downloader(NULL),messageCount(0)
+NetConnection::NetConnection(Class_base* c):
+	EventDispatcher(c),_connected(false),downloader(NULL),messageCount(0),
+	proxyType(PT_NONE)
 {
 }
 
 void NetConnection::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("connect","",Class<IFunction>::getFunction(connect),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("call","",Class<IFunction>::getFunction(call),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("connected","",Class<IFunction>::getFunction(_getConnected),GETTER_METHOD,true);
@@ -590,6 +637,8 @@
 	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_getObjectEncoding),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_setObjectEncoding),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("protocol","",Class<IFunction>::getFunction(_getProtocol),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("proxyType","",Class<IFunction>::getFunction(_getProxyType),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("proxyType","",Class<IFunction>::getFunction(_setProxyType),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("uri","",Class<IFunction>::getFunction(_getURI),GETTER_METHOD,true);
 	REGISTER_GETTER_SETTER(c,client);
 }
@@ -683,22 +732,25 @@
 	assert(!messageData.empty());
 	std::list<tiny_string> headers;
 	headers.push_back("Content-Type: application/x-amf");
-	downloader=getSys()->downloadManager->downloadWithData(uri, messageData,
-			headers, NULL);
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	downloader=getSys()->downloadManager->downloadWithData(uri, cache,
+			messageData, headers, NULL);
 	//Get the whole answer
-	downloader->waitForTermination();
-	if(downloader->hasFailed()) //Check to see if the download failed for some reason
+	cache->waitForTermination();
+	if(cache->hasFailed()) //Check to see if the download failed for some reason
 	{
 		LOG(LOG_ERROR, "NetConnection::execute(): Download of URL failed: " << uri);
 //		getVm()->addEvent(contentLoaderInfo,_MR(Class<IOErrorEvent>::getInstanceS()));
 		getSys()->downloadManager->destroy(downloader);
 		return;
 	}
-	istream s(downloader);
+	std::streambuf *sbuf = cache->createReader();
+	istream s(sbuf);
 	_R<ByteArray> message=_MR(Class<ByteArray>::getInstanceS());
 	uint8_t* buf=message->getBuffer(downloader->getLength(), true);
 	s.read((char*)buf,downloader->getLength());
 	//Download is done, destroy it
+	delete sbuf;
 	{
 		//Acquire the lock to ensure consistency in threadAbort
 		SpinlockLocker l(downloaderLock);
@@ -798,6 +850,14 @@
 	return abstract_b(th->_connected);
 }
 
+ASFUNCTIONBODY(NetConnection,_getConnectedProxyType)
+{
+	NetConnection* th=Class<NetConnection>::cast(obj);
+	if (!th->_connected)
+		throw Class<ArgumentError>::getInstanceS("NetConnection object must be connected.", 2126);
+	return Class<ASString>::getInstanceS("none");
+}
+
 ASFUNCTIONBODY(NetConnection,_getDefaultObjectEncoding)
 {
 	return abstract_i(getSys()->staticNetConnectionDefaultObjectEncoding);
@@ -847,6 +907,59 @@
 		throw Class<ArgumentError>::getInstanceS("get NetConnection.protocol before connect");
 }
 
+ASFUNCTIONBODY(NetConnection,_getProxyType)
+{
+	NetConnection* th=Class<NetConnection>::cast(obj);
+	tiny_string name;
+	switch(th->proxyType)
+	{
+		case PT_NONE:
+			name = "NONE";
+			break;
+		case PT_HTTP:
+			name = "HTTP";
+			break;
+		case PT_CONNECT_ONLY:
+			name = "CONNECTOnly";
+			break;
+		case PT_CONNECT:
+			name = "CONNECT";
+			break;
+		case PT_BEST:
+			name = "best";
+			break;
+		default:
+			assert(false && "Invalid proxy type");
+			name = "";
+			break;
+	}
+	return Class<ASString>::getInstanceS(name);
+}
+
+ASFUNCTIONBODY(NetConnection,_setProxyType)
+{
+	NetConnection* th=Class<NetConnection>::cast(obj);
+	tiny_string value;
+	ARG_UNPACK(value);
+	if (value == "NONE")
+		th->proxyType = PT_NONE;
+	else if (value == "HTTP")
+		th->proxyType = PT_HTTP;
+	else if (value == "CONNECTOnly")
+		th->proxyType = PT_CONNECT_ONLY;
+	else if (value == "CONNECT")
+		th->proxyType = PT_CONNECT;
+	else if (value == "best")
+		th->proxyType = PT_BEST;
+	else
+		throwError<ArgumentError>(kInvalidEnumError, "proxyType");
+
+	if (th->proxyType != PT_NONE)
+		LOG(LOG_NOT_IMPLEMENTED, "Unimplemented proxy type " << value);
+
+	return NULL;
+}
+
 ASFUNCTIONBODY(NetConnection,_getURI)
 {
 	NetConnection* th=Class<NetConnection>::cast(obj);
@@ -888,8 +1001,7 @@
 
 void NetStream::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setVariableByQName("CONNECT_TO_FMS","",Class<ASString>::getInstanceS("connectToFMS"),DECLARED_TRAIT);
 	c->setVariableByQName("DIRECT_CONNECTIONS","",Class<ASString>::getInstanceS("directConnections"),DECLARED_TRAIT);
 	c->setDeclaredMethodByQName("play","",Class<IFunction>::getFunction(play),NORMAL_METHOD,true);
@@ -1070,9 +1182,8 @@
 	}
 	else //The URL is valid so we can start the download and add ourself as a job
 	{
-		//Cahe the download only if it is not RTMP based
-		bool cached=!th->url.isRTMP();
-		th->downloader=getSys()->downloadManager->download(th->url, cached, NULL);
+		StreamCache *cache = new FileStreamCache;
+		th->downloader=getSys()->downloadManager->download(th->url, _MR(cache), NULL);
 		th->streamTime=0;
 		//To be decreffed in jobFence
 		th->incRef();
@@ -1232,7 +1343,8 @@
 
 	//The downloader hasn't failed yet at this point
 
-	istream s(downloader);
+	std::streambuf *sbuf = downloader->getCache()->createReader();
+	istream s(sbuf);
 	s.exceptions(istream::goodbit);
 
 	ThreadProfile* profile=getSys()->allocateProfiler(RGB(0,0,200));
@@ -1349,6 +1461,7 @@
 		audioStream=NULL;
 	}
 	delete streamDecoder;
+	delete sbuf;
 }
 
 void NetStream::threadAbort()
@@ -1605,8 +1718,7 @@
 
 void URLVariables::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 	c->setDeclaredMethodByQName("decode","",Class<IFunction>::getFunction(decode),NORMAL_METHOD,true);
 	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
 }
@@ -1738,8 +1850,7 @@
 	urlRequest->getPostData(postData);
 	assert_and_throw(postData.empty());
 
-	//Don't cache our downloaded files
-	Downloader* downloader=getSys()->downloadManager->download(url, false, NULL);
+	Downloader* downloader=getSys()->downloadManager->download(url, _MR(new MemoryStreamCache), NULL);
 	//TODO: make the download asynchronous instead of waiting for an unused response
 	downloader->waitForTermination();
 	getSys()->downloadManager->destroy(downloader);
@@ -1783,8 +1894,7 @@
 
 void Responder::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("onResult","",Class<IFunction>::getFunction(onResult),NORMAL_METHOD,true);
 }
 
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/flashnet.h lightspark-0.7.2/src/scripting/flash/net/flashnet.h
--- lightspark-0.7.2.orig/src/scripting/flash/net/flashnet.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/flashnet.h	2013-11-09 19:23:31.000000000 +0200
@@ -39,6 +39,7 @@
 	METHOD method;
 	tiny_string url;
 	_NR<ASObject> data;
+	tiny_string digest;
 	tiny_string validatedContentType() const;
 	tiny_string getContentTypeHeader() const;
 	void validateHeaderName(const tiny_string& headerName) const;
@@ -56,6 +57,8 @@
 	ASFUNCTION(_setMethod);
 	ASFUNCTION(_setData);
 	ASFUNCTION(_getData);
+	ASFUNCTION(_getDigest);
+	ASFUNCTION(_setDigest);
 	URLInfo getRequestURL() const;
 	std::list<tiny_string> getHeaders() const;
 	void getPostData(std::vector<uint8_t>& data) const;
@@ -165,6 +168,7 @@
 {
 friend class NetStream;
 private:
+	enum PROXY_TYPE { PT_NONE, PT_HTTP, PT_CONNECT_ONLY, PT_CONNECT, PT_BEST };
 	//Indicates whether the application is connected to a server through a persistent RMTP connection/HTTP server with Flash Remoting
 	bool _connected;
 	tiny_string protocol;
@@ -178,6 +182,7 @@
 	uint32_t messageCount;
 	//The connection is to a flash media server
 	ObjectEncoding::ENCODING objectEncoding;
+	PROXY_TYPE proxyType;
 	//IThreadJob interface
 	void execute();
 	void threadAbort();
@@ -191,11 +196,14 @@
 	ASFUNCTION(connect);
 	ASFUNCTION(call);
 	ASFUNCTION(_getConnected);
+	ASFUNCTION(_getConnectedProxyType);
 	ASFUNCTION(_getDefaultObjectEncoding);
 	ASFUNCTION(_setDefaultObjectEncoding);
 	ASFUNCTION(_getObjectEncoding);
 	ASFUNCTION(_setObjectEncoding);
 	ASFUNCTION(_getProtocol);
+	ASFUNCTION(_getProxyType);
+	ASFUNCTION(_setProxyType);
 	ASFUNCTION(_getURI);
 	ASPROPERTY_GETTER_SETTER(NullableRef<ASObject>,client);
 };
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/URLRequestHeader.cpp lightspark-0.7.2/src/scripting/flash/net/URLRequestHeader.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/net/URLRequestHeader.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/URLRequestHeader.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -10,8 +10,7 @@
 
 void URLRequestHeader::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c,name);
 	REGISTER_GETTER_SETTER(c,value);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/URLStream.cpp lightspark-0.7.2/src/scripting/flash/net/URLStream.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/net/URLStream.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/URLStream.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -43,17 +43,19 @@
 
 	//TODO: support httpStatus, progress events
 
-	if(!createDownloader(false, loader))
+	_R<MemoryStreamCache> cache(_MR(new MemoryStreamCache));
+	if(!createDownloader(cache, loader))
 		return;
 
 	bool success=false;
 	if(!downloader->hasFailed())
 	{
 		getVm()->addEvent(loader,_MR(Class<Event>::getInstanceS("open")));
-		downloader->waitForTermination();
+		cache->waitForTermination();
 		if(!downloader->hasFailed() && !threadAborting)
 		{
-			istream s(downloader);
+			std::streambuf *sbuf = cache->createReader();
+			istream s(sbuf);
 			uint8_t* buf=new uint8_t[downloader->getLength()];
 			//TODO: avoid this useless copy
 			s.read((char*)buf,downloader->getLength());
@@ -61,6 +63,7 @@
 			data->acquireBuffer(buf,downloader->getLength());
 			//The buffers must not be deleted, it's now handled by the ByteArray instance
 			success=true;
+			delete sbuf;
 		}
 	}
 
@@ -86,8 +89,7 @@
 
 void URLStream::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("load","",Class<IFunction>::getFunction(load),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("close","",Class<IFunction>::getFunction(close),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("load","",Class<IFunction>::getFunction(load),NORMAL_METHOD,true);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/URLStream.h lightspark-0.7.2/src/scripting/flash/net/URLStream.h
--- lightspark-0.7.2.orig/src/scripting/flash/net/URLStream.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/URLStream.h	2013-11-09 19:23:31.000000000 +0200
@@ -23,6 +23,7 @@
 #include "compat.h"
 #include "asobject.h"
 #include "scripting/flash/events/flashevents.h"
+#include "scripting/flash/utils/ByteArray.h"
 #include "thread_pool.h"
 #include "backends/netutils.h"
 
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/net/XMLSocket.cpp lightspark-0.7.2/src/scripting/flash/net/XMLSocket.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/net/XMLSocket.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/net/XMLSocket.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -172,8 +172,7 @@
 
 void XMLSocket::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("close","",Class<IFunction>::getFunction(_close),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("connect","",Class<IFunction>::getFunction(_connect),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("send","",Class<IFunction>::getFunction(_send),NORMAL_METHOD,true);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/sensors/flashsensors.cpp lightspark-0.7.2/src/scripting/flash/sensors/flashsensors.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/sensors/flashsensors.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/sensors/flashsensors.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -29,10 +29,11 @@
 using namespace std;
 using namespace lightspark;
 
-Accelerometer::Accelerometer(Class_base* c):ASObject(c) {}
+Accelerometer::Accelerometer(Class_base* c):EventDispatcher(c) {}
 
 void Accelerometer::sinit(Class_base* c)
 {
+	CLASS_SETUP_NO_CONSTRUCTOR(c, EventDispatcher, CLASS_SEALED);
 	// properties
 	c->setDeclaredMethodByQName("isSupported", "", Class<IFunction>::getFunction(_isSupported),GETTER_METHOD,false);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/sensors/flashsensors.h lightspark-0.7.2/src/scripting/flash/sensors/flashsensors.h
--- lightspark-0.7.2.orig/src/scripting/flash/sensors/flashsensors.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/sensors/flashsensors.h	2013-11-09 19:23:31.000000000 +0200
@@ -30,7 +30,7 @@
 
 namespace lightspark
 {
-class Accelerometer: public ASObject {
+class Accelerometer: public EventDispatcher {
 	public:
 		Accelerometer(Class_base* c);
 		static void sinit(Class_base* c);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/system/flashsystem.cpp lightspark-0.7.2/src/scripting/flash/system/flashsystem.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/system/flashsystem.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/system/flashsystem.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -43,6 +43,7 @@
 
 void Capabilities::sinit(Class_base* c)
 {
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("language","",Class<IFunction>::getFunction(_getLanguage),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("playerType","",Class<IFunction>::getFunction(_getPlayerType),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("version","",Class<IFunction>::getFunction(_getVersion),GETTER_METHOD,false);
@@ -127,7 +128,7 @@
 
 void ApplicationDomain::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	//Static
 	c->setDeclaredMethodByQName("currentDomain","",Class<IFunction>::getFunction(_getCurrentDomain),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("MIN_DOMAIN_MEMORY_LENGTH","",Class<IFunction>::getFunction(_getMinDomainMemoryLength),GETTER_METHOD,false);
@@ -329,10 +330,20 @@
 	return NULL;
 }
 
+LoaderContext::LoaderContext(Class_base* c):
+	ASObject(c),allowCodeImport(true),checkPolicyFile(false)
+{
+}
+
 void LoaderContext::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
+	c->setDeclaredMethodByQName("allowLoadBytesCodeExecution","",Class<IFunction>::getFunction(_getter_allowCodeImport),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("allowLoadBytesCodeExecution","",Class<IFunction>::getFunction(_setter_allowCodeImport),SETTER_METHOD,false);
+	REGISTER_GETTER_SETTER(c, allowCodeImport);
 	REGISTER_GETTER_SETTER(c, applicationDomain);
+	REGISTER_GETTER_SETTER(c, checkPolicyFile);
+	REGISTER_GETTER_SETTER(c, parameters);
 	REGISTER_GETTER_SETTER(c, securityDomain);
 }
 
@@ -346,22 +357,31 @@
 ASFUNCTIONBODY(LoaderContext,_constructor)
 {
 	LoaderContext* th=Class<LoaderContext>::cast(obj);
-	bool checkPolicy;
-	_NR<ApplicationDomain> appDomain;
-	_NR<SecurityDomain> secDomain;
-	ARG_UNPACK (checkPolicy, false) (appDomain, NullRef) (secDomain, NullRef);
-	//TODO: Support checkPolicyFile
-	th->applicationDomain=appDomain;
-	th->securityDomain=secDomain;
+	ARG_UNPACK (th->checkPolicyFile, false)
+		(th->applicationDomain, NullRef)
+		(th->securityDomain, NullRef);
 	return NULL;
 }
 
+ASFUNCTIONBODY_GETTER_SETTER(LoaderContext, allowCodeImport);
 ASFUNCTIONBODY_GETTER_SETTER(LoaderContext, applicationDomain);
+ASFUNCTIONBODY_GETTER_SETTER(LoaderContext, checkPolicyFile);
+ASFUNCTIONBODY_GETTER_SETTER(LoaderContext, parameters);
 ASFUNCTIONBODY_GETTER_SETTER(LoaderContext, securityDomain);
 
+bool LoaderContext::getCheckPolicyFile()
+{
+	return checkPolicyFile;
+}
+
+bool LoaderContext::getAllowCodeImport()
+{
+	return allowCodeImport;
+}
+
 void SecurityDomain::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	//Static
 	c->setDeclaredMethodByQName("currentDomain","",Class<IFunction>::getFunction(_getCurrentDomain),GETTER_METHOD,false);
 }
@@ -384,8 +404,8 @@
 
 void Security::sinit(Class_base* c)
 {
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED | CLASS_FINAL);
 	//Fully static class
-	c->setConstructor(NULL);
 	c->setDeclaredMethodByQName("exactSettings","",Class<IFunction>::getFunction(_getExactSettings),GETTER_METHOD,false);
 	c->setDeclaredMethodByQName("exactSettings","",Class<IFunction>::getFunction(_setExactSettings),SETTER_METHOD,false);
 	c->setDeclaredMethodByQName("sandboxType","",Class<IFunction>::getFunction(_getSandboxType),GETTER_METHOD,false);
@@ -476,6 +496,7 @@
 
 void System::sinit(Class_base* c)
 {
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("totalMemory","",Class<IFunction>::getFunction(totalMemory),GETTER_METHOD,false);
 }
 
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/system/flashsystem.h lightspark-0.7.2/src/scripting/flash/system/flashsystem.h
--- lightspark-0.7.2.orig/src/scripting/flash/system/flashsystem.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/system/flashsystem.h	2013-11-09 19:23:31.000000000 +0200
@@ -22,7 +22,8 @@
 
 #include "compat.h"
 #include "asobject.h"
-#include "scripting/flash/utils/flashutils.h"
+#include "scripting/flash/utils/ByteArray.h"
+#include "scripting/toplevel/toplevel.h"
 
 namespace lightspark
 {
@@ -102,12 +103,17 @@
 class LoaderContext: public ASObject
 {
 public:
-	LoaderContext(Class_base* c):ASObject(c){};
+	LoaderContext(Class_base* c);
 	static void sinit(Class_base* c);
 	ASFUNCTION(_constructor);
+	ASPROPERTY_GETTER_SETTER(bool, allowCodeImport);
 	ASPROPERTY_GETTER_SETTER(_NR<ApplicationDomain>, applicationDomain);
+	ASPROPERTY_GETTER_SETTER(bool, checkPolicyFile);
+	ASPROPERTY_GETTER_SETTER(_NR<ASObject>, parameters);
 	ASPROPERTY_GETTER_SETTER(_NR<SecurityDomain>, securityDomain);
 	void finalize();
+	bool getAllowCodeImport();
+	bool getCheckPolicyFile();
 };
 
 class SecurityDomain: public ASObject
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/text/flashtext.cpp lightspark-0.7.2/src/scripting/flash/text/flashtext.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/text/flashtext.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/text/flashtext.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -33,16 +33,14 @@
 
 void lightspark::AntiAliasType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("ADVANCED","",Class<ASString>::getInstanceS("advanced"),DECLARED_TRAIT);
 	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),DECLARED_TRAIT);
 }
 
 void ASFont::sinit(Class_base* c)
 {
-//	c->constructor=Class<IFunction>::getFunction(_constructor);
-	//c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED);
 	c->setDeclaredMethodByQName("enumerateFonts","",Class<IFunction>::getFunction(enumerateFonts),NORMAL_METHOD,false);
 	c->setDeclaredMethodByQName("registerFont","",Class<IFunction>::getFunction(registerFont),NORMAL_METHOD,false);
 
@@ -93,60 +91,123 @@
 }
 
 TextField::TextField(Class_base* c, const TextData& textData, bool _selectable, bool readOnly)
-	: InteractiveObject(c), TextData(textData), type(READ_ONLY), 
-	  mouseWheelEnabled(true), selectable(_selectable)
+	: InteractiveObject(c), TextData(textData), type(ET_READ_ONLY), 
+	  antiAliasType(AA_NORMAL), gridFitType(GF_PIXEL),
+	  textInteractionMode(TI_NORMAL), alwaysShowSelection(false),
+	  caretIndex(0), condenseWhite(false), displayAsPassword(false),
+	  embedFonts(false), maxChars(0), mouseWheelEnabled(true),
+	  selectable(_selectable), selectionBeginIndex(0), selectionEndIndex(0),
+	  sharpness(0), thickness(0), useRichTextClipboard(false)
 {
 	if (!readOnly)
 	{
-		type = EDITABLE;
+		type = ET_EDITABLE;
 		tabEnabled = true;
 	}
 }
 
 void TextField::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<InteractiveObject>::getRef());
-	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(TextField::_getWidth),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(TextField::_setWidth),SETTER_METHOD,true);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, InteractiveObject, CLASS_SEALED);
+
+	// methods
+	c->setDeclaredMethodByQName("appendText","",Class<IFunction>::getFunction(TextField:: appendText),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getTextFormat","",Class<IFunction>::getFunction(_getTextFormat),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("setTextFormat","",Class<IFunction>::getFunction(_setTextFormat),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineIndexAtPoint","",Class<IFunction>::getFunction(_getLineIndexAtPoint),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineIndexOfChar","",Class<IFunction>::getFunction(_getLineIndexOfChar),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineLength","",Class<IFunction>::getFunction(_getLineLength),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineMetrics","",Class<IFunction>::getFunction(_getLineMetrics),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineOffset","",Class<IFunction>::getFunction(_getLineOffset),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("getLineText","",Class<IFunction>::getFunction(_getLineText),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("replaceSelectedText","",Class<IFunction>::getFunction(_replaceSelectedText),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("replaceText","",Class<IFunction>::getFunction(_replaceText),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("setSelection","",Class<IFunction>::getFunction(_setSelection),NORMAL_METHOD,true);
+
+	// properties
+	c->setDeclaredMethodByQName("antiAliasType","",Class<IFunction>::getFunction(TextField::_getAntiAliasType),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("antiAliasType","",Class<IFunction>::getFunction(TextField::_setAntiAliasType),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("autoSize","",Class<IFunction>::getFunction(TextField::_setAutoSize),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("autoSize","",Class<IFunction>::getFunction(TextField::_getAutoSize),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("defaultTextFormat","",Class<IFunction>::getFunction(TextField::_getDefaultTextFormat),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("defaultTextFormat","",Class<IFunction>::getFunction(TextField::_setDefaultTextFormat),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("gridFitType","",Class<IFunction>::getFunction(TextField::_getGridFitType),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("gridFitType","",Class<IFunction>::getFunction(TextField::_setGridFitType),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("height","",Class<IFunction>::getFunction(TextField::_getHeight),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("height","",Class<IFunction>::getFunction(TextField::_setHeight),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("htmlText","",Class<IFunction>::getFunction(TextField::_getHtmlText),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("htmlText","",Class<IFunction>::getFunction(TextField::_setHtmlText),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("textHeight","",Class<IFunction>::getFunction(TextField::_getTextHeight),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("textWidth","",Class<IFunction>::getFunction(TextField::_getTextWidth),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(TextField::_getLength),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("text","",Class<IFunction>::getFunction(TextField::_getText),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("text","",Class<IFunction>::getFunction(TextField::_setText),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("textHeight","",Class<IFunction>::getFunction(TextField::_getTextHeight),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("textWidth","",Class<IFunction>::getFunction(TextField::_getTextWidth),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(TextField::_getWidth),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("width","",Class<IFunction>::getFunction(TextField::_setWidth),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("wordWrap","",Class<IFunction>::getFunction(TextField::_setWordWrap),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("wordWrap","",Class<IFunction>::getFunction(TextField::_getWordWrap),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("autoSize","",Class<IFunction>::getFunction(TextField::_setAutoSize),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("autoSize","",Class<IFunction>::getFunction(TextField::_getAutoSize),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("appendText","",Class<IFunction>::getFunction(TextField:: appendText),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("getTextFormat","",Class<IFunction>::getFunction(_getTextFormat),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("setTextFormat","",Class<IFunction>::getFunction(_setTextFormat),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("getLineMetrics","",Class<IFunction>::getFunction(_getLineMetrics),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("defaultTextFormat","",Class<IFunction>::getFunction(TextField::_getDefaultTextFormat),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("defaultTextFormat","",Class<IFunction>::getFunction(TextField::_setDefaultTextFormat),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("numLines","",Class<IFunction>::getFunction(TextField::_getNumLines),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("maxScrollH","",Class<IFunction>::getFunction(TextField::_getMaxScrollH),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("maxScrollV","",Class<IFunction>::getFunction(TextField::_getMaxScrollV),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("bottomScrollV","",Class<IFunction>::getFunction(TextField::_getBottomScrollV),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("restrict","",Class<IFunction>::getFunction(TextField::_getRestrict),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("restrict","",Class<IFunction>::getFunction(TextField::_setRestrict),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("textInteractionMode","",Class<IFunction>::getFunction(TextField::_getTextInteractionMode),GETTER_METHOD,true);
 
+	REGISTER_GETTER_SETTER(c, alwaysShowSelection);
 	REGISTER_GETTER_SETTER(c, background);
 	REGISTER_GETTER_SETTER(c, backgroundColor);
 	REGISTER_GETTER_SETTER(c, border);
 	REGISTER_GETTER_SETTER(c, borderColor);
+	REGISTER_GETTER(c, caretIndex);
+	REGISTER_GETTER_SETTER(c, condenseWhite);
+	REGISTER_GETTER_SETTER(c, displayAsPassword);
+	REGISTER_GETTER_SETTER(c, embedFonts);
+	REGISTER_GETTER_SETTER(c, maxChars);
 	REGISTER_GETTER_SETTER(c, multiline);
 	REGISTER_GETTER_SETTER(c, mouseWheelEnabled);
+	REGISTER_GETTER_SETTER(c, scrollH);
+	REGISTER_GETTER_SETTER(c, scrollV);
 	REGISTER_GETTER_SETTER(c, selectable);
+	REGISTER_GETTER(c, selectionBeginIndex);
+	REGISTER_GETTER(c, selectionEndIndex);
+	REGISTER_GETTER_SETTER(c, sharpness);
+	REGISTER_GETTER_SETTER(c, styleSheet);
 	REGISTER_GETTER_SETTER(c, textColor);
+	REGISTER_GETTER_SETTER(c, thickness);
 	REGISTER_GETTER_SETTER(c, type);
+	REGISTER_GETTER_SETTER(c, useRichTextClipboard);
 }
 
+ASFUNCTIONBODY_GETTER_SETTER(TextField, alwaysShowSelection); // stub
 ASFUNCTIONBODY_GETTER_SETTER(TextField, background);
 ASFUNCTIONBODY_GETTER_SETTER(TextField, backgroundColor);
 ASFUNCTIONBODY_GETTER_SETTER(TextField, border);
 ASFUNCTIONBODY_GETTER_SETTER(TextField, borderColor);
+ASFUNCTIONBODY_GETTER(TextField, caretIndex);
+ASFUNCTIONBODY_GETTER_SETTER(TextField, condenseWhite);
+ASFUNCTIONBODY_GETTER_SETTER(TextField, displayAsPassword); // stub
+ASFUNCTIONBODY_GETTER_SETTER(TextField, embedFonts); // stub
+ASFUNCTIONBODY_GETTER_SETTER(TextField, maxChars); // stub
 ASFUNCTIONBODY_GETTER_SETTER(TextField, multiline);
-ASFUNCTIONBODY_GETTER_SETTER(TextField, mouseWheelEnabled);
-ASFUNCTIONBODY_GETTER_SETTER(TextField, selectable);
+ASFUNCTIONBODY_GETTER_SETTER(TextField, mouseWheelEnabled); // stub
+ASFUNCTIONBODY_GETTER_SETTER_CB(TextField, scrollH, validateScrollH);
+ASFUNCTIONBODY_GETTER_SETTER_CB(TextField, scrollV, validateScrollV);
+ASFUNCTIONBODY_GETTER_SETTER(TextField, selectable); // stub
+ASFUNCTIONBODY_GETTER(TextField, selectionBeginIndex);
+ASFUNCTIONBODY_GETTER(TextField, selectionEndIndex);
+ASFUNCTIONBODY_GETTER_SETTER_CB(TextField, sharpness, validateSharpness); // stub
+ASFUNCTIONBODY_GETTER_SETTER(TextField, styleSheet); // stub
 ASFUNCTIONBODY_GETTER_SETTER(TextField, textColor);
+ASFUNCTIONBODY_GETTER_SETTER_CB(TextField, thickness, validateThickness); // stub
+ASFUNCTIONBODY_GETTER_SETTER(TextField, useRichTextClipboard); // stub
+
+void TextField::finalize()
+{
+	ASObject::finalize();
+	restrictChars.reset();
+	styleSheet.reset();
+}
 
 void TextField::buildTraits(ASObject* o)
 {
@@ -167,7 +228,10 @@
 	number_t xmin,xmax,ymin,ymax;
 	boundsRect(xmin,xmax,ymin,ymax);
 	if( xmin <= x && x <= xmax && ymin <= y && y <= ymax && isHittable(type))
-		return last;
+	{
+		incRef();
+		return _MNR(this);
+	}
 	else
 		return NullRef;
 }
@@ -181,8 +245,8 @@
 ASFUNCTIONBODY(TextField,_setWordWrap)
 {
 	TextField* th=Class<TextField>::cast(obj);
-	assert_and_throw(argslen==1);
-	th->wordWrap=Boolean_concrete(args[0]);
+	ARG_UNPACK(th->wordWrap);
+	th->setSizeAndPositionFromAutoSize();
 	if(th->onStage)
 		th->requestInvalidation(getSys());
 	return NULL;
@@ -208,23 +272,59 @@
 ASFUNCTIONBODY(TextField,_setAutoSize)
 {
 	TextField* th=Class<TextField>::cast(obj);
-	assert_and_throw(argslen==1);
-	tiny_string temp = args[0]->toString();
-	if(temp == "none")
-		th->autoSize = AS_NONE;//TODO: take care of corner cases : what to do with sizes when changing the autoSize
-	else if (temp == "left")
-		th->autoSize = AS_LEFT;
-	else if (temp == "right")
-		th->autoSize = AS_RIGHT;
-	else if (temp == "center")
-		th->autoSize = AS_CENTER;
+	tiny_string autoSizeString;
+	ARG_UNPACK(autoSizeString);
+
+	AUTO_SIZE newAutoSize = AS_NONE;
+	if(autoSizeString == "none")
+		newAutoSize = AS_NONE;
+	else if (autoSizeString == "left")
+		newAutoSize = AS_LEFT;
+	else if (autoSizeString == "right")
+		newAutoSize = AS_RIGHT;
+	else if (autoSizeString == "center")
+		newAutoSize = AS_CENTER;
 	else
-		throw Class<ArgumentError>::getInstanceS("Wrong argument in TextField.autoSize");
-	if(th->onStage)
-		th->requestInvalidation(getSys());//TODO:check if there was any change
+		throwError<ArgumentError>(kInvalidEnumError, "autoSize");
+
+	if (th->autoSize != newAutoSize)
+	{
+		th->autoSize = newAutoSize;
+		th->setSizeAndPositionFromAutoSize();
+		if(th->onStage)
+			th->requestInvalidation(getSys());
+	}
+
 	return NULL;
 }
 
+void TextField::setSizeAndPositionFromAutoSize()
+{
+	if (autoSize == AS_NONE)
+		return;
+
+	height = textHeight;
+	if (!wordWrap && width < textWidth)
+	{
+		if (autoSize == AS_RIGHT)
+		{
+			number_t oldX = getXY().x;
+			setX(oldX+width-textWidth);
+			width = textWidth;
+		}
+		else if (autoSize == AS_CENTER)
+		{
+			number_t oldX = getXY().x;
+			setX(oldX + width/2 - textWidth/2);
+			width = textWidth;
+		}
+		else // AS_LEFT, because AS_NONE was handled before
+		{
+			width = textWidth;
+		}
+	}
+}
+
 ASFUNCTIONBODY(TextField,_getWidth)
 {
 	TextField* th=Class<TextField>::cast(obj);
@@ -383,7 +483,7 @@
 ASFUNCTIONBODY(TextField, _getter_type)
 {
 	TextField* th=Class<TextField>::cast(obj);
-	if (th->type == READ_ONLY)
+	if (th->type == ET_READ_ONLY)
 		return Class<ASString>::getInstanceS("dynamic");
 	else
 		return Class<ASString>::getInstanceS("input");
@@ -397,19 +497,370 @@
 	ARG_UNPACK(value);
 
 	if (value == "dynamic")
-		th->type = READ_ONLY;
+		th->type = ET_READ_ONLY;
 	else if (value == "input")
-		th->type = EDITABLE;
+		th->type = ET_EDITABLE;
 	else
 		throwError<ArgumentError>(kInvalidEnumError, "type");
 
 	return NULL;
 }
 
+ASFUNCTIONBODY(TextField,_getLineIndexAtPoint)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	number_t x;
+	number_t y;
+	ARG_UNPACK(x) (y);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	std::vector<LineData>::const_iterator it;
+	int i;
+	for (i=0, it=lines.begin(); it!=lines.end(); ++i, ++it)
+	{
+		if (x > it->extents.Xmin && x <= it->extents.Xmax &&
+		    y > it->extents.Ymin && y <= it->extents.Ymax)
+			return abstract_i(i);
+	}
+
+	return abstract_i(-1);
+}
+
+ASFUNCTIONBODY(TextField,_getLineIndexOfChar)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t charIndex;
+	ARG_UNPACK(charIndex);
+
+	if (charIndex < 0)
+		return abstract_i(-1);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	std::vector<LineData>::const_iterator it;
+	int i;
+	for (i=0, it=lines.begin(); it!=lines.end(); ++i, ++it)
+	{
+		if (charIndex >= it->firstCharOffset &&
+		    charIndex < it->firstCharOffset + it->length)
+			return abstract_i(i);
+	}
+
+	// testing shows that returns -1 on invalid index instead of
+	// throwing RangeError
+	return abstract_i(-1);
+}
+
+ASFUNCTIONBODY(TextField,_getLineLength)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t  lineIndex;
+	ARG_UNPACK(lineIndex);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	if (lineIndex < 0 || lineIndex >= (int32_t)lines.size())
+		throwError<RangeError>(kParamRangeError);
+
+	return abstract_i(lines[lineIndex].length);
+}
+
 ASFUNCTIONBODY(TextField,_getLineMetrics)
 {
-	LOG(LOG_NOT_IMPLEMENTED, "TextField.getLineMetrics() returns bogus values");
-	return Class<TextLineMetrics>::getInstanceS(19, 280, 14, 11, 3.5, 0);
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t  lineIndex;
+	ARG_UNPACK(lineIndex);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	if (lineIndex < 0 || lineIndex >= (int32_t)lines.size())
+		throwError<RangeError>(kParamRangeError);
+
+	return Class<TextLineMetrics>::getInstanceS(
+		lines[lineIndex].indent,
+		lines[lineIndex].extents.Xmax - lines[lineIndex].extents.Xmin,
+		lines[lineIndex].extents.Ymax - lines[lineIndex].extents.Ymin,
+		lines[lineIndex].ascent,
+		lines[lineIndex].descent,
+		lines[lineIndex].leading);
+}
+
+ASFUNCTIONBODY(TextField,_getLineOffset)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t  lineIndex;
+	ARG_UNPACK(lineIndex);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	if (lineIndex < 0 || lineIndex >= (int32_t)lines.size())
+		throwError<RangeError>(kParamRangeError);
+
+	return abstract_i(lines[lineIndex].firstCharOffset);
+}
+
+ASFUNCTIONBODY(TextField,_getLineText)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t  lineIndex;
+	ARG_UNPACK(lineIndex);
+
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	if (lineIndex < 0 || lineIndex >= (int32_t)lines.size())
+		throwError<RangeError>(kParamRangeError);
+
+	tiny_string substr = th->text.substr(lines[lineIndex].firstCharOffset,
+					     lines[lineIndex].length);
+	return Class<ASString>::getInstanceS(substr);
+}
+
+ASFUNCTIONBODY(TextField,_getAntiAliasType)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	if (th->antiAliasType == AA_NORMAL)
+		return Class<ASString>::getInstanceS("normal");
+	else
+		return Class<ASString>::getInstanceS("advanced");
+}
+
+ASFUNCTIONBODY(TextField,_setAntiAliasType)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	tiny_string value;
+	ARG_UNPACK(value);
+
+	if (value == "advanced")
+	{
+		th->antiAliasType = AA_ADVANCED;
+		LOG(LOG_NOT_IMPLEMENTED, "TextField advanced antiAliasType not implemented");
+	}
+	else
+		th->antiAliasType = AA_NORMAL;
+
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(TextField,_getGridFitType)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	if (th->gridFitType == GF_NONE)
+		return Class<ASString>::getInstanceS("none");
+	else if (th->gridFitType == GF_PIXEL)
+		return Class<ASString>::getInstanceS("pixel");
+	else
+		return Class<ASString>::getInstanceS("subpixel");
+}
+
+ASFUNCTIONBODY(TextField,_setGridFitType)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	tiny_string value;
+	ARG_UNPACK(value);
+
+	if (value == "none")
+		th->gridFitType = GF_NONE;
+	else if (value == "pixel")
+		th->gridFitType = GF_PIXEL;
+	else
+		th->gridFitType = GF_SUBPIXEL;
+
+	LOG(LOG_NOT_IMPLEMENTED, "TextField gridFitType not implemented");
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(TextField,_getLength)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	return abstract_i(th->text.numChars());
+}
+
+ASFUNCTIONBODY(TextField,_getNumLines)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	return abstract_i(CairoPangoRenderer::getLineData(*th).size());
+}
+
+ASFUNCTIONBODY(TextField,_getMaxScrollH)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	return abstract_i(th->getMaxScrollH());
+}
+
+ASFUNCTIONBODY(TextField,_getMaxScrollV)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	return abstract_i(th->getMaxScrollV());
+}
+
+ASFUNCTIONBODY(TextField,_getBottomScrollV)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*th);
+	for (unsigned int k=0; k<lines.size()-1; k++)
+	{
+		if (lines[k+1].extents.Ymin >= (int)th->height)
+			return abstract_i(k + 1);
+	}
+
+	return abstract_i(lines.size() + 1);
+}
+
+ASFUNCTIONBODY(TextField,_getRestrict)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	if (th->restrictChars.isNull())
+		return NULL;
+	else
+	{
+		th->restrictChars->incRef();
+		return th->restrictChars.getPtr();
+	}
+}
+
+ASFUNCTIONBODY(TextField,_setRestrict)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	ARG_UNPACK(th->restrictChars);
+	if (!th->restrictChars.isNull())
+		LOG(LOG_NOT_IMPLEMENTED, "TextField restrict property");
+	return NULL;
+}
+
+ASFUNCTIONBODY(TextField,_getTextInteractionMode)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	if (th->textInteractionMode == TI_NORMAL)
+		return Class<ASString>::getInstanceS("normal");
+	else
+		return Class<ASString>::getInstanceS("selection");
+}
+
+ASFUNCTIONBODY(TextField,_setSelection)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	ARG_UNPACK(th->selectionBeginIndex) (th->selectionEndIndex);
+
+	if (th->selectionBeginIndex < 0)
+		th->selectionBeginIndex = 0;
+
+	if (th->selectionEndIndex >= (int32_t)th->text.numChars())
+		th->selectionEndIndex = th->text.numChars()-1;
+
+	if (th->selectionBeginIndex > th->selectionEndIndex)
+		th->selectionBeginIndex = th->selectionEndIndex;
+
+	if (th->selectionBeginIndex == th->selectionEndIndex)
+		th->caretIndex = th->selectionBeginIndex;
+
+	LOG(LOG_NOT_IMPLEMENTED, "TextField selection will not be rendered");
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(TextField,_replaceSelectedText)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	tiny_string newText;
+	ARG_UNPACK(newText);
+	th->replaceText(th->selectionBeginIndex, th->selectionEndIndex, newText);
+	return NULL;
+}
+
+ASFUNCTIONBODY(TextField,_replaceText)
+{
+	TextField* th=Class<TextField>::cast(obj);
+	int32_t begin;
+	int32_t end;
+	tiny_string newText;
+	ARG_UNPACK(begin) (end) (newText);
+	th->replaceText(begin, end, newText);
+	return NULL;
+}
+
+void TextField::replaceText(unsigned int begin, unsigned int end, const tiny_string& newText)
+{
+	if (!styleSheet.isNull())
+		throw Class<ASError>::getInstanceS("Can not replace text on text field with a style sheet");
+
+	if (begin >= text.numChars())
+	{
+		text = text + newText;
+	}
+	else if (begin > end)
+	{
+		return;
+	}
+	else if (end >= text.numChars())
+	{
+		text = text.substr(0, begin) + newText;
+	}
+	else
+	{
+		text = text.substr(0, begin) + newText + text.substr(end, text.end());
+	}
+
+	textUpdated();
+}
+
+void TextField::validateThickness(number_t /*oldValue*/)
+{
+	thickness = dmin(dmax(thickness, -200.), 200.);
+}
+
+void TextField::validateSharpness(number_t /*oldValue*/)
+{
+	sharpness = dmin(dmax(sharpness, -400.), 400.);
+}
+
+void TextField::validateScrollH(int32_t oldValue)
+{
+	int32_t maxScrollH = getMaxScrollH();
+	if (scrollH > maxScrollH)
+		scrollH = maxScrollH;
+
+	if (onStage && (scrollH != oldValue))
+		requestInvalidation(getSys());
+}
+
+void TextField::validateScrollV(int32_t oldValue)
+{
+	int32_t maxScrollV = getMaxScrollV();
+	if (scrollV < 1)
+		scrollV = 1;
+	else if (scrollV > maxScrollV)
+		scrollV = maxScrollV;
+
+	if (onStage && (scrollV != oldValue))
+		requestInvalidation(getSys());
+}
+
+int32_t TextField::getMaxScrollH()
+{
+	if (wordWrap || (textWidth <= width))
+		return 0;
+	else
+		return textWidth;
+}
+
+int32_t TextField::getMaxScrollV()
+{
+	std::vector<LineData> lines = CairoPangoRenderer::getLineData(*this);
+	if (lines.size() <= 1)
+		return 1;
+
+	int32_t Ymax = lines[lines.size()-1].extents.Ymax;
+	int32_t measuredTextHeight = Ymax - lines[0].extents.Ymin;
+	if (measuredTextHeight <= (int32_t)height)
+		return 1;
+
+	// one full page from the bottom
+	for (int k=(int)lines.size()-1; k>=0; k--)
+	{
+		if (Ymax - lines[k].extents.Ymin > (int32_t)height)
+		{
+			return imin(k+1+1, lines.size());
+		}
+	}
+
+	return 1;
 }
 
 void TextField::updateSizes()
@@ -461,12 +912,53 @@
 void TextField::setHtmlText(const tiny_string& html)
 {
 	HtmlTextParser parser;
-	parser.parseTextAndFormating(html, this);
+	if (condenseWhite)
+	{
+		tiny_string processedHtml = compactHTMLWhiteSpace(html);
+		parser.parseTextAndFormating(processedHtml, this);
+	}
+	else
+	{
+		parser.parseTextAndFormating(html, this);
+	}
+	textUpdated();
+}
+
+tiny_string TextField::compactHTMLWhiteSpace(const tiny_string& html)
+{
+	tiny_string compacted;
+	bool previousWasSpace = false;
+	for (CharIterator ch=html.begin(); ch!=html.end(); ++ch)
+	{
+		if (g_unichar_isspace(*ch))
+		{
+			if (!previousWasSpace)
+				compacted += ' ';
+			previousWasSpace = true;
+		}
+		else
+		{
+			compacted += *ch;
+			previousWasSpace = false;
+		}
+	}
+
+	return compacted;
 }
 
 void TextField::updateText(const tiny_string& new_text)
 {
 	text = new_text;
+	textUpdated();
+}
+
+void TextField::textUpdated()
+{
+	scrollH = 0;
+	scrollV = 1;
+	selectionBeginIndex = 0;
+	selectionEndIndex = 0;
+
 	if(onStage)
 		requestInvalidation(getSys());
 	else
@@ -647,8 +1139,9 @@
 	return (uint32_t)size;
 }
 
-void TextFieldAutoSize ::sinit(Class_base* c)
+void TextFieldAutoSize::sinit(Class_base* c)
 {
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("CENTER","",Class<ASString>::getInstanceS("center"),DECLARED_TRAIT);
 	c->setVariableByQName("LEFT","",Class<ASString>::getInstanceS("left"),DECLARED_TRAIT);
 	c->setVariableByQName("NONE","",Class<ASString>::getInstanceS("none"),DECLARED_TRAIT);
@@ -657,12 +1150,14 @@
 
 void TextFieldType::sinit(Class_base* c)
 {
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("DYNAMIC","",Class<ASString>::getInstanceS("dynamic"),DECLARED_TRAIT);
 	c->setVariableByQName("INPUT","",Class<ASString>::getInstanceS("input"),DECLARED_TRAIT);
 }
 
-void TextFormatAlign ::sinit(Class_base* c)
+void TextFormatAlign::sinit(Class_base* c)
 {
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("CENTER","",Class<ASString>::getInstanceS("center"),DECLARED_TRAIT);
 	c->setVariableByQName("END","",Class<ASString>::getInstanceS("end"),DECLARED_TRAIT);
 	c->setVariableByQName("JUSTIFY","",Class<ASString>::getInstanceS("justify"),DECLARED_TRAIT);
@@ -673,8 +1168,7 @@
 
 void TextFormat::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c,align);
 	REGISTER_GETTER_SETTER(c,blockIndent);
 	REGISTER_GETTER_SETTER(c,bold);
@@ -773,8 +1267,7 @@
 
 void StyleSheet::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<EventDispatcher>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, EventDispatcher, CLASS_DYNAMIC_NOT_FINAL);
 	c->setDeclaredMethodByQName("styleNames","",Class<IFunction>::getFunction(_getStyleNames),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("setStyle","",Class<IFunction>::getFunction(setStyle),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("getStyle","",Class<IFunction>::getFunction(getStyle),NORMAL_METHOD,true);
@@ -833,9 +1326,10 @@
 
 void StaticText::sinit(Class_base* c)
 {
-	//TODO: spec says that constructor should throw ArgumentError
-	c->setConstructor(NULL);
-	c->setSuper(Class<DisplayObject>::getRef());
+	// FIXME: the constructor should be
+	// _constructorNotInstantiatable but that breaks when
+	// DisplayObjectContainer::initFrame calls the constructor
+	CLASS_SETUP_NO_CONSTRUCTOR(c, DisplayObject, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("text","",Class<IFunction>::getFunction(_getText),GETTER_METHOD,true);
 }
 
@@ -847,8 +1341,7 @@
 
 void FontStyle::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("BOLD","",Class<ASString>::getInstanceS("bold"),DECLARED_TRAIT);
 	c->setVariableByQName("BOLD_ITALIC","",Class<ASString>::getInstanceS("boldItalic"),DECLARED_TRAIT);
 	c->setVariableByQName("ITALIC","",Class<ASString>::getInstanceS("italic"),DECLARED_TRAIT);
@@ -857,8 +1350,7 @@
 
 void FontType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("DEVICE","",Class<ASString>::getInstanceS("device"),DECLARED_TRAIT);
 	c->setVariableByQName("EMBEDDED","",Class<ASString>::getInstanceS("embedded"),DECLARED_TRAIT);
 	c->setVariableByQName("EMBEDDED_CFF","",Class<ASString>::getInstanceS("embeddedCFF"),DECLARED_TRAIT);
@@ -866,8 +1358,7 @@
 
 void TextDisplayMode::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("CRT","",Class<ASString>::getInstanceS("crt"),DECLARED_TRAIT);
 	c->setVariableByQName("DEFAULT","",Class<ASString>::getInstanceS("default"),DECLARED_TRAIT);
 	c->setVariableByQName("LCD","",Class<ASString>::getInstanceS("lcd"),DECLARED_TRAIT);
@@ -875,25 +1366,29 @@
 
 void TextColorType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("DARK_COLOR","",Class<ASString>::getInstanceS("dark"),DECLARED_TRAIT);
 	c->setVariableByQName("LIGHT_COLOR","",Class<ASString>::getInstanceS("light"),DECLARED_TRAIT);
 }
 
 void GridFitType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("NONE","",Class<ASString>::getInstanceS("none"),DECLARED_TRAIT);
 	c->setVariableByQName("PIXEL","",Class<ASString>::getInstanceS("pixel"),DECLARED_TRAIT);
 	c->setVariableByQName("SUBPIXEL","",Class<ASString>::getInstanceS("subpixel"),DECLARED_TRAIT);
 }
 
+void TextInteractionMode::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
+	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),DECLARED_TRAIT);
+	c->setVariableByQName("SELECTION","",Class<ASString>::getInstanceS("selection"),DECLARED_TRAIT);
+}
+
 void TextLineMetrics::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c, ascent);
 	REGISTER_GETTER_SETTER(c, descent);
 	REGISTER_GETTER_SETTER(c, height);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/text/flashtextengine.cpp lightspark-0.7.2/src/scripting/flash/text/flashtextengine.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/text/flashtextengine.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/text/flashtextengine.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -29,20 +29,12 @@
 
 void ContentElement::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-}
-
-ASFUNCTIONBODY(ContentElement, _constructor)
-{
-	throwError<ArgumentError>(kCantInstantiateError, "ContentElement");
-	return NULL;
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_SEALED);
 }
 
 void ElementFormat::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("GRAPHIC_ELEMENT","",abstract_ui(0xFDEF),CONSTANT_TRAIT);
 }
 
@@ -54,8 +46,7 @@
 
 void FontDescription::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 }
 
 ASFUNCTIONBODY(FontDescription, _constructor)
@@ -66,16 +57,14 @@
 
 void FontWeight::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("BOLD","",Class<ASString>::getInstanceS("bold"),CONSTANT_TRAIT);
 	c->setVariableByQName("NORMAL","",Class<ASString>::getInstanceS("normal"),CONSTANT_TRAIT);
 }
 
 void TextBlock::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("createTextLine","",Class<IFunction>::getFunction(createTextLine),NORMAL_METHOD,true);
 	REGISTER_GETTER_SETTER(c, content);
 }
@@ -120,8 +109,7 @@
 
 void TextElement::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ContentElement>::getRef());
+	CLASS_SETUP(c, ContentElement, _constructor, CLASS_FINAL | CLASS_SEALED);
 	REGISTER_GETTER_SETTER(c, text);
 }
 
@@ -156,8 +144,7 @@
 
 void TextLine::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<DisplayObjectContainer>::getRef());
+	CLASS_SETUP(c, DisplayObjectContainer, _constructor, CLASS_FINAL | CLASS_SEALED);
 	REGISTER_GETTER(c, textBlock);
 	c->setVariableByQName("MAX_LINE_WIDTH","",abstract_ui(MAX_LINE_WIDTH),CONSTANT_TRAIT);
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/text/flashtextengine.h lightspark-0.7.2/src/scripting/flash/text/flashtextengine.h
--- lightspark-0.7.2.orig/src/scripting/flash/text/flashtextengine.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/text/flashtextengine.h	2013-11-09 19:23:31.000000000 +0200
@@ -34,7 +34,6 @@
 public:
 	ContentElement(Class_base* c): ASObject(c) {};
 	static void sinit(Class_base* c);
-	ASFUNCTION(_constructor);
 };
 
 class ElementFormat: public ASObject
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/text/flashtext.h lightspark-0.7.2/src/scripting/flash/text/flashtext.h
--- lightspark-0.7.2.orig/src/scripting/flash/text/flashtext.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/text/flashtext.h	2013-11-09 19:23:31.000000000 +0200
@@ -52,6 +52,20 @@
 	ASPROPERTY_GETTER(tiny_string, fontType);
 };
 
+class StyleSheet: public EventDispatcher
+{
+private:
+	std::map<tiny_string, _R<ASObject> > styles;
+public:
+	StyleSheet(Class_base* c):EventDispatcher(c){}
+	void finalize();
+	ASFUNCTION(getStyle);
+	ASFUNCTION(setStyle);
+	ASFUNCTION(_getStyleNames);
+	static void sinit(Class_base* c);
+	static void buildTraits(ASObject* o);
+};
+
 class TextField: public InteractiveObject, public TextData
 {
 private:
@@ -73,7 +87,10 @@
 	};
 
 public:
-	enum EDIT_TYPE {READ_ONLY, EDITABLE};
+	enum EDIT_TYPE { ET_READ_ONLY, ET_EDITABLE };
+	enum ANTI_ALIAS_TYPE { AA_NORMAL, AA_ADVANCED };
+	enum GRID_FIT_TYPE { GF_NONE, GF_PIXEL, GF_SUBPIXEL };
+	enum TEXT_INTERACTION_MODE { TI_NORMAL, TI_SELECTION };
 private:
 	_NR<DisplayObject> hitTestImpl(_NR<DisplayObject> last, number_t x, number_t y, HIT_TYPE type);
 	void renderImpl(RenderContext& ctxt) const;
@@ -84,13 +101,33 @@
 	//Computes and changes (text)width and (text)height using Pango
 	void updateSizes();
 	tiny_string toHtmlText();
+	tiny_string compactHTMLWhiteSpace(const tiny_string&);
+	void validateThickness(number_t oldValue);
+	void validateSharpness(number_t oldValue);
+	void validateScrollH(int32_t oldValue);
+	void validateScrollV(int32_t oldValue);
+	int32_t getMaxScrollH();
+	int32_t getMaxScrollV();
+	void textUpdated();
+	void setSizeAndPositionFromAutoSize();
+	void replaceText(unsigned int begin, unsigned int end, const tiny_string& newText);
 	EDIT_TYPE type;
+	ANTI_ALIAS_TYPE antiAliasType;
+	GRID_FIT_TYPE gridFitType;
+	TEXT_INTERACTION_MODE textInteractionMode;
+        _NR<ASString> restrictChars;
 public:
 	TextField(Class_base* c, const TextData& textData=TextData(), bool _selectable=true, bool readOnly=true);
+	void finalize();
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
 	void setHtmlText(const tiny_string& html);
 	ASFUNCTION(appendText);
+	ASFUNCTION(_getAntiAliasType);
+	ASFUNCTION(_setAntiAliasType);
+	ASFUNCTION(_getGridFitType);
+	ASFUNCTION(_setGridFitType);
+	ASFUNCTION(_getLength);
 	ASFUNCTION(_getWidth);
 	ASFUNCTION(_setWidth);
 	ASFUNCTION(_getHeight);
@@ -109,16 +146,45 @@
 	ASFUNCTION(_setTextFormat);
 	ASFUNCTION(_getDefaultTextFormat);
 	ASFUNCTION(_setDefaultTextFormat);
+	ASFUNCTION(_getLineIndexAtPoint);
+	ASFUNCTION(_getLineIndexOfChar);
+	ASFUNCTION(_getLineLength);
 	ASFUNCTION(_getLineMetrics);
+	ASFUNCTION(_getLineOffset);
+	ASFUNCTION(_getLineText);
+	ASFUNCTION(_getNumLines);
+	ASFUNCTION(_getMaxScrollH);
+	ASFUNCTION(_getMaxScrollV);
+	ASFUNCTION(_getBottomScrollV);
+	ASFUNCTION(_getRestrict);
+	ASFUNCTION(_setRestrict);
+	ASFUNCTION(_getTextInteractionMode);
+	ASFUNCTION(_setSelection);
+	ASFUNCTION(_replaceText);
+	ASFUNCTION(_replaceSelectedText);
+	ASPROPERTY_GETTER_SETTER(bool, alwaysShowSelection);
 	ASFUNCTION_GETTER_SETTER(background);
 	ASFUNCTION_GETTER_SETTER(backgroundColor);
 	ASFUNCTION_GETTER_SETTER(border);
 	ASFUNCTION_GETTER_SETTER(borderColor);
+	ASPROPERTY_GETTER(int32_t, caretIndex);
+	ASPROPERTY_GETTER_SETTER(bool, condenseWhite);
+	ASPROPERTY_GETTER_SETTER(bool, displayAsPassword);
+	ASPROPERTY_GETTER_SETTER(bool, embedFonts);
+	ASPROPERTY_GETTER_SETTER(int32_t, maxChars);
 	ASFUNCTION_GETTER_SETTER(multiline);
 	ASPROPERTY_GETTER_SETTER(bool, mouseWheelEnabled);
+	ASFUNCTION_GETTER_SETTER(scrollH);
+	ASFUNCTION_GETTER_SETTER(scrollV);
 	ASPROPERTY_GETTER_SETTER(bool, selectable);
+	ASPROPERTY_GETTER(int32_t, selectionBeginIndex);
+	ASPROPERTY_GETTER(int32_t, selectionEndIndex);
+	ASPROPERTY_GETTER_SETTER(number_t, sharpness);
+	ASPROPERTY_GETTER_SETTER(_NR<StyleSheet>, styleSheet);
 	ASFUNCTION_GETTER_SETTER(textColor);
+	ASPROPERTY_GETTER_SETTER(number_t, thickness);
 	ASFUNCTION_GETTER_SETTER(type);
+	ASPROPERTY_GETTER_SETTER(bool, useRichTextClipboard);
 };
 
 class TextFormat: public ASObject
@@ -172,20 +238,6 @@
 	static void sinit(Class_base* c);
 };
 
-class StyleSheet: public EventDispatcher
-{
-private:
-	std::map<tiny_string, _R<ASObject> > styles;
-public:
-	StyleSheet(Class_base* c):EventDispatcher(c){}
-	void finalize();
-	ASFUNCTION(getStyle);
-	ASFUNCTION(setStyle);
-	ASFUNCTION(_getStyleNames);
-	static void sinit(Class_base* c);
-	static void buildTraits(ASObject* o);
-};
-
 class StaticText: public DisplayObject, public TokenContainer
 {
 private:
@@ -242,6 +294,13 @@
 	static void sinit(Class_base* c);
 };
 
+class TextInteractionMode: public ASObject
+{
+public:
+	TextInteractionMode(Class_base* c):ASObject(c){}
+	static void sinit(Class_base* c);
+};
+
 class TextLineMetrics : public ASObject
 {
 protected:
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/ui/Keyboard.cpp lightspark-0.7.2/src/scripting/flash/ui/Keyboard.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/ui/Keyboard.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/ui/Keyboard.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -27,8 +27,7 @@
 
 void Keyboard::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("capsLock","",Class<IFunction>::getFunction(capsLock),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("hasVirtualKeyboard","",Class<IFunction>::getFunction(hasVirtualKeyboard),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("numLock","",Class<IFunction>::getFunction(numLock),GETTER_METHOD,true);
@@ -76,8 +75,7 @@
 
 void KeyboardType::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("ALPHANUMERIC","",Class<ASString>::getInstanceS("alphanumeric"),DECLARED_TRAIT);
 	c->setVariableByQName("KEYPAD","",Class<ASString>::getInstanceS("keypad"),DECLARED_TRAIT);
 	c->setVariableByQName("NONE","",Class<ASString>::getInstanceS("none"),DECLARED_TRAIT);
@@ -85,8 +83,7 @@
 
 void KeyLocation::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_FINAL | CLASS_SEALED);
 	c->setVariableByQName("LEFT","",Class<UInteger>::getInstanceS(1),DECLARED_TRAIT);
 	c->setVariableByQName("NUM_PAD","",Class<UInteger>::getInstanceS(3),DECLARED_TRAIT);
 	c->setVariableByQName("RIGHT","",Class<UInteger>::getInstanceS(2),DECLARED_TRAIT);
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/ui/Mouse.cpp lightspark-0.7.2/src/scripting/flash/ui/Mouse.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/ui/Mouse.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/ui/Mouse.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,75 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/flash/ui/Mouse.h"
+#include "scripting/toplevel/ASString.h"
+#include "scripting/toplevel/Error.h"
+#include "scripting/class.h"
+#include "scripting/argconv.h"
+#include "swf.h"
+
+using namespace std;
+using namespace lightspark;
+
+void Mouse::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructorNotInstantiatable, CLASS_FINAL | CLASS_SEALED);
+	c->setDeclaredMethodByQName("hide","",Class<IFunction>::getFunction(hide),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("show","",Class<IFunction>::getFunction(show),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("cursor","",Class<IFunction>::getFunction(getCursor),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("cursor","",Class<IFunction>::getFunction(setCursor),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("supportsCursor","",Class<IFunction>::getFunction(getSupportsCursor),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("supportsNativeCursor","",Class<IFunction>::getFunction(getSupportsNativeCursor),GETTER_METHOD,false);
+}
+
+ASFUNCTIONBODY(Mouse, hide)
+{
+	getSys()->showMouseCursor(false);
+	return NULL;
+}
+
+ASFUNCTIONBODY(Mouse, show)
+{
+	getSys()->showMouseCursor(true);
+	return NULL;
+}
+
+ASFUNCTIONBODY(Mouse, getCursor)
+{
+	return Class<ASString>::getInstanceS("auto");
+}
+
+ASFUNCTIONBODY(Mouse, setCursor)
+{
+	tiny_string cursorName;
+	ARG_UNPACK(cursorName);
+	if (cursorName != "auto")
+		throwError<ArgumentError>(kInvalidEnumError, "cursor");
+	return NULL;
+}
+
+ASFUNCTIONBODY(Mouse, getSupportsCursor)
+{
+	return abstract_b(true);
+}
+
+ASFUNCTIONBODY(Mouse, getSupportsNativeCursor)
+{
+	return abstract_b(false); // until registerCursor() is implemented
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/ui/Mouse.h lightspark-0.7.2/src/scripting/flash/ui/Mouse.h
--- lightspark-0.7.2.orig/src/scripting/flash/ui/Mouse.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/ui/Mouse.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,43 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2013  Antti Ajanki (antti.ajanki@iki.fi)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UI_MOUSE_H
+#define SCRIPTING_FLASH_UI_MOUSE_H 1
+
+#include "asobject.h"
+
+namespace lightspark
+{
+
+class Mouse : public ASObject
+{
+public:
+	Mouse(Class_base* c):ASObject(c){}
+	static void sinit(Class_base* c);
+	ASFUNCTION(hide);
+	ASFUNCTION(show);
+	ASFUNCTION(getCursor);
+	ASFUNCTION(setCursor);
+	ASFUNCTION(getSupportsCursor);
+	ASFUNCTION(getSupportsNativeCursor);
+};
+
+};
+
+#endif /* SCRIPTING_FLASH_UI_MOUSE_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/ByteArray.cpp lightspark-0.7.2/src/scripting/flash/utils/ByteArray.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/ByteArray.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/ByteArray.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,1383 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "scripting/flash/utils/flashutils.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+#include <sstream>
+#include <zlib.h>
+#include <glib.h>
+
+using namespace std;
+using namespace lightspark;
+
+#define BA_CHUNK_SIZE 4096
+
+
+ByteArray::ByteArray(Class_base* c, uint8_t* b, uint32_t l):ASObject(c),littleEndian(false),objectEncoding(ObjectEncoding::AMF3),
+	position(0),bytes(b),real_len(l),len(l),shareable(false)
+{
+#ifdef MEMORY_USAGE_PROFILING
+	c->memoryAccount->addBytes(l);
+#endif
+}
+
+ByteArray::~ByteArray()
+{
+	if(bytes)
+	{
+#ifdef MEMORY_USAGE_PROFILING
+		getClass()->memoryAccount->removeBytes(real_len);
+#endif
+		free(bytes);
+	}
+}
+
+void ByteArray::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED);
+	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_getLength),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_setLength),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("bytesAvailable","",Class<IFunction>::getFunction(_getBytesAvailable),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("position","",Class<IFunction>::getFunction(_getPosition),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("position","",Class<IFunction>::getFunction(_setPosition),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("endian","",Class<IFunction>::getFunction(_getEndian),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("endian","",Class<IFunction>::getFunction(_setEndian),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_getObjectEncoding),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_setObjectEncoding),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("defaultObjectEncoding","",Class<IFunction>::getFunction(_getDefaultObjectEncoding),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("defaultObjectEncoding","",Class<IFunction>::getFunction(_setDefaultObjectEncoding),SETTER_METHOD,false);
+
+	getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::DEFAULT;
+	c->setDeclaredMethodByQName("clear","",Class<IFunction>::getFunction(clear),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("compress","",Class<IFunction>::getFunction(_compress),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("uncompress","",Class<IFunction>::getFunction(_uncompress),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("deflate","",Class<IFunction>::getFunction(_deflate),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("inflate","",Class<IFunction>::getFunction(_inflate),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readBoolean","",Class<IFunction>::getFunction(readBoolean),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readBytes","",Class<IFunction>::getFunction(readBytes),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readByte","",Class<IFunction>::getFunction(readByte),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readDouble","",Class<IFunction>::getFunction(readDouble),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readFloat","",Class<IFunction>::getFunction(readFloat),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readInt","",Class<IFunction>::getFunction(readInt),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readMultiByte","",Class<IFunction>::getFunction(readMultiByte),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readShort","",Class<IFunction>::getFunction(readShort),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readUnsignedByte","",Class<IFunction>::getFunction(readUnsignedByte),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readUnsignedInt","",Class<IFunction>::getFunction(readUnsignedInt),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readUnsignedShort","",Class<IFunction>::getFunction(readUnsignedShort),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readObject","",Class<IFunction>::getFunction(readObject),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readUTF","",Class<IFunction>::getFunction(readUTF),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("readUTFBytes","",Class<IFunction>::getFunction(readUTFBytes),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeBoolean","",Class<IFunction>::getFunction(writeBoolean),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeUTF","",Class<IFunction>::getFunction(writeUTF),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeUTFBytes","",Class<IFunction>::getFunction(writeUTFBytes),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeBytes","",Class<IFunction>::getFunction(writeBytes),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeByte","",Class<IFunction>::getFunction(writeByte),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeDouble","",Class<IFunction>::getFunction(writeDouble),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeFloat","",Class<IFunction>::getFunction(writeFloat),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeInt","",Class<IFunction>::getFunction(writeInt),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeMultiByte","",Class<IFunction>::getFunction(writeMultiByte),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeUnsignedInt","",Class<IFunction>::getFunction(writeUnsignedInt),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeObject","",Class<IFunction>::getFunction(writeObject),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("writeShort","",Class<IFunction>::getFunction(writeShort),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(ByteArray::_toString),DYNAMIC_TRAIT);
+	REGISTER_GETTER_SETTER(c,shareable);
+	c->setDeclaredMethodByQName("atomicCompareAndSwapIntAt","",Class<IFunction>::getFunction(atomicCompareAndSwapIntAt),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("atomicCompareAndSwapLength","",Class<IFunction>::getFunction(atomicCompareAndSwapLength),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("toJSON",AS3,Class<IFunction>::getFunction(_toJSON),NORMAL_METHOD,true);
+
+	c->addImplementedInterface(InterfaceClass<IDataInput>::getClass());
+	IDataInput::linkTraits(c);
+	c->addImplementedInterface(InterfaceClass<IDataOutput>::getClass());
+	IDataOutput::linkTraits(c);
+}
+
+void ByteArray::buildTraits(ASObject* o)
+{
+}
+
+void ByteArray::lock()
+{
+	if (shareable) mutex.lock();
+}
+void ByteArray::unlock()
+{
+	if (shareable) mutex.unlock();
+}
+
+uint8_t* ByteArray::getBuffer(unsigned int size, bool enableResize)
+{
+	// the flash documentation doesn't tell how large ByteArrays are allowed to be
+	// so we simply don't allow bytearrays larger than 1GiB
+	// maybe we should set this smaller
+	if (size > 0x4000000) 
+		throwError<ASError>(kOutOfMemoryError);
+	// The first allocation is exactly the size we need,
+	// the subsequent reallocations happen in increments of BA_CHUNK_SIZE bytes
+	uint32_t prevLen = len;
+	if(bytes==NULL)
+	{
+		len=size;
+		real_len=len;
+		bytes = (uint8_t*) malloc(len);
+#ifdef MEMORY_USAGE_PROFILING
+		getClass()->memoryAccount->addBytes(len);
+#endif
+	}
+	else if(enableResize==false)
+	{
+		assert_and_throw(size<=len);
+	}
+	else if(real_len<size) // && enableResize==true
+	{
+#ifdef MEMORY_USAGE_PROFILING
+		uint32_t prev_real_len = real_len;
+#endif
+		while(real_len < size)
+			real_len += BA_CHUNK_SIZE;
+		// Reallocate the buffer, in chunks of BA_CHUNK_SIZE bytes
+		uint8_t* bytes2 = (uint8_t*) realloc(bytes, real_len);
+#ifdef MEMORY_USAGE_PROFILING
+		getClass()->memoryAccount->addBytes(real_len-prev_real_len);
+#endif
+		assert_and_throw(bytes2);
+		bytes = bytes2;
+		len=size;
+		bytes=bytes2;
+	}
+	else if(len<size)
+	{
+		len=size;
+	}
+	if(prevLen<size)
+	{
+		//Extend
+		memset(bytes+prevLen,0,size-prevLen);
+	}
+	return bytes;
+}
+
+uint16_t ByteArray::endianIn(uint16_t value)
+{
+	if(littleEndian)
+		return GUINT16_TO_LE(value);
+	else
+		return GUINT16_TO_BE(value);
+}
+
+uint32_t ByteArray::endianIn(uint32_t value)
+{
+	if(littleEndian)
+		return GUINT32_TO_LE(value);
+	else
+		return GUINT32_TO_BE(value);
+}
+
+uint64_t ByteArray::endianIn(uint64_t value)
+{
+	if(littleEndian)
+		return GUINT64_TO_LE(value);
+	else
+		return GUINT64_TO_BE(value);
+}
+
+uint16_t ByteArray::endianOut(uint16_t value)
+{
+	if(littleEndian)
+		return GUINT16_FROM_LE(value);
+	else
+		return GUINT16_FROM_BE(value);
+}
+
+uint32_t ByteArray::endianOut(uint32_t value)
+{
+	if(littleEndian)
+		return GUINT32_FROM_LE(value);
+	else
+		return GUINT32_FROM_BE(value);
+}
+
+uint64_t ByteArray::endianOut(uint64_t value)
+{
+	if(littleEndian)
+		return GUINT64_FROM_LE(value);
+	else
+		return GUINT64_FROM_BE(value);
+}
+
+uint32_t ByteArray::getPosition() const
+{
+	return position;
+}
+
+ASFUNCTIONBODY(ByteArray,_getPosition)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	return abstract_i(th->getPosition());
+}
+
+void ByteArray::setPosition(uint32_t p)
+{
+	lock();
+	position=p;
+	unlock();
+}
+
+ASFUNCTIONBODY(ByteArray,_setPosition)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint32_t pos=args[0]->toUInt();
+	th->setPosition(pos);
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_getEndian)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	if(th->littleEndian)
+		return Class<ASString>::getInstanceS(Endian::littleEndian);
+	else
+		return Class<ASString>::getInstanceS(Endian::bigEndian);
+}
+
+ASFUNCTIONBODY(ByteArray,_setEndian)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	if(args[0]->toString() == Endian::littleEndian)
+		th->littleEndian = true;
+	else if(args[0]->toString() == Endian::bigEndian)
+		th->littleEndian = false;
+	else
+		throwError<ArgumentError>(kInvalidEnumError, "endian");
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_getObjectEncoding)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	return abstract_ui(th->objectEncoding);
+}
+
+ASFUNCTIONBODY(ByteArray,_setObjectEncoding)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint32_t value;
+	ARG_UNPACK(value);
+	if(value!=ObjectEncoding::AMF0 && value!=ObjectEncoding::AMF3)
+		throwError<ArgumentError>(kInvalidEnumError, "objectEncoding");
+
+	th->objectEncoding=value;
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_getDefaultObjectEncoding)
+{
+	return abstract_i(getSys()->staticNetConnectionDefaultObjectEncoding);
+}
+
+ASFUNCTIONBODY(ByteArray,_setDefaultObjectEncoding)
+{
+	assert_and_throw(argslen == 1);
+	int32_t value = args[0]->toInt();
+	if(value == 0)
+		getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::AMF0;
+	else if(value == 3)
+		getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::AMF3;
+	else
+		throw RunTimeException("Invalid object encoding");
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_setLength)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	uint32_t newLen=args[0]->toInt();
+	th->lock();
+	if(newLen==th->len) //Nothing to do
+		return NULL;
+	th->setLength(newLen);
+	th->unlock();
+	return NULL;
+}
+void ByteArray::setLength(uint32_t newLen)
+{
+	if (newLen > 0)
+	{
+		getBuffer(newLen,true);
+	}
+	else
+	{
+		if (bytes)
+		{
+#ifdef MEMORY_USAGE_PROFILING
+			getClass()->memoryAccount->removeBytes(th->real_len);
+#endif
+			free(bytes);
+		}
+		bytes = NULL;
+		real_len = newLen;
+	}
+	len = newLen;
+	if (position > len)
+		position = (len > 0 ? len-1 : 0);
+}
+ASFUNCTIONBODY(ByteArray,_getLength)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	return abstract_i(th->len);
+}
+
+ASFUNCTIONBODY(ByteArray,_getBytesAvailable)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	return abstract_i(th->len-th->position);
+}
+
+ASFUNCTIONBODY(ByteArray,readBoolean)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+
+	th->lock();
+	uint8_t ret;
+	if(!th->readByte(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	th->unlock();
+	return abstract_b(ret!=0);
+}
+
+ASFUNCTIONBODY(ByteArray,readBytes)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	_NR<ByteArray> out;
+	uint32_t offset;
+	uint32_t length;
+	ARG_UNPACK(out)(offset, 0)(length, 0);
+	
+	th->lock();
+	if(length == 0)
+	{
+		assert(th->len >= th->position);
+		length = th->len - th->position;
+	}
+
+	//Error checks
+	if(th->position+length > th->len)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+	if((uint64_t)length+offset > 0xFFFFFFFF)
+	{
+		th->unlock();
+		throw Class<RangeError>::getInstanceS("length+offset");
+	}
+	
+	uint8_t* buf=out->getBuffer(length+offset,true);
+	memcpy(buf+offset,th->bytes+th->position,length);
+	th->position+=length;
+	th->unlock();
+
+	return NULL;
+}
+
+bool ByteArray::readUTF(tiny_string& ret)
+{
+	uint16_t stringLen;
+	if(!readShort(stringLen))
+		return false;
+	if(len < (position+stringLen))
+		return false;
+	//Very inefficient copy
+	//TODO: optmize
+	ret=string((char*)bytes+position, (size_t)stringLen);
+	position+=stringLen;
+	return true;
+}
+
+ASFUNCTIONBODY(ByteArray,readUTF)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+
+	tiny_string res;
+	th->lock();
+	if (!th->readUTF(res))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+	th->unlock();
+	return Class<ASString>::getInstanceS(res);
+}
+
+ASFUNCTIONBODY(ByteArray,readUTFBytes)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint32_t length;
+
+	ARG_UNPACK (length);
+	th->lock();
+	if(th->position+length > th->len)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	uint8_t *bufStart=th->bytes+th->position;
+	th->position+=length;
+	th->unlock();
+	return Class<ASString>::getInstanceS((char *)bufStart,length);
+}
+
+void ByteArray::writeUTF(const tiny_string& str)
+{
+	getBuffer(position+str.numBytes()+2,true);
+	if(str.numBytes() > 65535)
+	{
+		throwError<RangeError>(kParamRangeError);
+	}
+	uint16_t numBytes=endianIn((uint16_t)str.numBytes());
+	memcpy(bytes+position,&numBytes,2);
+	memcpy(bytes+position+2,str.raw_buf(),str.numBytes());
+	position+=str.numBytes()+2;
+}
+
+ASFUNCTIONBODY(ByteArray,writeUTF)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	//Validate parameters
+	assert_and_throw(argslen==1);
+	assert_and_throw(args[0]->getObjectType()==T_STRING);
+	ASString* str=Class<ASString>::cast(args[0]);
+	th->lock();
+	th->writeUTF(str->data);
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeUTFBytes)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	//Validate parameters
+	assert_and_throw(argslen==1);
+	assert_and_throw(args[0]->getObjectType()==T_STRING);
+	ASString* str=Class<ASString>::cast(args[0]);
+	th->lock();
+	th->getBuffer(th->position+str->data.numBytes(),true);
+	memcpy(th->bytes+th->position,str->data.raw_buf(),str->data.numBytes());
+	th->position+=str->data.numBytes();
+	th->unlock();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeMultiByte)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	tiny_string value;
+	tiny_string charset;
+	ARG_UNPACK(value)(charset);
+
+	// TODO: should convert from UTF-8 to charset
+	LOG(LOG_NOT_IMPLEMENTED, "ByteArray.writeMultiByte doesn't convert charset");
+
+	th->lock();
+	th->getBuffer(th->position+value.numBytes(),true);
+	memcpy(th->bytes+th->position,value.raw_buf(),value.numBytes());
+	th->position+=value.numBytes();
+	th->unlock();
+
+	return NULL;
+}
+
+uint32_t ByteArray::writeObject(ASObject* obj)
+{
+	//Return the length of the serialized object
+
+	//TODO: support AMF0
+	assert_and_throw(objectEncoding==ObjectEncoding::AMF3);
+	//TODO: support custom serialization
+	map<tiny_string, uint32_t> stringMap;
+	map<const ASObject*, uint32_t> objMap;
+	map<const Class_base*, uint32_t> traitsMap;
+	uint32_t oldPosition=position;
+	obj->serialize(this, stringMap, objMap,traitsMap);
+	return position-oldPosition;
+}
+
+ASFUNCTIONBODY(ByteArray,writeObject)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	//Validate parameters
+	assert_and_throw(argslen==1);
+	th->lock();
+	th->writeObject(args[0]);
+	th->unlock();
+
+	return NULL;
+}
+
+void ByteArray::writeShort(uint16_t val)
+{
+	int16_t value2 = endianIn(val);
+	getBuffer(position+2,true);
+	memcpy(bytes+position,&value2,2);
+	position+=2;
+}
+
+ASFUNCTIONBODY(ByteArray,writeShort)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	int32_t value;
+	ARG_UNPACK(value);
+
+	th->lock();
+	th->writeShort((static_cast<uint16_t>(value & 0xffff)));
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeBytes)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	//Validate parameters
+	assert_and_throw(argslen>=1 && argslen<=3);
+	assert_and_throw(args[0]->getClass()->isSubClass(Class<ByteArray>::getClass()));
+	ByteArray* out=Class<ByteArray>::cast(args[0]);
+	uint32_t offset=0;
+	uint32_t length=0;
+	if(argslen>=2)
+		offset=args[1]->toUInt();
+	if(argslen==3)
+		length=args[2]->toUInt();
+
+	// We need to clamp offset to the beginning of the bytes array
+	if(offset > out->getLength()-1)
+		offset = 0;
+	// We need to clamp length to the end of the bytes array
+	if(length > out->getLength()-offset)
+		length = 0;
+
+	//If the length is 0 the whole buffer must be copied
+	if(length == 0)
+		length=(out->getLength()-offset);
+	uint8_t* buf=out->getBuffer(offset+length,false);
+	th->lock();
+	th->getBuffer(th->position+length,true);
+	memcpy(th->bytes+th->position,buf+offset,length);
+	th->position+=length;
+	th->unlock();
+
+	return NULL;
+}
+
+void ByteArray::writeByte(uint8_t b)
+{
+	getBuffer(position+1,true);
+	bytes[position++] = b;
+}
+
+ASFUNCTIONBODY(ByteArray,writeByte)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	int32_t value=args[0]->toInt();
+
+	th->lock();
+	th->writeByte(value&0xff);
+	th->unlock();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeBoolean)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	bool b;
+	ARG_UNPACK (b);
+
+	th->lock();
+	if (b)
+		th->writeByte(1);
+	else
+		th->writeByte(0);
+	th->unlock();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeDouble)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	double value = args[0]->toNumber();
+	uint64_t *intptr=reinterpret_cast<uint64_t*>(&value);
+	uint64_t value2=th->endianIn(*intptr);
+
+	th->lock();
+	th->getBuffer(th->position+8,true);
+	memcpy(th->bytes+th->position,&value2,8);
+	th->position+=8;
+	th->unlock();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeFloat)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	float value = args[0]->toNumber();
+	uint32_t *intptr=reinterpret_cast<uint32_t*>(&value);
+	uint32_t value2=th->endianIn(*intptr);
+
+	th->lock();
+	th->getBuffer(th->position+4,true);
+	memcpy(th->bytes+th->position,&value2,4);
+	th->position+=4;
+	th->unlock();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,writeInt)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	uint32_t value=th->endianIn(static_cast<uint32_t>(args[0]->toInt()));
+
+	th->lock();
+	th->getBuffer(th->position+4,true);
+	memcpy(th->bytes+th->position,&value,4);
+	th->position+=4;
+	th->unlock();
+
+	return NULL;
+}
+
+void ByteArray::writeUnsignedInt(uint32_t val)
+{
+	getBuffer(position+4,true);
+	memcpy(bytes+position,&val,4);
+	position+=4;
+}
+
+ASFUNCTIONBODY(ByteArray,writeUnsignedInt)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==1);
+
+	th->lock();
+	uint32_t value=th->endianIn(args[0]->toUInt());
+	th->writeUnsignedInt(value);
+	th->unlock();
+	return NULL;
+}
+
+bool ByteArray::readByte(uint8_t& b)
+{
+	if (len <= position)
+		return false;
+
+	b=bytes[position++];
+	return true;
+}
+
+bool ByteArray::readU29(uint32_t& ret)
+{
+	//Be careful! This is different from u32 parsing.
+	//Here the most significant bits appears before in the stream!
+	ret=0;
+	for(uint32_t i=0;i<4;i++)
+	{
+		if (len <= position)
+			return false;
+
+		uint8_t tmp=bytes[position++];
+		ret <<= 7;
+		if(i<3)
+		{
+			ret |= tmp&0x7f;
+			if((tmp&0x80)==0)
+				break;
+		}
+		else
+		{
+			ret |= tmp;
+			//Sign extend
+			if(tmp&0x80)
+				ret|=0xe0000000;
+		}
+	}
+	return true;
+}
+
+ASFUNCTIONBODY(ByteArray, readByte)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	th->lock();
+	uint8_t ret;
+	if(!th->readByte(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+	th->unlock();
+	return abstract_i((int8_t)ret);
+}
+
+ASFUNCTIONBODY(ByteArray,readDouble)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	th->lock();
+	if(th->len < th->position+8)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	uint64_t ret;
+	memcpy(&ret,th->bytes+th->position,8);
+	th->position+=8;
+	ret = th->endianOut(ret);
+
+	double *doubleptr=reinterpret_cast<double*>(&ret);
+	th->unlock();
+	return abstract_d(*doubleptr);
+}
+
+ASFUNCTIONBODY(ByteArray,readFloat)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	th->lock();
+	if(th->len < th->position+4)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	uint32_t ret;
+	memcpy(&ret,th->bytes+th->position,4);
+	th->position+=4;
+	ret = th->endianOut(ret);
+
+	float *floatptr=reinterpret_cast<float*>(&ret);
+	th->unlock();
+	return abstract_d(*floatptr);
+}
+
+ASFUNCTIONBODY(ByteArray,readInt)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	th->lock();
+	if(th->len < th->position+4)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	uint32_t ret;
+	memcpy(&ret,th->bytes+th->position,4);
+	th->position+=4;
+	th->unlock();
+	return abstract_i((int32_t)th->endianOut(ret));
+}
+
+bool ByteArray::readShort(uint16_t& ret)
+{
+	if (len < position+2)
+		return false;
+
+	uint16_t tmp;
+	memcpy(&tmp,bytes+position,2);
+	ret=endianOut(tmp);
+	position+=2;
+	return true;
+}
+
+ASFUNCTIONBODY(ByteArray,readShort)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	uint16_t ret;
+	th->lock();
+	if(!th->readShort(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	th->unlock();
+	return abstract_i((int16_t)ret);
+}
+
+ASFUNCTIONBODY(ByteArray,readUnsignedByte)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	uint8_t ret;
+	th->lock();
+	if (!th->readByte(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+	return abstract_ui(ret);
+}
+
+bool ByteArray::readUnsignedInt(uint32_t& ret)
+{
+	if(len < position+4)
+		return false;
+
+	uint32_t tmp;
+	memcpy(&tmp,bytes+position,4);
+	ret=endianOut(tmp);
+	position+=4;
+	return true;
+}
+
+ASFUNCTIONBODY(ByteArray,readUnsignedInt)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	uint32_t ret;
+	th->lock();
+	if(!th->readUnsignedInt(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+	th->unlock();
+	return abstract_ui(ret);
+}
+
+ASFUNCTIONBODY(ByteArray,readUnsignedShort)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+
+	uint16_t ret;
+	th->lock();
+	if(!th->readShort(ret))
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	return abstract_ui(ret);
+}
+
+ASFUNCTIONBODY(ByteArray,readMultiByte)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint32_t strlen;
+	tiny_string charset;
+	ARG_UNPACK(strlen)(charset);
+
+	th->lock();
+	if(th->len < th->position+strlen)
+	{
+		th->unlock();
+		throwError<EOFError>(kEOFError);
+	}
+
+	// TODO: should convert from charset to UTF-8
+	LOG(LOG_NOT_IMPLEMENTED, "ByteArray.readMultiByte doesn't convert charset");
+	return Class<ASString>::getInstanceS((char*)th->bytes+th->position,strlen);
+}
+
+ASFUNCTIONBODY(ByteArray,readObject)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	assert_and_throw(argslen==0);
+	th->lock();
+	if(th->bytes==NULL)
+	{
+		th->unlock();
+		// it seems that contrary to the specs Adobe returns Undefined when reading from an empty ByteArray
+		return getSys()->getUndefinedRef();
+		//throwError<EOFError>(kEOFError);
+	}
+	assert_and_throw(th->objectEncoding==ObjectEncoding::AMF3);
+	Amf3Deserializer d(th);
+	_NR<ASObject> ret(NullRef);
+	try
+	{
+		ret=d.readObject();
+		th->unlock();
+	}
+	catch(LightsparkException& e)
+	{
+		th->unlock();
+		LOG(LOG_ERROR,"Exception caught while parsing AMF3: " << e.cause);
+		//TODO: throw AS exception
+	}
+
+	if(ret.isNull())
+	{
+		LOG(LOG_ERROR,"No objects in the AMF3 data. Returning Undefined");
+		return getSys()->getUndefinedRef();
+	}
+	ret->incRef();
+	return ret.getPtr();
+}
+
+ASFUNCTIONBODY(ByteArray,_toString)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	//TODO: check for Byte Order Mark
+	return Class<ASString>::getInstanceS((char*)th->bytes,th->len);
+}
+
+bool ByteArray::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
+{
+	if(considerDynamic==false)
+		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
+
+	unsigned int index=0;
+	if(!Array::isValidMultiname(name,index))
+		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
+
+	return index<len;
+}
+
+_NR<ASObject> ByteArray::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
+{
+	assert_and_throw(implEnable);
+	unsigned int index=0;
+	if((opt & ASObject::SKIP_IMPL)!=0 || !Array::isValidMultiname(name,index))
+		return ASObject::getVariableByMultiname(name,opt);
+
+	if(index<len)
+	{
+		uint8_t value = bytes[index];
+		return _MNR(abstract_ui(static_cast<uint32_t>(value)));
+	}
+	else
+		return _MNR(getSys()->getUndefinedRef());
+}
+
+int32_t ByteArray::getVariableByMultiname_i(const multiname& name)
+{
+	assert_and_throw(implEnable);
+	unsigned int index=0;
+	if(!Array::isValidMultiname(name,index))
+		return ASObject::getVariableByMultiname_i(name);
+
+	if(index<len)
+	{
+		uint8_t value = bytes[index];
+		return static_cast<uint32_t>(value);
+	}
+	else
+		return _MNR(getSys()->getUndefinedRef());
+}
+
+void ByteArray::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
+{
+	assert_and_throw(implEnable);
+	unsigned int index=0;
+	if(!Array::isValidMultiname(name,index))
+		return ASObject::setVariableByMultiname(name,o,allowConst);
+
+	if(index>=len)
+	{
+		uint32_t prevLen = len;
+		getBuffer(index+1, true);
+		// Fill the gap between the end of the current data and the index with zeros
+		memset(bytes+prevLen, 0, index-prevLen);
+	}
+
+	// Fill the byte pointed to by index with the truncated uint value of the object.
+	uint8_t value = static_cast<uint8_t>(o->toUInt() & 0xff);
+	bytes[index] = value;
+
+	o->decRef();
+}
+
+void ByteArray::setVariableByMultiname_i(const multiname& name, int32_t value)
+{
+	setVariableByMultiname(name, abstract_i(value),ASObject::CONST_NOT_ALLOWED);
+}
+
+void ByteArray::acquireBuffer(uint8_t* buf, int bufLen)
+{
+	if(bytes)
+	{
+#ifdef MEMORY_USAGE_PROFILING
+		getClass()->memoryAccount->removeBytes(real_len);
+#endif
+		free(bytes);
+	}
+	bytes=buf;
+	real_len=bufLen;
+	len=bufLen;
+#ifdef MEMORY_USAGE_PROFILING
+	getClass()->memoryAccount->addBytes(real_len);
+#endif
+	position=0;
+}
+
+void ByteArray::writeU29(uint32_t val)
+{
+	for(uint32_t i=0;i<4;i++)
+	{
+		uint8_t b;
+		if(i<3)
+		{
+			uint32_t tmp=(val >> ((3-i)*7));
+			if(tmp==0)
+				continue;
+
+			b=(tmp&0x7f)|0x80;
+		}
+		else
+			b=val&0x7f;
+
+		writeByte(b);
+	}
+}
+
+void ByteArray::writeStringVR(map<tiny_string, uint32_t>& stringMap, const tiny_string& s)
+{
+	const uint32_t len=s.numBytes();
+	if(len >= 1<<28)
+		throwError<RangeError>(kParamRangeError);
+
+	//Check if the string is already in the map
+	auto it=stringMap.find(s);
+	if(it!=stringMap.end())
+	{
+		//The first bit must be 0, the next 29 bits
+		//store the index of the string in the map
+		writeU29(it->second << 1);
+	}
+	else
+	{
+		//The AMF3 spec says that the empty string is never sent by reference
+		//So add the string to the map only if it's not the empty string
+		if(len)
+			stringMap.insert(make_pair(s, stringMap.size()));
+
+		//The first bit must be 1, the next 29 bits
+		//store the number of bytes of the string
+		writeU29((len<<1) | 1);
+
+		getBuffer(position+len,true);
+		memcpy(bytes+position,s.raw_buf(),len);
+		position+=len;
+	}
+}
+
+void ByteArray::writeXMLString(std::map<const ASObject*, uint32_t>& objMap,
+			       ASObject *xml,
+			       const tiny_string& xmlstr)
+{
+	if(xmlstr.numBytes() >= 1<<28)
+		throwError<RangeError>(kParamRangeError);
+
+	//Check if the XML object has been already serialized
+	auto it=objMap.find(xml);
+	if(it!=objMap.end())
+	{
+		//The least significant bit is 0 to signal a reference
+		writeU29(it->second << 1);
+	}
+	else
+	{
+		//Add the XML object to the map
+		objMap.insert(make_pair(xml, objMap.size()));
+
+		//The first bit must be 1, the next 29 bits
+		//store the number of bytes of the string
+		writeU29((xmlstr.numBytes()<<1) | 1);
+
+		getBuffer(position+xmlstr.numBytes(),true);
+		memcpy(bytes+position,xmlstr.raw_buf(),xmlstr.numBytes());
+		position+=xmlstr.numBytes();
+	}
+}
+
+void ByteArray::compress_zlib()
+{
+	if(len==0)
+		return;
+
+	unsigned long buflen=compressBound(len);
+	uint8_t *compressed=(uint8_t*) malloc(buflen);
+	assert_and_throw(compressed);
+
+	if(compress(compressed, &buflen, bytes, len)!=Z_OK)
+	{
+		free(compressed);
+		throw RunTimeException("zlib compress failed");
+	}
+
+	acquireBuffer(compressed, buflen);
+	position=buflen;
+}
+
+void ByteArray::uncompress_zlib()
+{
+	z_stream strm;
+	int status;
+
+	if(len==0)
+		return;
+
+	strm.zalloc=Z_NULL;
+	strm.zfree=Z_NULL;
+	strm.opaque=Z_NULL;
+	strm.avail_in=len;
+	strm.next_in=bytes;
+	strm.total_out=0;
+	status=inflateInit(&strm);
+	if(status==Z_VERSION_ERROR)
+		throw Class<IOError>::getInstanceS("not valid compressed data");
+	else if(status!=Z_OK)
+		throw RunTimeException("zlib uncompress failed");
+
+	vector<uint8_t> buf(3*len);
+	do
+	{
+		strm.next_out=&buf[strm.total_out];
+		strm.avail_out=buf.size()-strm.total_out;
+		status=inflate(&strm, Z_NO_FLUSH);
+
+		if(status!=Z_OK && status!=Z_STREAM_END)
+		{
+			inflateEnd(&strm);
+			throw Class<IOError>::getInstanceS("not valid compressed data");
+		}
+
+		if(strm.avail_out==0)
+			buf.resize(buf.size()+len);
+	} while(status!=Z_STREAM_END);
+
+	inflateEnd(&strm);
+
+	len=strm.total_out;
+#ifdef MEMORY_USAGE_PROFILING
+	getClass()->memoryAccount->addBytes(len-real_len);
+#endif
+	real_len = len;
+	uint8_t* bytes2=(uint8_t*) realloc(bytes, len);
+	assert_and_throw(bytes2);
+	bytes = bytes2;
+	memcpy(bytes, &buf[0], len);
+	position=0;
+}
+
+ASFUNCTIONBODY(ByteArray,_compress)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	// flash throws an error if compress is called with a compression algorithm,
+	// and always uses the zlib algorithm
+	// but tamarin tests do not catch it, so we simply ignore any parameters provided
+	th->lock();
+	th->compress_zlib();
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_uncompress)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	// flash throws an error if uncompress is called with a compression algorithm,
+	// and always uses the zlib algorithm
+	// but tamarin tests do not catch it, so we simply ignore any parameters provided
+	th->lock();
+	th->uncompress_zlib();
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_deflate)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	th->lock();
+	th->compress_zlib();
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,_inflate)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	th->lock();
+	th->uncompress_zlib();
+	th->unlock();
+	return NULL;
+}
+
+ASFUNCTIONBODY(ByteArray,clear)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	th->lock();
+	if(th->bytes)
+	{
+#ifdef MEMORY_USAGE_PROFILING
+		th->getClass()->memoryAccount->removeBytes(th->real_len);
+#endif
+		free(th->bytes);
+	}
+	th->bytes = NULL;
+	th->len=0;
+	th->real_len=0;
+	th->position=0;
+	th->unlock();
+	return NULL;
+}
+
+// this seems to be how AS3 handles generic pop calls in Array class
+ASFUNCTIONBODY(ByteArray,pop)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint8_t res = 0;
+	th->lock();
+	if (th->readByte(res))
+	{
+		memmove(th->bytes,(th->bytes+1),th->getLength()-1);
+		th->len--;
+	}
+	th->unlock();
+	return abstract_ui(res);
+	
+}
+
+// this seems to be how AS3 handles generic push calls in Array class
+ASFUNCTIONBODY(ByteArray,push)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	th->lock();
+	th->getBuffer(th->len+argslen,true);
+	for (unsigned int i = 0; i < argslen; i++)
+	{
+		th->bytes[th->len+i] = (uint8_t)args[i]->toInt();
+	}
+	uint32_t res = th->getLength();
+	th->unlock();
+	return abstract_ui(res);
+}
+
+// this seems to be how AS3 handles generic shift calls in Array class
+ASFUNCTIONBODY(ByteArray,shift)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	uint8_t res = 0;
+	th->lock();
+	if (th->readByte(res))
+	{
+		memmove(th->bytes,(th->bytes+1),th->getLength()-1);
+		th->len--;
+	}
+	th->unlock();
+	return abstract_ui(res);
+}
+
+// this seems to be how AS3 handles generic unshift calls in Array class
+ASFUNCTIONBODY(ByteArray,unshift)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	th->lock();
+	th->getBuffer(th->len+argslen,true);
+	for (unsigned int i = 0; i < argslen; i++)
+	{
+		memmove((th->bytes+argslen),(th->bytes),th->len);
+		th->bytes[i] = (uint8_t)args[i]->toInt();
+	}
+	uint32_t res = th->getLength();
+	th->unlock();
+	return abstract_ui(res);
+}
+ASFUNCTIONBODY_GETTER_SETTER(ByteArray,shareable);
+
+ASFUNCTIONBODY(ByteArray,atomicCompareAndSwapIntAt)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+
+	int32_t byteindex,expectedValue,newvalue;
+	ARG_UNPACK(byteindex)(expectedValue)(newvalue);
+
+	if (byteindex < 0 || byteindex%4)
+	{
+		throwError<RangeError>(kInvalidRangeError, obj->getClassName());
+	}
+	th->lock();
+	if(byteindex >= (int32_t)th->len-4)
+	{
+		th->unlock();
+		throwError<RangeError>(kInvalidRangeError, obj->getClassName());
+	}
+	int32_t ret;
+	memcpy(&ret,th->bytes+byteindex,4);
+
+	if (ret == expectedValue)
+	{
+		memcpy(th->bytes+byteindex,&newvalue,4);
+	}
+	th->unlock();
+	return abstract_i(ret);
+}
+ASFUNCTIONBODY(ByteArray,atomicCompareAndSwapLength)
+{
+	ByteArray* th=static_cast<ByteArray*>(obj);
+	int32_t expectedLength,newLength;
+	ARG_UNPACK(expectedLength)(newLength);
+
+	th->lock();
+	int32_t ret = th->len;
+	if (ret == expectedLength)
+	{
+		th->setLength(newLength);
+	}
+	th->unlock();
+	return abstract_i(ret);
+}
+
+ASFUNCTIONBODY(ByteArray,_toJSON)
+{
+	return Class<ASString>::getInstanceS("ByteArray");
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/ByteArray.h lightspark-0.7.2/src/scripting/flash/utils/ByteArray.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/ByteArray.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/ByteArray.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,149 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_BYTEARRAY_H
+#define SCRIPTING_FLASH_UTILS_BYTEARRAY_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+#include "scripting/flash/utils/flashutils.h"
+
+namespace lightspark
+{
+
+class ByteArray: public ASObject, public IDataInput, public IDataOutput
+{
+friend class LoaderThread;
+friend class URLLoader;
+protected:
+	bool littleEndian;
+	uint8_t objectEncoding;
+	uint32_t position;
+	uint8_t* bytes;
+	uint32_t real_len;
+	uint32_t len;
+	void compress_zlib();
+	void uncompress_zlib();
+	Mutex mutex;
+	void lock();
+	void unlock();
+	void setLength(uint32_t newLen);
+public:
+	ByteArray(Class_base* c, uint8_t* b = NULL, uint32_t l = 0);
+	~ByteArray();
+	//Helper interface for serialization
+	bool readByte(uint8_t& b);
+	bool readShort(uint16_t& ret);
+	bool readUnsignedInt(uint32_t& ret);
+	bool readU29(uint32_t& ret);
+	bool readUTF(tiny_string& ret);
+	void writeByte(uint8_t b);
+	void writeShort(uint16_t val);
+	void writeUnsignedInt(uint32_t val);
+	void writeUTF(const tiny_string& str);
+	uint32_t writeObject(ASObject* obj);
+	void writeStringVR(std::map<tiny_string, uint32_t>& stringMap, const tiny_string& s);
+	void writeXMLString(std::map<const ASObject*, uint32_t>& objMap, ASObject *xml, const tiny_string& s);
+	void writeU29(uint32_t val);
+	uint32_t getPosition() const;
+	void setPosition(uint32_t p);
+
+	ASFUNCTION(_getBytesAvailable);
+	ASFUNCTION(_getLength);
+	ASFUNCTION(_setLength);
+	ASFUNCTION(_getPosition);
+	ASFUNCTION(_setPosition);
+	ASFUNCTION(_getEndian);
+	ASFUNCTION(_setEndian);
+	ASFUNCTION(_getObjectEncoding);
+	ASFUNCTION(_setObjectEncoding);
+	ASFUNCTION(_getDefaultObjectEncoding);
+	ASFUNCTION(_setDefaultObjectEncoding);
+	ASFUNCTION(_compress);
+	ASFUNCTION(_uncompress);
+	ASFUNCTION(_deflate);
+	ASFUNCTION(_inflate);
+	ASFUNCTION(clear);
+	ASFUNCTION(readBoolean);
+	ASFUNCTION(readByte);
+	ASFUNCTION(readBytes);
+	ASFUNCTION(readDouble);
+	ASFUNCTION(readFloat);
+	ASFUNCTION(readInt);
+	ASFUNCTION(readMultiByte);
+	ASFUNCTION(readObject);
+	ASFUNCTION(readShort);
+	ASFUNCTION(readUnsignedByte);
+	ASFUNCTION(readUnsignedInt);
+	ASFUNCTION(readUnsignedShort);
+	ASFUNCTION(readUTF);
+	ASFUNCTION(readUTFBytes);
+	ASFUNCTION(writeBoolean);
+	ASFUNCTION(writeByte);
+	ASFUNCTION(writeBytes);
+	ASFUNCTION(writeDouble);
+	ASFUNCTION(writeFloat);
+	ASFUNCTION(writeInt);
+	ASFUNCTION(writeUnsignedInt);
+	ASFUNCTION(writeMultiByte);
+	ASFUNCTION(writeObject);
+	ASFUNCTION(writeShort);
+	ASFUNCTION(writeUTF);
+	ASFUNCTION(writeUTFBytes);
+	ASFUNCTION(_toString);
+	ASPROPERTY_GETTER_SETTER(bool,shareable);
+	ASFUNCTION(atomicCompareAndSwapIntAt);
+	ASFUNCTION(atomicCompareAndSwapLength);
+	ASFUNCTION(_toJSON);
+
+	// these are internal methods used if the generic Array-Methods are called on a ByteArray
+	ASFUNCTION(pop);
+	ASFUNCTION(push);
+	ASFUNCTION(shift);
+	ASFUNCTION(unshift);
+	/**
+		Get ownership over the passed buffer
+		@param buf Pointer to the buffer to acquire, ownership and delete authority is acquired
+		@param bufLen Lenght of the buffer
+		@pre buf must be allocated using new[]
+	*/
+	void acquireBuffer(uint8_t* buf, int bufLen);
+	uint8_t* getBuffer(unsigned int size, bool enableResize);
+	uint32_t getLength() const { return len; }
+
+	uint16_t endianIn(uint16_t value);
+	uint32_t endianIn(uint32_t value);
+	uint64_t endianIn(uint64_t value);
+
+	uint16_t endianOut(uint16_t value);
+	uint32_t endianOut(uint32_t value);
+	uint64_t endianOut(uint64_t value);
+
+	static void sinit(Class_base* c);
+	static void buildTraits(ASObject* o);
+	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
+	int32_t getVariableByMultiname_i(const multiname& name);
+	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
+	void setVariableByMultiname_i(const multiname& name, int32_t value);
+	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
+};
+
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_BYTEARRAY_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Dictionary.cpp lightspark-0.7.2/src/scripting/flash/utils/Dictionary.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Dictionary.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Dictionary.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,256 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+#include "scripting/flash/utils/Dictionary.h"
+
+using namespace std;
+using namespace lightspark;
+
+Dictionary::Dictionary(Class_base* c):ASObject(c),
+	data(std::less<dictType::key_type>(), reporter_allocator<dictType::value_type>(c->memoryAccount))
+{
+}
+
+void Dictionary::finalize()
+{
+	ASObject::finalize();
+	data.clear();
+}
+
+void Dictionary::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_DYNAMIC_NOT_FINAL);
+	c->setDeclaredMethodByQName("toJSON",AS3,Class<IFunction>::getFunction(_toJSON),NORMAL_METHOD,true);
+}
+
+void Dictionary::buildTraits(ASObject* o)
+{
+}
+
+ASFUNCTIONBODY(Dictionary,_constructor)
+{
+	return NULL;
+}
+
+ASFUNCTIONBODY(Dictionary,_toJSON)
+{
+	return Class<ASString>::getInstanceS("Dictionary");
+}
+
+Dictionary::dictType::iterator Dictionary::findKey(ASObject *o)
+{
+	Dictionary::dictType::iterator it = data.begin();
+	for(; it!=data.end(); ++it)
+	{
+		if (it->first->isEqualStrict(o))
+			return it;
+	}
+
+	return data.end();
+}
+
+void Dictionary::setVariableByMultiname_i(const multiname& name, int32_t value)
+{
+	assert_and_throw(implEnable);
+	Dictionary::setVariableByMultiname(name,abstract_i(value),CONST_NOT_ALLOWED);
+}
+
+void Dictionary::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
+{
+	assert_and_throw(implEnable);
+	if(name.name_type==multiname::NAME_OBJECT)
+	{
+		name.name_o->incRef();
+		_R<ASObject> name_o(name.name_o);
+
+		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
+		if(it!=data.end())
+			it->second=_MR(o);
+		else
+			data.insert(make_pair(name_o,_MR(o)));
+	}
+	else
+	{
+		//Primitive types _must_ be handled by the normal ASObject path
+		//REFERENCE: Dictionary Object on AS3 reference
+		assert(name.name_type==multiname::NAME_STRING ||
+			name.name_type==multiname::NAME_INT ||
+			name.name_type==multiname::NAME_NUMBER);
+		ASObject::setVariableByMultiname(name, o, allowConst);
+	}
+}
+
+bool Dictionary::deleteVariableByMultiname(const multiname& name)
+{
+	assert_and_throw(implEnable);
+
+	if(name.name_type==multiname::NAME_OBJECT)
+	{
+		name.name_o->incRef();
+		_R<ASObject> name_o(name.name_o);
+
+		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
+		if(it != data.end())
+		{
+			data.erase(it);
+			return true;
+		}
+		return false;
+	}
+	else
+	{
+		//Primitive types _must_ be handled by the normal ASObject path
+		//REFERENCE: Dictionary Object on AS3 reference
+		assert(name.name_type==multiname::NAME_STRING ||
+			name.name_type==multiname::NAME_INT ||
+			name.name_type==multiname::NAME_NUMBER);
+		return ASObject::deleteVariableByMultiname(name);
+	}
+}
+
+_NR<ASObject> Dictionary::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
+{
+	if((opt & ASObject::SKIP_IMPL)==0 && implEnable)
+	{
+		if(name.name_type==multiname::NAME_OBJECT)
+		{
+			name.name_o->incRef();
+			_R<ASObject> name_o(name.name_o);
+
+			Dictionary::dictType::iterator it=findKey(name_o.getPtr());
+			if(it != data.end())
+				return it->second;
+			else
+				return NullRef;
+		}
+		else
+		{
+			//Primitive types _must_ be handled by the normal ASObject path
+			//REFERENCE: Dictionary Object on AS3 reference
+			assert(name.name_type==multiname::NAME_STRING ||
+				name.name_type==multiname::NAME_INT ||
+				name.name_type==multiname::NAME_NUMBER);
+			return ASObject::getVariableByMultiname(name, opt);
+		}
+	}
+	//Try with the base implementation
+	return ASObject::getVariableByMultiname(name, opt);
+}
+
+bool Dictionary::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
+{
+	if(considerDynamic==false)
+		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
+
+	if(name.name_type==multiname::NAME_OBJECT)
+	{
+		name.name_o->incRef();
+		_R<ASObject> name_o(name.name_o);
+
+		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
+		return it != data.end();
+	}
+	else
+	{
+		//Primitive types _must_ be handled by the normal ASObject path
+		//REFERENCE: Dictionary Object on AS3 reference
+		assert(name.name_type==multiname::NAME_STRING ||
+			name.name_type==multiname::NAME_INT ||
+			name.name_type==multiname::NAME_NUMBER);
+		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
+	}
+}
+
+uint32_t Dictionary::nextNameIndex(uint32_t cur_index)
+{
+	assert_and_throw(implEnable);
+	if(cur_index<data.size())
+		return cur_index+1;
+	else
+	{
+		//Fall back on object properties
+		uint32_t ret=ASObject::nextNameIndex(cur_index-data.size());
+		if(ret==0)
+			return 0;
+		else
+			return ret+data.size();
+
+	}
+}
+
+_R<ASObject> Dictionary::nextName(uint32_t index)
+{
+	assert_and_throw(implEnable);
+	if(index<=data.size())
+	{
+		map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
+		for(unsigned int i=1;i<index;i++)
+			++it;
+
+		return it->first;
+	}
+	else
+	{
+		//Fall back on object properties
+		return ASObject::nextName(index-data.size());
+	}
+}
+
+_R<ASObject> Dictionary::nextValue(uint32_t index)
+{
+	assert_and_throw(implEnable);
+	if(index<=data.size())
+	{
+		map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
+		for(unsigned int i=1;i<index;i++)
+			++it;
+
+		return it->second;
+	}
+	else
+	{
+		//Fall back on object properties
+		return ASObject::nextValue(index-data.size());
+	}
+}
+
+tiny_string Dictionary::toString()
+{
+	std::stringstream retstr;
+	retstr << "{";
+	map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
+	while(it != data.end())
+	{
+		if(it != data.begin())
+			retstr << ", ";
+		retstr << "{" << it->first->toString() << ", " << it->second->toString() << "}";
+		++it;
+	}
+	retstr << "}";
+
+	return retstr.str();
+}
+
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Dictionary.h lightspark-0.7.2/src/scripting/flash/utils/Dictionary.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Dictionary.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Dictionary.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,64 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_DICTIONARY_H
+#define SCRIPTING_FLASH_UTILS_DICTIONARY_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+
+
+namespace lightspark
+{
+
+class Dictionary: public ASObject
+{
+friend class ABCVm;
+private:
+	typedef std::map<_R<ASObject>,_R<ASObject>,std::less<_R<ASObject>>,
+	       reporter_allocator<std::pair<const _R<ASObject>, _R<ASObject>>>> dictType;
+	dictType data;
+	dictType::iterator findKey(ASObject *);
+public:
+	Dictionary(Class_base* c);
+	void finalize();
+	static void sinit(Class_base*);
+	static void buildTraits(ASObject* o);
+	ASFUNCTION(_constructor);
+	ASFUNCTION(_toJSON);
+
+	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
+	int32_t getVariableByMultiname_i(const multiname& name)
+	{
+		assert_and_throw(implEnable);
+		throw UnsupportedException("getVariableByMultiName_i not supported for Dictionary");
+	}
+	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
+	void setVariableByMultiname_i(const multiname& name, int32_t value);
+	bool deleteVariableByMultiname(const multiname& name);
+	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
+	tiny_string toString();
+	uint32_t nextNameIndex(uint32_t cur_index);
+	_R<ASObject> nextName(uint32_t index);
+	_R<ASObject> nextValue(uint32_t index);
+};
+
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_DICTIONARY_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/flashutils.cpp lightspark-0.7.2/src/scripting/flash/utils/flashutils.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/flashutils.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/flashutils.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -39,7 +39,7 @@
 
 void Endian::sinit(Class_base* c)
 {
-	c->setConstructor(NULL);
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("LITTLE_ENDIAN","",Class<ASString>::getInstanceS(littleEndian),DECLARED_TRAIT);
 	c->setVariableByQName("BIG_ENDIAN","",Class<ASString>::getInstanceS(bigEndian),DECLARED_TRAIT);
 }
@@ -89,1351 +89,7 @@
 	lookupAndLink(c,"writeUTFBytes","flash.utils:IDataOutput");
 }
 
-ByteArray::ByteArray(Class_base* c, uint8_t* b, uint32_t l):ASObject(c),littleEndian(false),objectEncoding(ObjectEncoding::AMF3),
-	position(0),bytes(b),real_len(l),len(l)
-{
-#ifdef MEMORY_USAGE_PROFILING
-	c->memoryAccount->addBytes(l);
-#endif
-}
-
-ByteArray::~ByteArray()
-{
-	if(bytes)
-	{
-#ifdef MEMORY_USAGE_PROFILING
-		getClass()->memoryAccount->removeBytes(real_len);
-#endif
-		free(bytes);
-	}
-}
-
-void ByteArray::sinit(Class_base* c)
-{
-	c->setConstructor(NULL);
-	c->setSuper(Class<ASObject>::getRef());
-
-	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_getLength),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_setLength),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("bytesAvailable","",Class<IFunction>::getFunction(_getBytesAvailable),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("position","",Class<IFunction>::getFunction(_getPosition),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("position","",Class<IFunction>::getFunction(_setPosition),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("endian","",Class<IFunction>::getFunction(_getEndian),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("endian","",Class<IFunction>::getFunction(_setEndian),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_getObjectEncoding),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("objectEncoding","",Class<IFunction>::getFunction(_setObjectEncoding),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("defaultObjectEncoding","",Class<IFunction>::getFunction(_getDefaultObjectEncoding),GETTER_METHOD,false);
-	c->setDeclaredMethodByQName("defaultObjectEncoding","",Class<IFunction>::getFunction(_setDefaultObjectEncoding),SETTER_METHOD,false);
-	getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::DEFAULT;
-	c->setDeclaredMethodByQName("clear","",Class<IFunction>::getFunction(clear),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("compress","",Class<IFunction>::getFunction(_compress),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("uncompress","",Class<IFunction>::getFunction(_uncompress),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("deflate","",Class<IFunction>::getFunction(_deflate),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("inflate","",Class<IFunction>::getFunction(_inflate),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readBoolean","",Class<IFunction>::getFunction(readBoolean),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readBytes","",Class<IFunction>::getFunction(readBytes),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readByte","",Class<IFunction>::getFunction(readByte),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readDouble","",Class<IFunction>::getFunction(readDouble),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readFloat","",Class<IFunction>::getFunction(readFloat),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readInt","",Class<IFunction>::getFunction(readInt),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readMultiByte","",Class<IFunction>::getFunction(readMultiByte),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readShort","",Class<IFunction>::getFunction(readShort),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readUnsignedByte","",Class<IFunction>::getFunction(readUnsignedByte),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readUnsignedInt","",Class<IFunction>::getFunction(readUnsignedInt),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readUnsignedShort","",Class<IFunction>::getFunction(readUnsignedShort),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readObject","",Class<IFunction>::getFunction(readObject),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readUTF","",Class<IFunction>::getFunction(readUTF),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("readUTFBytes","",Class<IFunction>::getFunction(readUTFBytes),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeBoolean","",Class<IFunction>::getFunction(writeBoolean),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeUTF","",Class<IFunction>::getFunction(writeUTF),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeUTFBytes","",Class<IFunction>::getFunction(writeUTFBytes),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeBytes","",Class<IFunction>::getFunction(writeBytes),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeByte","",Class<IFunction>::getFunction(writeByte),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeDouble","",Class<IFunction>::getFunction(writeDouble),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeFloat","",Class<IFunction>::getFunction(writeFloat),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeInt","",Class<IFunction>::getFunction(writeInt),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeMultiByte","",Class<IFunction>::getFunction(writeMultiByte),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeUnsignedInt","",Class<IFunction>::getFunction(writeUnsignedInt),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeObject","",Class<IFunction>::getFunction(writeObject),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("writeShort","",Class<IFunction>::getFunction(writeShort),NORMAL_METHOD,true);
-	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(ByteArray::_toString),DYNAMIC_TRAIT);
-
-	c->addImplementedInterface(InterfaceClass<IDataInput>::getClass());
-	IDataInput::linkTraits(c);
-	c->addImplementedInterface(InterfaceClass<IDataOutput>::getClass());
-	IDataOutput::linkTraits(c);
-}
-
-void ByteArray::buildTraits(ASObject* o)
-{
-}
-
-uint8_t* ByteArray::getBuffer(unsigned int size, bool enableResize)
-{
-	// the flash documentation doesn't tell how large ByteArrays are allowed to be
-	// so we simply don't allow bytearrays larger than 1GiB
-	// maybe we should set this smaller
-	if (size > 0x4000000) 
-		throwError<ASError>(kOutOfMemoryError);
-	// The first allocation is exactly the size we need,
-	// the subsequent reallocations happen in increments of BA_CHUNK_SIZE bytes
-	uint32_t prevLen = len;
-	if(bytes==NULL)
-	{
-		len=size;
-		real_len=len;
-		bytes = (uint8_t*) malloc(len);
-#ifdef MEMORY_USAGE_PROFILING
-		getClass()->memoryAccount->addBytes(len);
-#endif
-	}
-	else if(enableResize==false)
-	{
-		assert_and_throw(size<=len);
-	}
-	else if(real_len<size) // && enableResize==true
-	{
-#ifdef MEMORY_USAGE_PROFILING
-		uint32_t prev_real_len = real_len;
-#endif
-		while(real_len < size)
-			real_len += BA_CHUNK_SIZE;
-		// Reallocate the buffer, in chunks of BA_CHUNK_SIZE bytes
-		uint8_t* bytes2 = (uint8_t*) realloc(bytes, real_len);
-#ifdef MEMORY_USAGE_PROFILING
-		getClass()->memoryAccount->addBytes(real_len-prev_real_len);
-#endif
-		assert_and_throw(bytes2);
-		bytes = bytes2;
-		len=size;
-		bytes=bytes2;
-	}
-	else if(len<size)
-	{
-		len=size;
-	}
-	if(prevLen<size)
-	{
-		//Extend
-		memset(bytes+prevLen,0,size-prevLen);
-	}
-	return bytes;
-}
-
-uint16_t ByteArray::endianIn(uint16_t value)
-{
-	if(littleEndian)
-		return GUINT16_TO_LE(value);
-	else
-		return GUINT16_TO_BE(value);
-}
-
-uint32_t ByteArray::endianIn(uint32_t value)
-{
-	if(littleEndian)
-		return GUINT32_TO_LE(value);
-	else
-		return GUINT32_TO_BE(value);
-}
-
-uint64_t ByteArray::endianIn(uint64_t value)
-{
-	if(littleEndian)
-		return GUINT64_TO_LE(value);
-	else
-		return GUINT64_TO_BE(value);
-}
-
-uint16_t ByteArray::endianOut(uint16_t value)
-{
-	if(littleEndian)
-		return GUINT16_FROM_LE(value);
-	else
-		return GUINT16_FROM_BE(value);
-}
-
-uint32_t ByteArray::endianOut(uint32_t value)
-{
-	if(littleEndian)
-		return GUINT32_FROM_LE(value);
-	else
-		return GUINT32_FROM_BE(value);
-}
-
-uint64_t ByteArray::endianOut(uint64_t value)
-{
-	if(littleEndian)
-		return GUINT64_FROM_LE(value);
-	else
-		return GUINT64_FROM_BE(value);
-}
-
-uint32_t ByteArray::getPosition() const
-{
-	return position;
-}
-
-ASFUNCTIONBODY(ByteArray,_getPosition)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	return abstract_i(th->getPosition());
-}
-
-void ByteArray::setPosition(uint32_t p)
-{
-	position=p;
-}
-
-ASFUNCTIONBODY(ByteArray,_setPosition)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint32_t pos=args[0]->toUInt();
-	th->setPosition(pos);
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_getEndian)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	if(th->littleEndian)
-		return Class<ASString>::getInstanceS(Endian::littleEndian);
-	else
-		return Class<ASString>::getInstanceS(Endian::bigEndian);
-}
-
-ASFUNCTIONBODY(ByteArray,_setEndian)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	if(args[0]->toString() == Endian::littleEndian)
-		th->littleEndian = true;
-	else if(args[0]->toString() == Endian::bigEndian)
-		th->littleEndian = false;
-	else
-		throwError<ArgumentError>(kInvalidEnumError, "endian");
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_getObjectEncoding)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	return abstract_ui(th->objectEncoding);
-}
-
-ASFUNCTIONBODY(ByteArray,_setObjectEncoding)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint32_t value;
-	ARG_UNPACK(value);
-	if(value!=ObjectEncoding::AMF0 && value!=ObjectEncoding::AMF3)
-		throwError<ArgumentError>(kInvalidEnumError, "objectEncoding");
-
-	th->objectEncoding=value;
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_getDefaultObjectEncoding)
-{
-	return abstract_i(getSys()->staticNetConnectionDefaultObjectEncoding);
-}
-
-ASFUNCTIONBODY(ByteArray,_setDefaultObjectEncoding)
-{
-	assert_and_throw(argslen == 1);
-	int32_t value = args[0]->toInt();
-	if(value == 0)
-		getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::AMF0;
-	else if(value == 3)
-		getSys()->staticByteArrayDefaultObjectEncoding = ObjectEncoding::AMF3;
-	else
-		throw RunTimeException("Invalid object encoding");
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_setLength)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-	uint32_t newLen=args[0]->toInt();
-	if(newLen==th->len) //Nothing to do
-		return NULL;
-	if (newLen > 0)
-	{
-		th->getBuffer(newLen,true);
-	}
-	else
-	{
-		if (th->bytes)
-		{
-#ifdef MEMORY_USAGE_PROFILING
-			th->getClass()->memoryAccount->removeBytes(th->real_len);
-#endif
-			free(th->bytes);
-		}
-		th->bytes = NULL;
-		th->len = newLen;
-		th->real_len = newLen;
-	}
-	if (th->position > th->len)
-		th->position = (th->len > 0 ? th->len-1 : 0);
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_getLength)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	return abstract_i(th->len);
-}
-
-ASFUNCTIONBODY(ByteArray,_getBytesAvailable)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	return abstract_i(th->len-th->position);
-}
-
-ASFUNCTIONBODY(ByteArray,readBoolean)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-
-	uint8_t ret;
-	if(!th->readByte(ret))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	return abstract_b(ret!=0);
-}
-
-ASFUNCTIONBODY(ByteArray,readBytes)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	_NR<ByteArray> out;
-	uint32_t offset;
-	uint32_t length;
-	ARG_UNPACK(out)(offset, 0)(length, 0);
-	
-	if(length == 0)
-	{
-		assert(th->len >= th->position);
-		length = th->len - th->position;
-	}
-
-	//Error checks
-	if(th->position+length > th->len)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-	if((uint64_t)length+offset > 0xFFFFFFFF)
-	{
-		throw Class<RangeError>::getInstanceS("length+offset");
-	}
-	
-	uint8_t* buf=out->getBuffer(length+offset,true);
-	memcpy(buf+offset,th->bytes+th->position,length);
-	th->position+=length;
-
-	return NULL;
-}
-
-bool ByteArray::readUTF(tiny_string& ret)
-{
-	uint16_t stringLen;
-	if(!readShort(stringLen))
-		return false;
-	if(len < (position+stringLen))
-		return false;
-	//Very inefficient copy
-	//TODO: optmize
-	ret=string((char*)bytes+position, (size_t)stringLen);
-	position+=stringLen;
-	return true;
-}
-
-ASFUNCTIONBODY(ByteArray,readUTF)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-
-	tiny_string res;
-	if (!th->readUTF(res))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	return Class<ASString>::getInstanceS(res);
-}
-
-ASFUNCTIONBODY(ByteArray,readUTFBytes)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint32_t length;
-
-	ARG_UNPACK (length);
-	if(th->position+length > th->len)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	uint8_t *bufStart=th->bytes+th->position;
-	th->position+=length;
-	return Class<ASString>::getInstanceS((char *)bufStart,length);
-}
-
-void ByteArray::writeUTF(const tiny_string& str)
-{
-	getBuffer(position+str.numBytes()+2,true);
-	if(str.numBytes() > 65535)
-	{
-		throwError<RangeError>(kParamRangeError);
-	}
-	uint16_t numBytes=endianIn((uint16_t)str.numBytes());
-	memcpy(bytes+position,&numBytes,2);
-	memcpy(bytes+position+2,str.raw_buf(),str.numBytes());
-	position+=str.numBytes()+2;
-}
-
-ASFUNCTIONBODY(ByteArray,writeUTF)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	//Validate parameters
-	assert_and_throw(argslen==1);
-	assert_and_throw(args[0]->getObjectType()==T_STRING);
-	ASString* str=Class<ASString>::cast(args[0]);
-	th->writeUTF(str->data);
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeUTFBytes)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	//Validate parameters
-	assert_and_throw(argslen==1);
-	assert_and_throw(args[0]->getObjectType()==T_STRING);
-	ASString* str=Class<ASString>::cast(args[0]);
-	th->getBuffer(th->position+str->data.numBytes(),true);
-	memcpy(th->bytes+th->position,str->data.raw_buf(),str->data.numBytes());
-	th->position+=str->data.numBytes();
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeMultiByte)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	tiny_string value;
-	tiny_string charset;
-	ARG_UNPACK(value)(charset);
-
-	// TODO: should convert from UTF-8 to charset
-	LOG(LOG_NOT_IMPLEMENTED, "ByteArray.writeMultiByte doesn't convert charset");
-
-	th->getBuffer(th->position+value.numBytes(),true);
-	memcpy(th->bytes+th->position,value.raw_buf(),value.numBytes());
-	th->position+=value.numBytes();
-
-	return NULL;
-}
-
-uint32_t ByteArray::writeObject(ASObject* obj)
-{
-	//Return the length of the serialized object
-
-	//TODO: support AMF0
-	assert_and_throw(objectEncoding==ObjectEncoding::AMF3);
-	//TODO: support custom serialization
-	map<tiny_string, uint32_t> stringMap;
-	map<const ASObject*, uint32_t> objMap;
-	map<const Class_base*, uint32_t> traitsMap;
-	uint32_t oldPosition=position;
-	obj->serialize(this, stringMap, objMap,traitsMap);
-	return position-oldPosition;
-}
-
-ASFUNCTIONBODY(ByteArray,writeObject)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	//Validate parameters
-	assert_and_throw(argslen==1);
-	th->writeObject(args[0]);
-
-	return NULL;
-}
-
-void ByteArray::writeShort(uint16_t val)
-{
-	int16_t value2 = endianIn(val);
-	getBuffer(position+2,true);
-	memcpy(bytes+position,&value2,2);
-	position+=2;
-}
-
-ASFUNCTIONBODY(ByteArray,writeShort)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	int32_t value;
-	ARG_UNPACK(value);
-
-	th->writeShort((static_cast<uint16_t>(value & 0xffff)));
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeBytes)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	//Validate parameters
-	assert_and_throw(argslen>=1 && argslen<=3);
-	assert_and_throw(args[0]->getClass()->isSubClass(Class<ByteArray>::getClass()));
-	ByteArray* out=Class<ByteArray>::cast(args[0]);
-	uint32_t offset=0;
-	uint32_t length=0;
-	if(argslen>=2)
-		offset=args[1]->toUInt();
-	if(argslen==3)
-		length=args[2]->toUInt();
-
-	// We need to clamp offset to the beginning of the bytes array
-	if(offset > out->getLength()-1)
-		offset = 0;
-	// We need to clamp length to the end of the bytes array
-	if(length > out->getLength()-offset)
-		length = 0;
-
-	//If the length is 0 the whole buffer must be copied
-	if(length == 0)
-		length=(out->getLength()-offset);
-	uint8_t* buf=out->getBuffer(offset+length,false);
-	th->getBuffer(th->position+length,true);
-	memcpy(th->bytes+th->position,buf+offset,length);
-	th->position+=length;
-
-	return NULL;
-}
-
-void ByteArray::writeByte(uint8_t b)
-{
-	getBuffer(position+1,true);
-	bytes[position++] = b;
-}
-
-ASFUNCTIONBODY(ByteArray,writeByte)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-
-	int32_t value=args[0]->toInt();
-
-	th->writeByte(value&0xff);
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeBoolean)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	bool b;
-	ARG_UNPACK (b);
-
-	if (b)
-		th->writeByte(1);
-	else
-		th->writeByte(0);
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeDouble)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-
-	double value = args[0]->toNumber();
-	uint64_t *intptr=reinterpret_cast<uint64_t*>(&value);
-	uint64_t value2=th->endianIn(*intptr);
-
-	th->getBuffer(th->position+8,true);
-	memcpy(th->bytes+th->position,&value2,8);
-	th->position+=8;
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeFloat)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-
-	float value = args[0]->toNumber();
-	uint32_t *intptr=reinterpret_cast<uint32_t*>(&value);
-	uint32_t value2=th->endianIn(*intptr);
-
-	th->getBuffer(th->position+4,true);
-	memcpy(th->bytes+th->position,&value2,4);
-	th->position+=4;
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,writeInt)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-
-	uint32_t value=th->endianIn(static_cast<uint32_t>(args[0]->toInt()));
-
-	th->getBuffer(th->position+4,true);
-	memcpy(th->bytes+th->position,&value,4);
-	th->position+=4;
-
-	return NULL;
-}
-
-void ByteArray::writeUnsignedInt(uint32_t val)
-{
-	getBuffer(position+4,true);
-	memcpy(bytes+position,&val,4);
-	position+=4;
-}
-
-ASFUNCTIONBODY(ByteArray,writeUnsignedInt)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==1);
-
-	uint32_t value=th->endianIn(args[0]->toUInt());
-	th->writeUnsignedInt(value);
-	return NULL;
-}
-
-bool ByteArray::readByte(uint8_t& b)
-{
-	if (len <= position)
-		return false;
-
-	b=bytes[position++];
-	return true;
-}
-
-bool ByteArray::readU29(uint32_t& ret)
-{
-	//Be careful! This is different from u32 parsing.
-	//Here the most significant bits appears before in the stream!
-	ret=0;
-	for(uint32_t i=0;i<4;i++)
-	{
-		if (len <= position)
-			return false;
-
-		uint8_t tmp=bytes[position++];
-		ret <<= 7;
-		if(i<3)
-		{
-			ret |= tmp&0x7f;
-			if((tmp&0x80)==0)
-				break;
-		}
-		else
-		{
-			ret |= tmp;
-			//Sign extend
-			if(tmp&0x80)
-				ret|=0xe0000000;
-		}
-	}
-	return true;
-}
-
-ASFUNCTIONBODY(ByteArray, readByte)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	uint8_t ret;
-	if(!th->readByte(ret))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-	return abstract_i((int8_t)ret);
-}
-
-ASFUNCTIONBODY(ByteArray,readDouble)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	if(th->len < th->position+8)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	uint64_t ret;
-	memcpy(&ret,th->bytes+th->position,8);
-	th->position+=8;
-	ret = th->endianOut(ret);
-
-	double *doubleptr=reinterpret_cast<double*>(&ret);
-	return abstract_d(*doubleptr);
-}
-
-ASFUNCTIONBODY(ByteArray,readFloat)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	if(th->len < th->position+4)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	uint32_t ret;
-	memcpy(&ret,th->bytes+th->position,4);
-	th->position+=4;
-	ret = th->endianOut(ret);
-
-	float *floatptr=reinterpret_cast<float*>(&ret);
-	return abstract_d(*floatptr);
-}
-
-ASFUNCTIONBODY(ByteArray,readInt)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	if(th->len < th->position+4)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	uint32_t ret;
-	memcpy(&ret,th->bytes+th->position,4);
-	th->position+=4;
-
-	return abstract_i((int32_t)th->endianOut(ret));
-}
-
-bool ByteArray::readShort(uint16_t& ret)
-{
-	if (len < position+2)
-		return false;
-
-	uint16_t tmp;
-	memcpy(&tmp,bytes+position,2);
-	ret=endianOut(tmp);
-	position+=2;
-	return true;
-}
-
-ASFUNCTIONBODY(ByteArray,readShort)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	uint16_t ret;
-	if(!th->readShort(ret))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	return abstract_i((int16_t)ret);
-}
-
-ASFUNCTIONBODY(ByteArray,readUnsignedByte)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	uint8_t ret;
-	if (!th->readByte(ret))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-	return abstract_ui(ret);
-}
-
-bool ByteArray::readUnsignedInt(uint32_t& ret)
-{
-	if(len < position+4)
-		return false;
-
-	uint32_t tmp;
-	memcpy(&tmp,bytes+position,4);
-	ret=endianOut(tmp);
-	position+=4;
-	return true;
-}
-
-ASFUNCTIONBODY(ByteArray,readUnsignedInt)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	uint32_t ret;
-	if(!th->readUnsignedInt(ret))
-		throwError<ArgumentError>(kEOFError);
-
-	return abstract_ui(ret);
-}
-
-ASFUNCTIONBODY(ByteArray,readUnsignedShort)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-
-	uint16_t ret;
-	if(!th->readShort(ret))
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	return abstract_ui(ret);
-}
-
-ASFUNCTIONBODY(ByteArray,readMultiByte)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint32_t strlen;
-	tiny_string charset;
-	ARG_UNPACK(strlen)(charset);
-
-	if(th->len < th->position+strlen)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-
-	// TODO: should convert from charset to UTF-8
-	LOG(LOG_NOT_IMPLEMENTED, "ByteArray.readMultiByte doesn't convert charset");
-	return Class<ASString>::getInstanceS((char*)th->bytes+th->position,strlen);
-}
-
-ASFUNCTIONBODY(ByteArray,readObject)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	assert_and_throw(argslen==0);
-	if(th->bytes==NULL)
-	{
-		throwError<ArgumentError>(kEOFError);
-	}
-	assert_and_throw(th->objectEncoding==ObjectEncoding::AMF3);
-	Amf3Deserializer d(th);
-	_NR<ASObject> ret(NullRef);
-	try
-	{
-		ret=d.readObject();
-	}
-	catch(LightsparkException& e)
-	{
-		LOG(LOG_ERROR,"Exception caught while parsing AMF3: " << e.cause);
-		//TODO: throw AS exception
-	}
-
-	if(ret.isNull())
-	{
-		LOG(LOG_ERROR,"No objects in the AMF3 data. Returning Undefined");
-		return getSys()->getUndefinedRef();
-	}
-	ret->incRef();
-	return ret.getPtr();
-}
-
-ASFUNCTIONBODY(ByteArray,_toString)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	//TODO: check for Byte Order Mark
-	return Class<ASString>::getInstanceS((char*)th->bytes,th->len);
-}
-
-bool ByteArray::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
-{
-	if(considerDynamic==false)
-		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
-
-	unsigned int index=0;
-	if(!Array::isValidMultiname(name,index))
-		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
-
-	return index<len;
-}
-
-_NR<ASObject> ByteArray::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
-{
-	assert_and_throw(implEnable);
-	unsigned int index=0;
-	if((opt & ASObject::SKIP_IMPL)!=0 || !Array::isValidMultiname(name,index))
-		return ASObject::getVariableByMultiname(name,opt);
-
-	if(index<len)
-	{
-		uint8_t value = bytes[index];
-		return _MNR(abstract_ui(static_cast<uint32_t>(value)));
-	}
-	else
-		return _MNR(getSys()->getUndefinedRef());
-}
-
-int32_t ByteArray::getVariableByMultiname_i(const multiname& name)
-{
-	assert_and_throw(implEnable);
-	unsigned int index=0;
-	if(!Array::isValidMultiname(name,index))
-		return ASObject::getVariableByMultiname_i(name);
-
-	if(index<len)
-	{
-		uint8_t value = bytes[index];
-		return static_cast<uint32_t>(value);
-	}
-	else
-		return _MNR(getSys()->getUndefinedRef());
-}
-
-void ByteArray::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
-{
-	assert_and_throw(implEnable);
-	unsigned int index=0;
-	if(!Array::isValidMultiname(name,index))
-		return ASObject::setVariableByMultiname(name,o,allowConst);
-
-	if(index>=len)
-	{
-		uint32_t prevLen = len;
-		getBuffer(index+1, true);
-		// Fill the gap between the end of the current data and the index with zeros
-		memset(bytes+prevLen, 0, index-prevLen);
-	}
-
-	// Fill the byte pointed to by index with the truncated uint value of the object.
-	uint8_t value = static_cast<uint8_t>(o->toUInt() & 0xff);
-	bytes[index] = value;
-
-	o->decRef();
-}
-
-void ByteArray::setVariableByMultiname_i(const multiname& name, int32_t value)
-{
-	setVariableByMultiname(name, abstract_i(value),ASObject::CONST_NOT_ALLOWED);
-}
-
-void ByteArray::acquireBuffer(uint8_t* buf, int bufLen)
-{
-	if(bytes)
-	{
-#ifdef MEMORY_USAGE_PROFILING
-		getClass()->memoryAccount->removeBytes(real_len);
-#endif
-		free(bytes);
-	}
-	bytes=buf;
-	real_len=bufLen;
-	len=bufLen;
-#ifdef MEMORY_USAGE_PROFILING
-	getClass()->memoryAccount->addBytes(real_len);
-#endif
-	position=0;
-}
-
-void ByteArray::writeU29(uint32_t val)
-{
-	for(uint32_t i=0;i<4;i++)
-	{
-		uint8_t b;
-		if(i<3)
-		{
-			uint32_t tmp=(val >> ((3-i)*7));
-			if(tmp==0)
-				continue;
-
-			b=(tmp&0x7f)|0x80;
-		}
-		else
-			b=val&0x7f;
-
-		writeByte(b);
-	}
-}
-
-void ByteArray::writeStringVR(map<tiny_string, uint32_t>& stringMap, const tiny_string& s)
-{
-	const uint32_t len=s.numBytes();
-	if(len >= 1<<28)
-		throwError<RangeError>(kParamRangeError);
-
-	//Check if the string is already in the map
-	auto it=stringMap.find(s);
-	if(it!=stringMap.end())
-	{
-		//The first bit must be 0, the next 29 bits
-		//store the index of the string in the map
-		writeU29(it->second << 1);
-	}
-	else
-	{
-		//The AMF3 spec says that the empty string is never sent by reference
-		//So add the string to the map only if it's not the empty string
-		if(len)
-			stringMap.insert(make_pair(s, stringMap.size()));
-
-		//The first bit must be 1, the next 29 bits
-		//store the number of bytes of the string
-		writeU29((len<<1) | 1);
-
-		getBuffer(position+len,true);
-		memcpy(bytes+position,s.raw_buf(),len);
-		position+=len;
-	}
-}
-
-void ByteArray::writeXMLString(std::map<const ASObject*, uint32_t>& objMap,
-			       ASObject *xml,
-			       const tiny_string& xmlstr)
-{
-	if(xmlstr.numBytes() >= 1<<28)
-		throwError<RangeError>(kParamRangeError);
-
-	//Check if the XML object has been already serialized
-	auto it=objMap.find(xml);
-	if(it!=objMap.end())
-	{
-		//The least significant bit is 0 to signal a reference
-		writeU29(it->second << 1);
-	}
-	else
-	{
-		//Add the XML object to the map
-		objMap.insert(make_pair(xml, objMap.size()));
-
-		//The first bit must be 1, the next 29 bits
-		//store the number of bytes of the string
-		writeU29((xmlstr.numBytes()<<1) | 1);
-
-		getBuffer(position+xmlstr.numBytes(),true);
-		memcpy(bytes+position,xmlstr.raw_buf(),xmlstr.numBytes());
-		position+=xmlstr.numBytes();
-	}
-}
-
-void ByteArray::compress_zlib()
-{
-	if(len==0)
-		return;
-
-	unsigned long buflen=compressBound(len);
-	uint8_t *compressed=(uint8_t*) malloc(buflen);
-	assert_and_throw(compressed);
-
-	if(compress(compressed, &buflen, bytes, len)!=Z_OK)
-	{
-		free(compressed);
-		throw RunTimeException("zlib compress failed");
-	}
-
-	acquireBuffer(compressed, buflen);
-	position=buflen;
-}
-
-void ByteArray::uncompress_zlib()
-{
-	z_stream strm;
-	int status;
-
-	if(len==0)
-		return;
-
-	strm.zalloc=Z_NULL;
-	strm.zfree=Z_NULL;
-	strm.opaque=Z_NULL;
-	strm.avail_in=len;
-	strm.next_in=bytes;
-	strm.total_out=0;
-	status=inflateInit(&strm);
-	if(status==Z_VERSION_ERROR)
-		throw Class<IOError>::getInstanceS("not valid compressed data");
-	else if(status!=Z_OK)
-		throw RunTimeException("zlib uncompress failed");
-
-	vector<uint8_t> buf(3*len);
-	do
-	{
-		strm.next_out=&buf[strm.total_out];
-		strm.avail_out=buf.size()-strm.total_out;
-		status=inflate(&strm, Z_NO_FLUSH);
-
-		if(status!=Z_OK && status!=Z_STREAM_END)
-		{
-			inflateEnd(&strm);
-			throw Class<IOError>::getInstanceS("not valid compressed data");
-		}
-
-		if(strm.avail_out==0)
-			buf.resize(buf.size()+len);
-	} while(status!=Z_STREAM_END);
-
-	inflateEnd(&strm);
-
-	len=strm.total_out;
-#ifdef MEMORY_USAGE_PROFILING
-	getClass()->memoryAccount->addBytes(len-real_len);
-#endif
-	real_len = len;
-	uint8_t* bytes2=(uint8_t*) realloc(bytes, len);
-	assert_and_throw(bytes2);
-	bytes = bytes2;
-	memcpy(bytes, &buf[0], len);
-	position=0;
-}
-
-ASFUNCTIONBODY(ByteArray,_compress)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	// flash throws an error if compress is called with a compression algorithm,
-	// and always uses the zlib algorithm
-	// but tamarin tests do not catch it, so we simply ignore any parameters provided
-	th->compress_zlib();
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_uncompress)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	// flash throws an error if uncompress is called with a compression algorithm,
-	// and always uses the zlib algorithm
-	// but tamarin tests do not catch it, so we simply ignore any parameters provided
-	th->uncompress_zlib();
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_deflate)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	th->compress_zlib();
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,_inflate)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	th->uncompress_zlib();
-	return NULL;
-}
-
-ASFUNCTIONBODY(ByteArray,clear)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	if(th->bytes)
-	{
-#ifdef MEMORY_USAGE_PROFILING
-		th->getClass()->memoryAccount->removeBytes(th->real_len);
-#endif
-		free(th->bytes);
-	}
-	th->bytes = NULL;
-	th->len=0;
-	th->real_len=0;
-	th->position=0;
-	return NULL;
-}
-
-void Timer::tick()
-{
-	//This will be executed once if repeatCount was originally 1
-	//Otherwise it's executed until stopMe is set to true
-	this->incRef();
-	getVm()->addEvent(_MR(this),_MR(Class<TimerEvent>::getInstanceS("timer")));
-
-	currentCount++;
-	if(repeatCount!=0)
-	{
-		if(currentCount==repeatCount)
-		{
-			this->incRef();
-			getVm()->addEvent(_MR(this),_MR(Class<TimerEvent>::getInstanceS("timerComplete")));
-			stopMe=true;
-			running=false;
-		}
-	}
-}
 
-void Timer::tickFence()
-{
-	tickJobInstance = NullRef;
-}
-
-// this seems to be how AS3 handles generic pop calls in Array class
-ASFUNCTIONBODY(ByteArray,pop)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint8_t res = 0;
-	if (th->readByte(res))
-	{
-		memmove(th->bytes,(th->bytes+1),th->getLength()-1);
-		th->len--;
-	}
-	return abstract_ui(res);
-	
-}
-
-// this seems to be how AS3 handles generic push calls in Array class
-ASFUNCTIONBODY(ByteArray,push)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	th->getBuffer(th->len+argslen,true);
-	for (unsigned int i = 0; i < argslen; i++)
-	{
-		th->bytes[th->len+i] = (uint8_t)args[i]->toInt();
-	}
-	return abstract_ui(th->getLength());
-}
-
-// this seems to be how AS3 handles generic shift calls in Array class
-ASFUNCTIONBODY(ByteArray,shift)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	uint8_t res = 0;
-	if (th->readByte(res))
-	{
-		memmove(th->bytes,(th->bytes+1),th->getLength()-1);
-		th->len--;
-	}
-	return abstract_ui(res);
-}
-
-// this seems to be how AS3 handles generic unshift calls in Array class
-ASFUNCTIONBODY(ByteArray,unshift)
-{
-	ByteArray* th=static_cast<ByteArray*>(obj);
-	th->getBuffer(th->len+argslen,true);
-	for (unsigned int i = 0; i < argslen; i++)
-	{
-		memmove((th->bytes+argslen),(th->bytes),th->len);
-		th->bytes[i] = (uint8_t)args[i]->toInt();
-	}
-	return abstract_ui(th->getLength());
-}
-
-void Timer::sinit(Class_base* c)
-{
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<EventDispatcher>::getRef());
-	c->setDeclaredMethodByQName("currentCount","",Class<IFunction>::getFunction(_getCurrentCount),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("repeatCount","",Class<IFunction>::getFunction(_getRepeatCount),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("repeatCount","",Class<IFunction>::getFunction(_setRepeatCount),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("running","",Class<IFunction>::getFunction(_getRunning),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("delay","",Class<IFunction>::getFunction(_getDelay),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("delay","",Class<IFunction>::getFunction(_setDelay),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("start","",Class<IFunction>::getFunction(start),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("reset","",Class<IFunction>::getFunction(reset),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("stop","",Class<IFunction>::getFunction(stop),NORMAL_METHOD,true);
-}
-
-ASFUNCTIONBODY(Timer,_constructor)
-{
-	EventDispatcher::_constructor(obj,NULL,0);
-	Timer* th=static_cast<Timer*>(obj);
-
-	th->delay=args[0]->toInt();
-	if(argslen>=2)
-		th->repeatCount=args[1]->toInt();
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(Timer,_getCurrentCount)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	return abstract_i(th->currentCount);
-}
-
-ASFUNCTIONBODY(Timer,_getRepeatCount)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	return abstract_i(th->repeatCount);
-}
-
-ASFUNCTIONBODY(Timer,_setRepeatCount)
-{
-	assert_and_throw(argslen==1);
-	int32_t count=args[0]->toInt();
-	Timer* th=static_cast<Timer*>(obj);
-	th->repeatCount=count;
-	if(th->repeatCount>0 && th->repeatCount<=th->currentCount)
-	{
-		getSys()->removeJob(th);
-		th->running=false;
-		th->tickJobInstance = NullRef;
-	}
-	return NULL;
-}
-
-ASFUNCTIONBODY(Timer,_getRunning)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	return abstract_b(th->running);
-}
-
-ASFUNCTIONBODY(Timer,_getDelay)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	return abstract_i(th->delay);
-}
-
-ASFUNCTIONBODY(Timer,_setDelay)
-{
-	assert_and_throw(argslen==1);
-	int32_t newdelay = args[0]->toInt();
-	if (newdelay<=0)
-		throw Class<RangeError>::getInstanceS("delay must be positive", 2066);
-
-	Timer* th=static_cast<Timer*>(obj);
-	th->delay=newdelay;
-
-	return NULL;
-}
-
-ASFUNCTIONBODY(Timer,start)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	if(th->running)
-		return NULL;
-	th->running=true;
-	th->stopMe=false;
-	th->incRef();
-	th->tickJobInstance = _MNR(th);
-	if(th->repeatCount==1)
-		getSys()->addWait(th->delay,th);
-	else
-		getSys()->addTick(th->delay,th);
-	return NULL;
-}
-
-ASFUNCTIONBODY(Timer,reset)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	if(th->running)
-	{
-		//This spin waits if the timer is running right now
-		getSys()->removeJob(th);
-		//NOTE: although no new events will be sent now there might be old events in the queue.
-		//Is this behaviour right?
-		//This is not anymore used by the timer, so it can die
-		th->tickJobInstance = NullRef;
-		th->running=false;
-	}
-	th->currentCount=0;
-	return NULL;
-}
-
-ASFUNCTIONBODY(Timer,stop)
-{
-	Timer* th=static_cast<Timer*>(obj);
-	if(th->running)
-	{
-		//This spin waits if the timer is running right now
-		getSys()->removeJob(th);
-		//NOTE: although no new events will be sent now there might be old events in the queue.
-		//Is this behaviour right?
-
-		//This is not anymore used by the timer, so it can die
-		th->tickJobInstance = NullRef;
-		th->running=false;
-	}
-	return NULL;
-}
 
 ASFUNCTIONBODY(lightspark,getQualifiedClassName)
 {
@@ -1518,430 +174,6 @@
 	return abstract_i(ret);
 }
 
-Dictionary::Dictionary(Class_base* c):ASObject(c),
-	data(std::less<dictType::key_type>(), reporter_allocator<dictType::value_type>(c->memoryAccount))
-{
-}
-
-void Dictionary::finalize()
-{
-	ASObject::finalize();
-	data.clear();
-}
-
-void Dictionary::sinit(Class_base* c)
-{
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-}
-
-void Dictionary::buildTraits(ASObject* o)
-{
-}
-
-ASFUNCTIONBODY(Dictionary,_constructor)
-{
-	return NULL;
-}
-
-Dictionary::dictType::iterator Dictionary::findKey(ASObject *o)
-{
-	Dictionary::dictType::iterator it = data.begin();
-	for(; it!=data.end(); ++it)
-	{
-		if (it->first->isEqualStrict(o))
-			return it;
-	}
-
-	return data.end();
-}
-
-void Dictionary::setVariableByMultiname_i(const multiname& name, int32_t value)
-{
-	assert_and_throw(implEnable);
-	Dictionary::setVariableByMultiname(name,abstract_i(value),CONST_NOT_ALLOWED);
-}
-
-void Dictionary::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
-{
-	assert_and_throw(implEnable);
-	if(name.name_type==multiname::NAME_OBJECT)
-	{
-		name.name_o->incRef();
-		_R<ASObject> name_o(name.name_o);
-
-		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
-		if(it!=data.end())
-			it->second=_MR(o);
-		else
-			data.insert(make_pair(name_o,_MR(o)));
-	}
-	else
-	{
-		//Primitive types _must_ be handled by the normal ASObject path
-		//REFERENCE: Dictionary Object on AS3 reference
-		assert(name.name_type==multiname::NAME_STRING ||
-			name.name_type==multiname::NAME_INT ||
-			name.name_type==multiname::NAME_NUMBER);
-		ASObject::setVariableByMultiname(name, o, allowConst);
-	}
-}
-
-bool Dictionary::deleteVariableByMultiname(const multiname& name)
-{
-	assert_and_throw(implEnable);
-
-	if(name.name_type==multiname::NAME_OBJECT)
-	{
-		name.name_o->incRef();
-		_R<ASObject> name_o(name.name_o);
-
-		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
-		if(it != data.end())
-		{
-			data.erase(it);
-			return true;
-		}
-		return false;
-	}
-	else
-	{
-		//Primitive types _must_ be handled by the normal ASObject path
-		//REFERENCE: Dictionary Object on AS3 reference
-		assert(name.name_type==multiname::NAME_STRING ||
-			name.name_type==multiname::NAME_INT ||
-			name.name_type==multiname::NAME_NUMBER);
-		return ASObject::deleteVariableByMultiname(name);
-	}
-}
-
-_NR<ASObject> Dictionary::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
-{
-	if((opt & ASObject::SKIP_IMPL)==0 && implEnable)
-	{
-		if(name.name_type==multiname::NAME_OBJECT)
-		{
-			name.name_o->incRef();
-			_R<ASObject> name_o(name.name_o);
-
-			Dictionary::dictType::iterator it=findKey(name_o.getPtr());
-			if(it != data.end())
-				return it->second;
-			else
-				return NullRef;
-		}
-		else
-		{
-			//Primitive types _must_ be handled by the normal ASObject path
-			//REFERENCE: Dictionary Object on AS3 reference
-			assert(name.name_type==multiname::NAME_STRING ||
-				name.name_type==multiname::NAME_INT ||
-				name.name_type==multiname::NAME_NUMBER);
-			return ASObject::getVariableByMultiname(name, opt);
-		}
-	}
-	//Try with the base implementation
-	return ASObject::getVariableByMultiname(name, opt);
-}
-
-bool Dictionary::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
-{
-	if(considerDynamic==false)
-		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
-
-	if(name.name_type==multiname::NAME_OBJECT)
-	{
-		name.name_o->incRef();
-		_R<ASObject> name_o(name.name_o);
-
-		Dictionary::dictType::iterator it=findKey(name_o.getPtr());
-		return it != data.end();
-	}
-	else
-	{
-		//Primitive types _must_ be handled by the normal ASObject path
-		//REFERENCE: Dictionary Object on AS3 reference
-		assert(name.name_type==multiname::NAME_STRING ||
-			name.name_type==multiname::NAME_INT ||
-			name.name_type==multiname::NAME_NUMBER);
-		return ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
-	}
-}
-
-uint32_t Dictionary::nextNameIndex(uint32_t cur_index)
-{
-	assert_and_throw(implEnable);
-	if(cur_index<data.size())
-		return cur_index+1;
-	else
-	{
-		//Fall back on object properties
-		uint32_t ret=ASObject::nextNameIndex(cur_index-data.size());
-		if(ret==0)
-			return 0;
-		else
-			return ret+data.size();
-
-	}
-}
-
-_R<ASObject> Dictionary::nextName(uint32_t index)
-{
-	assert_and_throw(implEnable);
-	if(index<=data.size())
-	{
-		map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
-		for(unsigned int i=1;i<index;i++)
-			++it;
-
-		return it->first;
-	}
-	else
-	{
-		//Fall back on object properties
-		return ASObject::nextName(index-data.size());
-	}
-}
-
-_R<ASObject> Dictionary::nextValue(uint32_t index)
-{
-	assert_and_throw(implEnable);
-	if(index<=data.size())
-	{
-		map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
-		for(unsigned int i=1;i<index;i++)
-			++it;
-
-		return it->second;
-	}
-	else
-	{
-		//Fall back on object properties
-		return ASObject::nextValue(index-data.size());
-	}
-}
-
-tiny_string Dictionary::toString()
-{
-	std::stringstream retstr;
-	retstr << "{";
-	map<_R<ASObject>,_R<ASObject> >::iterator it=data.begin();
-	while(it != data.end())
-	{
-		if(it != data.begin())
-			retstr << ", ";
-		retstr << "{" << it->first->toString() << ", " << it->second->toString() << "}";
-		++it;
-	}
-	retstr << "}";
-
-	return retstr.str();
-}
-
-void Proxy::sinit(Class_base* c)
-{
-	//c->constructor=Class<IFunction>::getFunction(_constructor);
-	c->setConstructor(NULL);
-}
-
-void Proxy::buildTraits(ASObject* o)
-{
-}
-
-void Proxy::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
-{
-	//If a variable named like this already exist, use that
-	if(ASObject::hasPropertyByMultiname(name, true, false) || !implEnable)
-	{
-		ASObject::setVariableByMultiname(name,o,allowConst);
-		return;
-	}
-
-	//Check if there is a custom setter defined, skipping implementation to avoid recursive calls
-	multiname setPropertyName(NULL);
-	setPropertyName.name_type=multiname::NAME_STRING;
-	setPropertyName.name_s_id=getSys()->getUniqueStringId("setProperty");
-	setPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> proxySetter=getVariableByMultiname(setPropertyName,ASObject::SKIP_IMPL);
-
-	if(proxySetter.isNull())
-	{
-		ASObject::setVariableByMultiname(name,o,allowConst);
-		return;
-	}
-
-	assert_and_throw(proxySetter->getObjectType()==T_FUNCTION);
-
-	IFunction* f=static_cast<IFunction*>(proxySetter.getPtr());
-
-	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
-	ASObject* args[2];
-	args[0]=Class<ASString>::getInstanceS(name.normalizedName());
-	args[1]=o;
-	//We now suppress special handling
-	implEnable=false;
-	LOG(LOG_CALLS,_("Proxy::setProperty"));
-	incRef();
-	_R<ASObject> ret=_MR( f->call(this,args,2) );
-	assert_and_throw(ret->is<Undefined>());
-	implEnable=true;
-}
-
-_NR<ASObject> Proxy::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
-{
-	//It seems that various kind of implementation works only with the empty namespace
-	assert_and_throw(name.ns.size()>0);
-	if(!name.ns[0].hasEmptyName() || ASObject::hasPropertyByMultiname(name, true, true) || !implEnable || (opt & ASObject::SKIP_IMPL)!=0)
-		return ASObject::getVariableByMultiname(name,opt);
-
-	//Check if there is a custom getter defined, skipping implementation to avoid recursive calls
-	multiname getPropertyName(NULL);
-	getPropertyName.name_type=multiname::NAME_STRING;
-	getPropertyName.name_s_id=getSys()->getUniqueStringId("getProperty");
-	getPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> o=getVariableByMultiname(getPropertyName,ASObject::SKIP_IMPL);
-
-	if(o.isNull())
-		return ASObject::getVariableByMultiname(name,opt);
-
-	assert_and_throw(o->getObjectType()==T_FUNCTION);
-
-	IFunction* f=static_cast<IFunction*>(o.getPtr());
-
-	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
-	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
-	//We now suppress special handling
-	implEnable=false;
-	LOG(LOG_CALLS,"Proxy::getProperty");
-	incRef();
-	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
-	implEnable=true;
-	return ret;
-}
-
-bool Proxy::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
-{
-	//If a variable named like this already exist, use that
-	bool asobject_has_property=ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
-	if(asobject_has_property || !implEnable)
-		return asobject_has_property;
-
-	//Check if there is a custom hasProperty defined, skipping implementation to avoid recursive calls
-	multiname hasPropertyName(NULL);
-	hasPropertyName.name_type=multiname::NAME_STRING;
-	hasPropertyName.name_s_id=getSys()->getUniqueStringId("hasProperty");
-	hasPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> proxyHasProperty=getVariableByMultiname(hasPropertyName,ASObject::SKIP_IMPL);
-
-	if(proxyHasProperty.isNull())
-	{
-		return false;
-	}
-
-	assert_and_throw(proxyHasProperty->getObjectType()==T_FUNCTION);
-
-	IFunction* f=static_cast<IFunction*>(proxyHasProperty.getPtr());
-
-	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
-	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
-	//We now suppress special handling
-	implEnable=false;
-	LOG(LOG_CALLS,_("Proxy::hasProperty"));
-	incRef();
-	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
-	implEnable=true;
-	Boolean* b = static_cast<Boolean*>(ret.getPtr());
-	return b->val;
-}
-bool Proxy::deleteVariableByMultiname(const multiname& name)
-{
-	//If a variable named like this already exist, use that
-	if(ASObject::hasPropertyByMultiname(name, true, false) || !implEnable)
-	{
-		return ASObject::deleteVariableByMultiname(name);
-	}
-
-	//Check if there is a custom deleter defined, skipping implementation to avoid recursive calls
-	multiname deletePropertyName(NULL);
-	deletePropertyName.name_type=multiname::NAME_STRING;
-	deletePropertyName.name_s_id=getSys()->getUniqueStringId("deleteProperty");
-	deletePropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> proxyDeleter=getVariableByMultiname(deletePropertyName,ASObject::SKIP_IMPL);
-
-	if(proxyDeleter.isNull())
-	{
-		return ASObject::deleteVariableByMultiname(name);
-	}
-
-	assert_and_throw(proxyDeleter->getObjectType()==T_FUNCTION);
-
-	IFunction* f=static_cast<IFunction*>(proxyDeleter.getPtr());
-
-	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
-	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
-	//We now suppress special handling
-	implEnable=false;
-	LOG(LOG_CALLS,_("Proxy::deleteProperty"));
-	incRef();
-	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
-	implEnable=true;
-	Boolean* b = static_cast<Boolean*>(ret.getPtr());
-	return b->val;
-}
-
-uint32_t Proxy::nextNameIndex(uint32_t cur_index)
-{
-	assert_and_throw(implEnable);
-	LOG(LOG_CALLS,"Proxy::nextNameIndex");
-	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
-	multiname nextNameIndexName(NULL);
-	nextNameIndexName.name_type=multiname::NAME_STRING;
-	nextNameIndexName.name_s_id=getSys()->getUniqueStringId("nextNameIndex");
-	nextNameIndexName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> o=getVariableByMultiname(nextNameIndexName,ASObject::SKIP_IMPL);
-	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
-	IFunction* f=static_cast<IFunction*>(o.getPtr());
-	ASObject* arg=abstract_i(cur_index);
-	this->incRef();
-	ASObject* ret=f->call(this,&arg,1);
-	uint32_t newIndex=ret->toInt();
-	ret->decRef();
-	return newIndex;
-}
-
-_R<ASObject> Proxy::nextName(uint32_t index)
-{
-	assert_and_throw(implEnable);
-	LOG(LOG_CALLS, _("Proxy::nextName"));
-	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
-	multiname nextNameName(NULL);
-	nextNameName.name_type=multiname::NAME_STRING;
-	nextNameName.name_s_id=getSys()->getUniqueStringId("nextName");
-	nextNameName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> o=getVariableByMultiname(nextNameName,ASObject::SKIP_IMPL);
-	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
-	IFunction* f=static_cast<IFunction*>(o.getPtr());
-	ASObject* arg=abstract_i(index);
-	incRef();
-	return _MR(f->call(this,&arg,1));
-}
-
-_R<ASObject> Proxy::nextValue(uint32_t index)
-{
-	assert_and_throw(implEnable);
-	LOG(LOG_CALLS, _("Proxy::nextValue"));
-	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
-	multiname nextValueName(NULL);
-	nextValueName.name_type=multiname::NAME_STRING;
-	nextValueName.name_s_id=getSys()->getUniqueStringId("nextValue");
-	nextValueName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
-	_NR<ASObject> o=getVariableByMultiname(nextValueName,ASObject::SKIP_IMPL);
-	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
-	IFunction* f=static_cast<IFunction*>(o.getPtr());
-	ASObject* arg=abstract_i(index);
-	incRef();
-	return _MR(f->call(this,&arg,1));
-}
 
 ASFUNCTIONBODY(lightspark,setInterval)
 {
@@ -2002,118 +234,3 @@
 	getSys()->intervalManager->clearInterval(args[0]->toInt(), IntervalRunner::TIMEOUT, true);
 	return NULL;
 }
-
-IntervalRunner::IntervalRunner(IntervalRunner::INTERVALTYPE _type, uint32_t _id, _R<IFunction> _callback, ASObject** _args,
-		const unsigned int _argslen, _R<ASObject> _obj, uint32_t _interval):
-	EventDispatcher(NULL),type(_type), id(_id), callback(_callback),obj(_obj),argslen(_argslen),interval(_interval)
-{
-	args = new ASObject*[argslen];
-	for(uint32_t i=0; i<argslen; i++)
-		args[i] = _args[i];
-}
-
-IntervalRunner::~IntervalRunner()
-{
-	for(uint32_t i=0; i<argslen; i++)
-		args[i]->decRef();
-	delete[] args;
-}
-
-void IntervalRunner::tick() 
-{
-	//incRef all arguments
-	uint32_t i;
-	for(i=0; i < argslen; i++)
-	{
-		args[i]->incRef();
-	}
-	_R<FunctionEvent> event(new (getSys()->unaccountedMemory) FunctionEvent(callback, obj, args, argslen));
-	getVm()->addEvent(NullRef,event);
-	if(type == TIMEOUT)
-	{
-		//TODO: IntervalRunner deletes itself. Is this allowed?
-		//Delete ourselves from the active intervals list
-		getSys()->intervalManager->clearInterval(id, TIMEOUT, false);
-		//No actions may be performed after this point
-	}
-}
-
-void IntervalRunner::tickFence()
-{
-	delete this;
-}
-
-IntervalManager::IntervalManager() : currentID(1)
-{
-}
-
-IntervalManager::~IntervalManager()
-{
-	//Run through all running intervals and remove their tickjob, delete their intervalRunner and erase their entry
-	std::map<uint32_t,IntervalRunner*>::iterator it = runners.begin();
-	while(it != runners.end())
-	{
-		getSys()->removeJob((*it).second);
-		runners.erase(it++);
-	}
-}
-
-uint32_t IntervalManager::setInterval(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, uint32_t interval)
-{
-	Mutex::Lock l(mutex);
-
-	uint32_t id = getFreeID();
-	IntervalRunner* runner = new (getSys()->unaccountedMemory)
-		IntervalRunner(IntervalRunner::INTERVAL, id, callback, args, argslen, obj, interval);
-
-	//Add runner as tickjob
-	getSys()->addTick(interval, runner);
-	//Add runner to map
-	runners[id] = runner;
-	//Increment currentID
-	currentID++;
-
-	return currentID-1;
-}
-uint32_t IntervalManager::setTimeout(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, uint32_t interval)
-{
-	Mutex::Lock l(mutex);
-
-	uint32_t id = getFreeID();
-	IntervalRunner* runner = new (getSys()->unaccountedMemory)
-		IntervalRunner(IntervalRunner::TIMEOUT, id, callback, args, argslen, obj, interval);
-
-	//Add runner as waitjob
-	getSys()->addWait(interval, runner);
-	//Add runner to map
-	runners[id] = runner;
-	//increment currentID
-	currentID++;
-
-	return currentID-1;
-}
-
-uint32_t IntervalManager::getFreeID()
-{
-	//At the first run every currentID will be available. But eventually the currentID will wrap around.
-	//Thats why we need to check if the currentID isn't used yet
-	while(currentID == 0 || runners.count(currentID) != 0)
-		currentID++;
-	return currentID;
-}
-
-void IntervalManager::clearInterval(uint32_t id, IntervalRunner::INTERVALTYPE type, bool removeJob)
-{
-	Mutex::Lock l(mutex);
-
-	std::map<uint32_t,IntervalRunner*>::iterator it = runners.find(id);
-	//If the entry exists and the types match, remove its tickjob, delete its intervalRunner and erase their entry
-	if(it != runners.end() && (*it).second->getType() == type)
-	{
-		if(removeJob)
-		{
-			getSys()->removeJob((*it).second);
-		}
-		runners.erase(it);
-	}
-}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/flashutils.h lightspark-0.7.2/src/scripting/flash/utils/flashutils.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/flashutils.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/flashutils.h	2013-11-09 19:23:31.000000000 +0200
@@ -22,11 +22,8 @@
 
 #include "compat.h"
 #include "swftypes.h"
-#include "scripting/flash/events/flashevents.h"
-#include "thread_pool.h"
-#include "timer.h"
+#include "asobject.h"
 
-#include <map>
 
 namespace lightspark
 {
@@ -59,203 +56,7 @@
 	static void linkTraits(Class_base* c);
 };
 
-class ByteArray: public ASObject, public IDataInput, public IDataOutput
-{
-friend class LoaderThread;
-friend class URLLoader;
-protected:
-	bool littleEndian;
-	uint8_t objectEncoding;
-	uint32_t position;
-	uint8_t* bytes;
-	uint32_t real_len;
-	uint32_t len;
-	void compress_zlib();
-	void uncompress_zlib();
-public:
-	ByteArray(Class_base* c, uint8_t* b = NULL, uint32_t l = 0);
-	~ByteArray();
-	//Helper interface for serialization
-	bool readByte(uint8_t& b);
-	bool readShort(uint16_t& ret);
-	bool readUnsignedInt(uint32_t& ret);
-	bool readU29(uint32_t& ret);
-	bool readUTF(tiny_string& ret);
-	void writeByte(uint8_t b);
-	void writeShort(uint16_t val);
-	void writeUnsignedInt(uint32_t val);
-	void writeUTF(const tiny_string& str);
-	uint32_t writeObject(ASObject* obj);
-	void writeStringVR(std::map<tiny_string, uint32_t>& stringMap, const tiny_string& s);
-	void writeXMLString(std::map<const ASObject*, uint32_t>& objMap, ASObject *xml, const tiny_string& s);
-	void writeU29(uint32_t val);
-	uint32_t getPosition() const;
-	void setPosition(uint32_t p);
-
-	ASFUNCTION(_getBytesAvailable);
-	ASFUNCTION(_getLength);
-	ASFUNCTION(_setLength);
-	ASFUNCTION(_getPosition);
-	ASFUNCTION(_setPosition);
-	ASFUNCTION(_getEndian);
-	ASFUNCTION(_setEndian);
-	ASFUNCTION(_getObjectEncoding);
-	ASFUNCTION(_setObjectEncoding);
-	ASFUNCTION(_getDefaultObjectEncoding);
-	ASFUNCTION(_setDefaultObjectEncoding);
-	ASFUNCTION(_compress);
-	ASFUNCTION(_uncompress);
-	ASFUNCTION(_deflate);
-	ASFUNCTION(_inflate);
-	ASFUNCTION(clear);
-	ASFUNCTION(readBoolean);
-	ASFUNCTION(readByte);
-	ASFUNCTION(readBytes);
-	ASFUNCTION(readDouble);
-	ASFUNCTION(readFloat);
-	ASFUNCTION(readInt);
-	ASFUNCTION(readMultiByte);
-	ASFUNCTION(readObject);
-	ASFUNCTION(readShort);
-	ASFUNCTION(readUnsignedByte);
-	ASFUNCTION(readUnsignedInt);
-	ASFUNCTION(readUnsignedShort);
-	ASFUNCTION(readUTF);
-	ASFUNCTION(readUTFBytes);
-	ASFUNCTION(writeBoolean);
-	ASFUNCTION(writeByte);
-	ASFUNCTION(writeBytes);
-	ASFUNCTION(writeDouble);
-	ASFUNCTION(writeFloat);
-	ASFUNCTION(writeInt);
-	ASFUNCTION(writeUnsignedInt);
-	ASFUNCTION(writeMultiByte);
-	ASFUNCTION(writeObject);
-	ASFUNCTION(writeShort);
-	ASFUNCTION(writeUTF);
-	ASFUNCTION(writeUTFBytes);
-	ASFUNCTION(_toString);
-
-	// these are internal methods used if the generic Array-Methods are called on a ByteArray
-	ASFUNCTION(pop);
-	ASFUNCTION(push);
-	ASFUNCTION(shift);
-	ASFUNCTION(unshift);
-	/**
-		Get ownership over the passed buffer
-		@param buf Pointer to the buffer to acquire, ownership and delete authority is acquired
-		@param bufLen Lenght of the buffer
-		@pre buf must be allocated using new[]
-	*/
-	void acquireBuffer(uint8_t* buf, int bufLen);
-	uint8_t* getBuffer(unsigned int size, bool enableResize);
-	uint32_t getLength() const { return len; }
-
-	uint16_t endianIn(uint16_t value);
-	uint32_t endianIn(uint32_t value);
-	uint64_t endianIn(uint64_t value);
-
-	uint16_t endianOut(uint16_t value);
-	uint32_t endianOut(uint32_t value);
-	uint64_t endianOut(uint64_t value);
-
-	static void sinit(Class_base* c);
-	static void buildTraits(ASObject* o);
-	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
-	int32_t getVariableByMultiname_i(const multiname& name);
-	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
-	void setVariableByMultiname_i(const multiname& name, int32_t value);
-	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
-};
-
-class Timer: public EventDispatcher, public ITickJob
-{
-private:
-	void tick();
-	void tickFence();
-	//tickJobInstance keeps a reference to self while this
-	//instance is being used by the timer thread.
-	_NR<Timer> tickJobInstance;
-protected:
-	bool running;
-	uint32_t delay;
-	uint32_t repeatCount;
-	uint32_t currentCount;
-public:
-	Timer(Class_base* c):EventDispatcher(c),running(false),delay(0),repeatCount(0),currentCount(0){};
-	static void sinit(Class_base* c);
-	ASFUNCTION(_constructor);
-	ASFUNCTION(_getCurrentCount);
-	ASFUNCTION(_getRepeatCount);
-	ASFUNCTION(_setRepeatCount);
-	ASFUNCTION(_getRunning);
-	ASFUNCTION(_getDelay);
-	ASFUNCTION(_setDelay);
-	ASFUNCTION(start);
-	ASFUNCTION(reset);
-	ASFUNCTION(stop);
-};
 
-class Dictionary: public ASObject
-{
-friend class ABCVm;
-private:
-	typedef std::map<_R<ASObject>,_R<ASObject>,std::less<_R<ASObject>>,
-	       reporter_allocator<std::pair<const _R<ASObject>, _R<ASObject>>>> dictType;
-	dictType data;
-	dictType::iterator findKey(ASObject *);
-public:
-	Dictionary(Class_base* c);
-	void finalize();
-	static void sinit(Class_base*);
-	static void buildTraits(ASObject* o);
-	ASFUNCTION(_constructor);
-	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
-	int32_t getVariableByMultiname_i(const multiname& name)
-	{
-		assert_and_throw(implEnable);
-		throw UnsupportedException("getVariableByMultiName_i not supported for Dictionary");
-	}
-	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
-	void setVariableByMultiname_i(const multiname& name, int32_t value);
-	bool deleteVariableByMultiname(const multiname& name);
-	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
-	tiny_string toString();
-	uint32_t nextNameIndex(uint32_t cur_index);
-	_R<ASObject> nextName(uint32_t index);
-	_R<ASObject> nextValue(uint32_t index);
-};
-
-class Proxy: public ASObject
-{
-friend class ABCVm;
-public:
-	Proxy(Class_base* c):ASObject(c){}
-	static void sinit(Class_base*);
-	static void buildTraits(ASObject* o);
-//	ASFUNCTION(_constructor);
-	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
-	int32_t getVariableByMultiname_i(const multiname& name)
-	{
-		assert_and_throw(implEnable);
-		throw UnsupportedException("getVariableByMultiName_i not supported for Proxy");
-	}
-	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
-	void setVariableByMultiname_i(const multiname& name, int32_t value)
-	{
-		setVariableByMultiname(name,abstract_i(value),CONST_NOT_ALLOWED);
-	}
-	
-	bool deleteVariableByMultiname(const multiname& name);
-	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
-	tiny_string toString()
-	{
-		throw UnsupportedException("Proxy is missing some stuff");
-	}
-	uint32_t nextNameIndex(uint32_t cur_index);
-	_R<ASObject> nextName(uint32_t index);
-	_R<ASObject> nextValue(uint32_t index);
-};
 
 ASObject* getQualifiedClassName(ASObject*, ASObject* const* args, const unsigned int len);
 ASObject* getQualifiedSuperclassName(ASObject*, ASObject* const* args, const unsigned int len);
@@ -267,44 +68,6 @@
 ASObject* clearTimeout(ASObject* obj,ASObject* const* args, const unsigned int argslen);
 ASObject* describeType(ASObject* obj,ASObject* const* args, const unsigned int argslen);
 
-class IntervalRunner : public ITickJob, public EventDispatcher
-{
-public:
-	enum INTERVALTYPE { INTERVAL, TIMEOUT };
-private:
-	// IntervalRunner will delete itself in tickFence, others
-	// should not call the destructor.
-	~IntervalRunner();
-	INTERVALTYPE type;
-	uint32_t id;
-	_R<IFunction> callback;
-	ASObject** args;
-	_R<ASObject> obj;
-	const unsigned int argslen;
-	uint32_t interval;
-public:
-	IntervalRunner(INTERVALTYPE _type, uint32_t _id, _R<IFunction> _callback, ASObject** _args,
-			const unsigned int _argslen, _R<ASObject> _obj, const uint32_t _interval);
-	void tick();
-	void tickFence();
-	INTERVALTYPE getType() { return type; }
-};
-
-class IntervalManager
-{
-private:
-	Mutex mutex;
-	std::map<uint32_t,IntervalRunner*> runners;
-	uint32_t currentID;
-public:
-	IntervalManager();
-	~IntervalManager();
-	uint32_t setInterval(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, const uint32_t interval);
-	uint32_t setTimeout(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, const uint32_t interval);
-	uint32_t getFreeID();
-	void clearInterval(uint32_t id, IntervalRunner::INTERVALTYPE type, bool removeJob);
-};
-
-};
+}
 
 #endif /* SCRIPTING_FLASH_UTILS_FLASHUTILS_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalManager.cpp lightspark-0.7.2/src/scripting/flash/utils/IntervalManager.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalManager.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/IntervalManager.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,106 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "scripting/flash/utils/flashutils.h"
+#include "scripting/flash/utils/IntervalManager.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+
+using namespace std;
+using namespace lightspark;
+
+IntervalManager::IntervalManager() : currentID(1)
+{
+}
+
+IntervalManager::~IntervalManager()
+{
+	//Run through all running intervals and remove their tickjob, delete their intervalRunner and erase their entry
+	std::map<uint32_t,IntervalRunner*>::iterator it = runners.begin();
+	while(it != runners.end())
+	{
+		getSys()->removeJob((*it).second);
+		runners.erase(it++);
+	}
+}
+
+uint32_t IntervalManager::setInterval(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, uint32_t interval)
+{
+	Mutex::Lock l(mutex);
+
+	uint32_t id = getFreeID();
+	IntervalRunner* runner = new (getSys()->unaccountedMemory)
+		IntervalRunner(IntervalRunner::INTERVAL, id, callback, args, argslen, obj, interval);
+
+	//Add runner as tickjob
+	getSys()->addTick(interval, runner);
+	//Add runner to map
+	runners[id] = runner;
+	//Increment currentID
+	currentID++;
+
+	return currentID-1;
+}
+uint32_t IntervalManager::setTimeout(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, uint32_t interval)
+{
+	Mutex::Lock l(mutex);
+
+	uint32_t id = getFreeID();
+	IntervalRunner* runner = new (getSys()->unaccountedMemory)
+		IntervalRunner(IntervalRunner::TIMEOUT, id, callback, args, argslen, obj, interval);
+
+	//Add runner as waitjob
+	getSys()->addWait(interval, runner);
+	//Add runner to map
+	runners[id] = runner;
+	//increment currentID
+	currentID++;
+
+	return currentID-1;
+}
+
+uint32_t IntervalManager::getFreeID()
+{
+	//At the first run every currentID will be available. But eventually the currentID will wrap around.
+	//Thats why we need to check if the currentID isn't used yet
+	while(currentID == 0 || runners.count(currentID) != 0)
+		currentID++;
+	return currentID;
+}
+
+void IntervalManager::clearInterval(uint32_t id, IntervalRunner::INTERVALTYPE type, bool removeJob)
+{
+	Mutex::Lock l(mutex);
+
+	std::map<uint32_t,IntervalRunner*>::iterator it = runners.find(id);
+	//If the entry exists and the types match, remove its tickjob, delete its intervalRunner and erase their entry
+	if(it != runners.end() && (*it).second->getType() == type)
+	{
+		if(removeJob)
+		{
+			getSys()->removeJob((*it).second);
+		}
+		runners.erase(it);
+	}
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalManager.h lightspark-0.7.2/src/scripting/flash/utils/IntervalManager.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalManager.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/IntervalManager.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,48 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_INTERVALMANAGER_H
+#define SCRIPTING_FLASH_UTILS_INTERVALMANAGER_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+#include "scripting/flash/utils/IntervalRunner.h"
+
+
+namespace lightspark
+{
+
+class IntervalManager
+{
+private:
+	Mutex mutex;
+	std::map<uint32_t,IntervalRunner*> runners;
+	uint32_t currentID;
+public:
+	IntervalManager();
+	~IntervalManager();
+	uint32_t setInterval(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, const uint32_t interval);
+	uint32_t setTimeout(_R<IFunction> callback, ASObject** args, const unsigned int argslen, _R<ASObject> obj, const uint32_t interval);
+	uint32_t getFreeID();
+	void clearInterval(uint32_t id, IntervalRunner::INTERVALTYPE type, bool removeJob);
+};
+
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_INTERVALMANAGER_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalRunner.cpp lightspark-0.7.2/src/scripting/flash/utils/IntervalRunner.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalRunner.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/IntervalRunner.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,72 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "scripting/flash/utils/flashutils.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+
+using namespace std;
+using namespace lightspark;
+
+
+IntervalRunner::IntervalRunner(IntervalRunner::INTERVALTYPE _type, uint32_t _id, _R<IFunction> _callback, ASObject** _args,
+		const unsigned int _argslen, _R<ASObject> _obj, uint32_t _interval):
+	EventDispatcher(NULL),type(_type), id(_id), callback(_callback),obj(_obj),argslen(_argslen),interval(_interval)
+{
+	args = new ASObject*[argslen];
+	for(uint32_t i=0; i<argslen; i++)
+		args[i] = _args[i];
+}
+
+IntervalRunner::~IntervalRunner()
+{
+	for(uint32_t i=0; i<argslen; i++)
+		args[i]->decRef();
+	delete[] args;
+}
+
+void IntervalRunner::tick() 
+{
+	//incRef all arguments
+	uint32_t i;
+	for(i=0; i < argslen; i++)
+	{
+		args[i]->incRef();
+	}
+	_R<FunctionEvent> event(new (getSys()->unaccountedMemory) FunctionEvent(callback, obj, args, argslen));
+	getVm()->addEvent(NullRef,event);
+	if(type == TIMEOUT)
+	{
+		//TODO: IntervalRunner deletes itself. Is this allowed?
+		//Delete ourselves from the active intervals list
+		getSys()->intervalManager->clearInterval(id, TIMEOUT, false);
+		//No actions may be performed after this point
+	}
+}
+
+void IntervalRunner::tickFence()
+{
+	delete this;
+}
+
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalRunner.h lightspark-0.7.2/src/scripting/flash/utils/IntervalRunner.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/IntervalRunner.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/IntervalRunner.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,56 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_INTERVALRUNNER_H
+#define SCRIPTING_FLASH_UTILS_INTERVALRUNNER_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+
+
+namespace lightspark
+{
+
+class IntervalRunner : public ITickJob, public EventDispatcher
+{
+public:
+	enum INTERVALTYPE { INTERVAL, TIMEOUT };
+private:
+	// IntervalRunner will delete itself in tickFence, others
+	// should not call the destructor.
+	~IntervalRunner();
+	INTERVALTYPE type;
+	uint32_t id;
+	_R<IFunction> callback;
+	ASObject** args;
+	_R<ASObject> obj;
+	const unsigned int argslen;
+	uint32_t interval;
+public:
+	IntervalRunner(INTERVALTYPE _type, uint32_t _id, _R<IFunction> _callback, ASObject** _args,
+			const unsigned int _argslen, _R<ASObject> _obj, const uint32_t _interval);
+	void tick();
+	void tickFence();
+	INTERVALTYPE getType() { return type; }
+};
+
+
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_FLASHUTILS_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Proxy.cpp lightspark-0.7.2/src/scripting/flash/utils/Proxy.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Proxy.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Proxy.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,241 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "scripting/flash/utils/flashutils.h"
+#include "scripting/flash/utils/Proxy.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+#include <sstream>
+#include <zlib.h>
+#include <glib.h>
+
+using namespace std;
+using namespace lightspark;
+
+
+
+void Proxy::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, CLASS_SEALED);
+}
+
+void Proxy::buildTraits(ASObject* o)
+{
+}
+
+void Proxy::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
+{
+	//If a variable named like this already exist, use that
+	if(ASObject::hasPropertyByMultiname(name, true, false) || !implEnable)
+	{
+		ASObject::setVariableByMultiname(name,o,allowConst);
+		return;
+	}
+
+	//Check if there is a custom setter defined, skipping implementation to avoid recursive calls
+	multiname setPropertyName(NULL);
+	setPropertyName.name_type=multiname::NAME_STRING;
+	setPropertyName.name_s_id=getSys()->getUniqueStringId("setProperty");
+	setPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> proxySetter=getVariableByMultiname(setPropertyName,ASObject::SKIP_IMPL);
+
+	if(proxySetter.isNull())
+	{
+		ASObject::setVariableByMultiname(name,o,allowConst);
+		return;
+	}
+
+	assert_and_throw(proxySetter->getObjectType()==T_FUNCTION);
+
+	IFunction* f=static_cast<IFunction*>(proxySetter.getPtr());
+
+	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
+	ASObject* args[2];
+	args[0]=Class<ASString>::getInstanceS(name.normalizedName());
+	args[1]=o;
+	//We now suppress special handling
+	implEnable=false;
+	LOG(LOG_CALLS,_("Proxy::setProperty"));
+	incRef();
+	_R<ASObject> ret=_MR( f->call(this,args,2) );
+	assert_and_throw(ret->is<Undefined>());
+	implEnable=true;
+}
+
+_NR<ASObject> Proxy::getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt)
+{
+	//It seems that various kind of implementation works only with the empty namespace
+	assert_and_throw(name.ns.size()>0);
+	if(!name.ns[0].hasEmptyName() || ASObject::hasPropertyByMultiname(name, true, true) || !implEnable || (opt & ASObject::SKIP_IMPL)!=0)
+		return ASObject::getVariableByMultiname(name,opt);
+
+	//Check if there is a custom getter defined, skipping implementation to avoid recursive calls
+	multiname getPropertyName(NULL);
+	getPropertyName.name_type=multiname::NAME_STRING;
+	getPropertyName.name_s_id=getSys()->getUniqueStringId("getProperty");
+	getPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> o=getVariableByMultiname(getPropertyName,ASObject::SKIP_IMPL);
+
+	if(o.isNull())
+		return ASObject::getVariableByMultiname(name,opt);
+
+	assert_and_throw(o->getObjectType()==T_FUNCTION);
+
+	IFunction* f=static_cast<IFunction*>(o.getPtr());
+
+	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
+	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
+	//We now suppress special handling
+	implEnable=false;
+	LOG(LOG_CALLS,"Proxy::getProperty");
+	incRef();
+	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
+	implEnable=true;
+	return ret;
+}
+
+bool Proxy::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype)
+{
+	//If a variable named like this already exist, use that
+	bool asobject_has_property=ASObject::hasPropertyByMultiname(name, considerDynamic, considerPrototype);
+	if(asobject_has_property || !implEnable)
+		return asobject_has_property;
+
+	//Check if there is a custom hasProperty defined, skipping implementation to avoid recursive calls
+	multiname hasPropertyName(NULL);
+	hasPropertyName.name_type=multiname::NAME_STRING;
+	hasPropertyName.name_s_id=getSys()->getUniqueStringId("hasProperty");
+	hasPropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> proxyHasProperty=getVariableByMultiname(hasPropertyName,ASObject::SKIP_IMPL);
+
+	if(proxyHasProperty.isNull())
+	{
+		return false;
+	}
+
+	assert_and_throw(proxyHasProperty->getObjectType()==T_FUNCTION);
+
+	IFunction* f=static_cast<IFunction*>(proxyHasProperty.getPtr());
+
+	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
+	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
+	//We now suppress special handling
+	implEnable=false;
+	LOG(LOG_CALLS,_("Proxy::hasProperty"));
+	incRef();
+	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
+	implEnable=true;
+	Boolean* b = static_cast<Boolean*>(ret.getPtr());
+	return b->val;
+}
+bool Proxy::deleteVariableByMultiname(const multiname& name)
+{
+	//If a variable named like this already exist, use that
+	if(ASObject::hasPropertyByMultiname(name, true, false) || !implEnable)
+	{
+		return ASObject::deleteVariableByMultiname(name);
+	}
+
+	//Check if there is a custom deleter defined, skipping implementation to avoid recursive calls
+	multiname deletePropertyName(NULL);
+	deletePropertyName.name_type=multiname::NAME_STRING;
+	deletePropertyName.name_s_id=getSys()->getUniqueStringId("deleteProperty");
+	deletePropertyName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> proxyDeleter=getVariableByMultiname(deletePropertyName,ASObject::SKIP_IMPL);
+
+	if(proxyDeleter.isNull())
+	{
+		return ASObject::deleteVariableByMultiname(name);
+	}
+
+	assert_and_throw(proxyDeleter->getObjectType()==T_FUNCTION);
+
+	IFunction* f=static_cast<IFunction*>(proxyDeleter.getPtr());
+
+	//Well, I don't how to pass multiname to an as function. I'll just pass the name as a string
+	ASObject* arg=Class<ASString>::getInstanceS(name.normalizedName());
+	//We now suppress special handling
+	implEnable=false;
+	LOG(LOG_CALLS,_("Proxy::deleteProperty"));
+	incRef();
+	_NR<ASObject> ret=_MNR(f->call(this,&arg,1));
+	implEnable=true;
+	Boolean* b = static_cast<Boolean*>(ret.getPtr());
+	return b->val;
+}
+
+uint32_t Proxy::nextNameIndex(uint32_t cur_index)
+{
+	assert_and_throw(implEnable);
+	LOG(LOG_CALLS,"Proxy::nextNameIndex");
+	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
+	multiname nextNameIndexName(NULL);
+	nextNameIndexName.name_type=multiname::NAME_STRING;
+	nextNameIndexName.name_s_id=getSys()->getUniqueStringId("nextNameIndex");
+	nextNameIndexName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> o=getVariableByMultiname(nextNameIndexName,ASObject::SKIP_IMPL);
+	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
+	IFunction* f=static_cast<IFunction*>(o.getPtr());
+	ASObject* arg=abstract_i(cur_index);
+	this->incRef();
+	ASObject* ret=f->call(this,&arg,1);
+	uint32_t newIndex=ret->toInt();
+	ret->decRef();
+	return newIndex;
+}
+
+_R<ASObject> Proxy::nextName(uint32_t index)
+{
+	assert_and_throw(implEnable);
+	LOG(LOG_CALLS, _("Proxy::nextName"));
+	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
+	multiname nextNameName(NULL);
+	nextNameName.name_type=multiname::NAME_STRING;
+	nextNameName.name_s_id=getSys()->getUniqueStringId("nextName");
+	nextNameName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> o=getVariableByMultiname(nextNameName,ASObject::SKIP_IMPL);
+	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
+	IFunction* f=static_cast<IFunction*>(o.getPtr());
+	ASObject* arg=abstract_i(index);
+	incRef();
+	return _MR(f->call(this,&arg,1));
+}
+
+_R<ASObject> Proxy::nextValue(uint32_t index)
+{
+	assert_and_throw(implEnable);
+	LOG(LOG_CALLS, _("Proxy::nextValue"));
+	//Check if there is a custom enumerator, skipping implementation to avoid recursive calls
+	multiname nextValueName(NULL);
+	nextValueName.name_type=multiname::NAME_STRING;
+	nextValueName.name_s_id=getSys()->getUniqueStringId("nextValue");
+	nextValueName.ns.push_back(nsNameAndKind(flash_proxy,NAMESPACE));
+	_NR<ASObject> o=getVariableByMultiname(nextValueName,ASObject::SKIP_IMPL);
+	assert_and_throw(!o.isNull() && o->getObjectType()==T_FUNCTION);
+	IFunction* f=static_cast<IFunction*>(o.getPtr());
+	ASObject* arg=abstract_i(index);
+	incRef();
+	return _MR(f->call(this,&arg,1));
+}
+
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Proxy.h lightspark-0.7.2/src/scripting/flash/utils/Proxy.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Proxy.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Proxy.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,61 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_PROXY_H
+#define SCRIPTING_FLASH_UTILS_PROXY_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+
+namespace lightspark
+{
+
+class Proxy: public ASObject
+{
+friend class ABCVm;
+public:
+	Proxy(Class_base* c):ASObject(c){}
+	static void sinit(Class_base*);
+	static void buildTraits(ASObject* o);
+//	ASFUNCTION(_constructor);
+	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt=NONE);
+	int32_t getVariableByMultiname_i(const multiname& name)
+	{
+		assert_and_throw(implEnable);
+		throw UnsupportedException("getVariableByMultiName_i not supported for Proxy");
+	}
+	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
+	void setVariableByMultiname_i(const multiname& name, int32_t value)
+	{
+		setVariableByMultiname(name,abstract_i(value),CONST_NOT_ALLOWED);
+	}
+	
+	bool deleteVariableByMultiname(const multiname& name);
+	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
+	tiny_string toString()
+	{
+		throw UnsupportedException("Proxy is missing some stuff");
+	}
+	uint32_t nextNameIndex(uint32_t cur_index);
+	_R<ASObject> nextName(uint32_t index);
+	_R<ASObject> nextValue(uint32_t index);
+};
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_PROXY_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Timer.cpp lightspark-0.7.2/src/scripting/flash/utils/Timer.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Timer.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Timer.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,185 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/abc.h"
+#include "asobject.h"
+#include "scripting/class.h"
+#include "compat.h"
+#include "parsing/amf3_generator.h"
+#include "scripting/argconv.h"
+#include "scripting/flash/errors/flasherrors.h"
+#include "scripting/flash/utils/Timer.h"
+
+using namespace std;
+using namespace lightspark;
+
+void Timer::tick()
+{
+	//This will be executed once if repeatCount was originally 1
+	//Otherwise it's executed until stopMe is set to true
+	this->incRef();
+	getVm()->addEvent(_MR(this),_MR(Class<TimerEvent>::getInstanceS("timer")));
+
+	currentCount++;
+	if(repeatCount!=0)
+	{
+		if(currentCount==repeatCount)
+		{
+			this->incRef();
+			getVm()->addEvent(_MR(this),_MR(Class<TimerEvent>::getInstanceS("timerComplete")));
+			stopMe=true;
+			running=false;
+		}
+	}
+}
+
+void Timer::tickFence()
+{
+	tickJobInstance = NullRef;
+}
+
+
+void Timer::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, EventDispatcher, _constructor, CLASS_SEALED);
+	c->setDeclaredMethodByQName("currentCount","",Class<IFunction>::getFunction(_getCurrentCount),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("repeatCount","",Class<IFunction>::getFunction(_getRepeatCount),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("repeatCount","",Class<IFunction>::getFunction(_setRepeatCount),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("running","",Class<IFunction>::getFunction(_getRunning),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("delay","",Class<IFunction>::getFunction(_getDelay),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("delay","",Class<IFunction>::getFunction(_setDelay),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("start","",Class<IFunction>::getFunction(start),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("reset","",Class<IFunction>::getFunction(reset),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("stop","",Class<IFunction>::getFunction(stop),NORMAL_METHOD,true);
+}
+
+ASFUNCTIONBODY(Timer,_constructor)
+{
+	EventDispatcher::_constructor(obj,NULL,0);
+	Timer* th=static_cast<Timer*>(obj);
+
+	th->delay=args[0]->toInt();
+	if(argslen>=2)
+		th->repeatCount=args[1]->toInt();
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Timer,_getCurrentCount)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	return abstract_i(th->currentCount);
+}
+
+ASFUNCTIONBODY(Timer,_getRepeatCount)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	return abstract_i(th->repeatCount);
+}
+
+ASFUNCTIONBODY(Timer,_setRepeatCount)
+{
+	assert_and_throw(argslen==1);
+	int32_t count=args[0]->toInt();
+	Timer* th=static_cast<Timer*>(obj);
+	th->repeatCount=count;
+	if(th->repeatCount>0 && th->repeatCount<=th->currentCount)
+	{
+		getSys()->removeJob(th);
+		th->running=false;
+		th->tickJobInstance = NullRef;
+	}
+	return NULL;
+}
+
+ASFUNCTIONBODY(Timer,_getRunning)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	return abstract_b(th->running);
+}
+
+ASFUNCTIONBODY(Timer,_getDelay)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	return abstract_i(th->delay);
+}
+
+ASFUNCTIONBODY(Timer,_setDelay)
+{
+	assert_and_throw(argslen==1);
+	int32_t newdelay = args[0]->toInt();
+	if (newdelay<=0)
+		throw Class<RangeError>::getInstanceS("delay must be positive", 2066);
+
+	Timer* th=static_cast<Timer*>(obj);
+	th->delay=newdelay;
+
+	return NULL;
+}
+
+ASFUNCTIONBODY(Timer,start)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	if(th->running)
+		return NULL;
+	th->running=true;
+	th->stopMe=false;
+	th->incRef();
+	th->tickJobInstance = _MNR(th);
+	if(th->repeatCount==1)
+		getSys()->addWait(th->delay,th);
+	else
+		getSys()->addTick(th->delay,th);
+	return NULL;
+}
+
+ASFUNCTIONBODY(Timer,reset)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	if(th->running)
+	{
+		//This spin waits if the timer is running right now
+		getSys()->removeJob(th);
+		//NOTE: although no new events will be sent now there might be old events in the queue.
+		//Is this behaviour right?
+		//This is not anymore used by the timer, so it can die
+		th->tickJobInstance = NullRef;
+		th->running=false;
+	}
+	th->currentCount=0;
+	return NULL;
+}
+
+ASFUNCTIONBODY(Timer,stop)
+{
+	Timer* th=static_cast<Timer*>(obj);
+	if(th->running)
+	{
+		//This spin waits if the timer is running right now
+		getSys()->removeJob(th);
+		//NOTE: although no new events will be sent now there might be old events in the queue.
+		//Is this behaviour right?
+
+		//This is not anymore used by the timer, so it can die
+		th->tickJobInstance = NullRef;
+		th->running=false;
+	}
+	return NULL;
+}
+
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/utils/Timer.h lightspark-0.7.2/src/scripting/flash/utils/Timer.h
--- lightspark-0.7.2.orig/src/scripting/flash/utils/Timer.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/utils/Timer.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,65 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_FLASH_UTILS_TIMER_H
+#define SCRIPTING_FLASH_UTILS_TIMER_H 1
+
+#include "compat.h"
+#include "swftypes.h"
+#include "scripting/flash/events/flashevents.h"
+#include "thread_pool.h"
+#include "timer.h"
+
+
+namespace lightspark
+{
+
+
+class Timer: public EventDispatcher, public ITickJob
+{
+private:
+	void tick();
+	void tickFence();
+	//tickJobInstance keeps a reference to self while this
+	//instance is being used by the timer thread.
+	_NR<Timer> tickJobInstance;
+protected:
+	bool running;
+	uint32_t delay;
+	uint32_t repeatCount;
+	uint32_t currentCount;
+public:
+	Timer(Class_base* c):EventDispatcher(c),running(false),delay(0),repeatCount(0),currentCount(0){};
+	static void sinit(Class_base* c);
+	ASFUNCTION(_constructor);
+	ASFUNCTION(_getCurrentCount);
+	ASFUNCTION(_getRepeatCount);
+	ASFUNCTION(_setRepeatCount);
+	ASFUNCTION(_getRunning);
+	ASFUNCTION(_getDelay);
+	ASFUNCTION(_setDelay);
+	ASFUNCTION(start);
+	ASFUNCTION(reset);
+	ASFUNCTION(stop);
+};
+
+
+}
+
+#endif /* SCRIPTING_FLASH_UTILS_TIMER_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/flash/xml/flashxml.cpp lightspark-0.7.2/src/scripting/flash/xml/flashxml.cpp
--- lightspark-0.7.2.orig/src/scripting/flash/xml/flashxml.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/flash/xml/flashxml.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -20,6 +20,7 @@
 #include <libxml++/nodes/textnode.h>
 
 #include "scripting/flash/xml/flashxml.h"
+#include "scripting/flash/utils/ByteArray.h"
 #include "swf.h"
 #include "compat.h"
 #include "scripting/argconv.h"
@@ -40,8 +41,7 @@
 
 void XMLNode::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("attributes","",Class<IFunction>::getFunction(attributes),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("childNodes","",Class<IFunction>::getFunction(XMLNode::childNodes),GETTER_METHOD,true);
@@ -262,8 +262,7 @@
 
 void XMLDocument::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<XMLNode>::getRef());
+	CLASS_SETUP(c, XMLNode, _constructor, CLASS_SEALED);
 	c->setDeclaredMethodByQName("parseXML","",Class<IFunction>::getFunction(parseXML),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("firstChild","",Class<IFunction>::getFunction(XMLDocument::firstChild),GETTER_METHOD,true);
@@ -298,7 +297,8 @@
 
 void XMLDocument::parseXMLImpl(const string& str)
 {
-	rootNode=buildFromString(str, ignoreWhite);
+	bool hasParent;
+	rootNode=buildFromString(str, ignoreWhite,&hasParent);
 }
 
 ASFUNCTIONBODY(XMLDocument,_toString)
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Array.cpp lightspark-0.7.2/src/scripting/toplevel/Array.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Array.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Array.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -37,10 +37,7 @@
 
 void Array::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	// public constants
-	c->setSuper(Class<ASObject>::getRef());
-
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 	c->setVariableByQName("CASEINSENSITIVE","",abstract_d(CASEINSENSITIVE),CONSTANT_TRAIT);
 	c->setVariableByQName("DESCENDING","",abstract_d(DESCENDING),CONSTANT_TRAIT);
 	c->setVariableByQName("NUMERIC","",abstract_d(NUMERIC),CONSTANT_TRAIT);
@@ -53,39 +50,47 @@
 
 	// public functions
 	c->setDeclaredMethodByQName("concat",AS3,Class<IFunction>::getFunction(_concat,1),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("every",AS3,Class<IFunction>::getFunction(every),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("filter",AS3,Class<IFunction>::getFunction(filter),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("forEach",AS3,Class<IFunction>::getFunction(forEach),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("indexOf",AS3,Class<IFunction>::getFunction(indexOf),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("lastIndexOf",AS3,Class<IFunction>::getFunction(lastIndexOf),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("every",AS3,Class<IFunction>::getFunction(every,1),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("filter",AS3,Class<IFunction>::getFunction(filter,1),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("forEach",AS3,Class<IFunction>::getFunction(forEach,1),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("indexOf",AS3,Class<IFunction>::getFunction(indexOf,1),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lastIndexOf",AS3,Class<IFunction>::getFunction(lastIndexOf,1),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("join",AS3,Class<IFunction>::getFunction(join,1),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("map",AS3,Class<IFunction>::getFunction(_map,1),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("pop",AS3,Class<IFunction>::getFunction(_pop),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("push",AS3,Class<IFunction>::getFunction(_push_as3),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("push",AS3,Class<IFunction>::getFunction(_push_as3,1),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("reverse",AS3,Class<IFunction>::getFunction(_reverse),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("shift",AS3,Class<IFunction>::getFunction(shift),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("slice",AS3,Class<IFunction>::getFunction(slice,2),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("some",AS3,Class<IFunction>::getFunction(some),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("some",AS3,Class<IFunction>::getFunction(some,1),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("sort",AS3,Class<IFunction>::getFunction(_sort),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("sortOn",AS3,Class<IFunction>::getFunction(sortOn),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("splice",AS3,Class<IFunction>::getFunction(splice,2),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("toLocaleString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
-	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->setDeclaredMethodByQName("toLocaleString",AS3,Class<IFunction>::getFunction(_toLocaleString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("unshift",AS3,Class<IFunction>::getFunction(unshift),NORMAL_METHOD,true);
 
+	c->prototype->setVariableByQName("concat","",Class<IFunction>::getFunction(_concat,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("every","",Class<IFunction>::getFunction(every,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("filter","",Class<IFunction>::getFunction(filter,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("forEach","",Class<IFunction>::getFunction(forEach,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("indexOf","",Class<IFunction>::getFunction(indexOf,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("lastIndexOf","",Class<IFunction>::getFunction(lastIndexOf,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("join","",Class<IFunction>::getFunction(join,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("map","",Class<IFunction>::getFunction(_map,1),DYNAMIC_TRAIT);
 	// workaround, pop was encountered not in the AS3 namespace before, need to investigate it further
 	c->setDeclaredMethodByQName("pop","",Class<IFunction>::getFunction(_pop),NORMAL_METHOD,true);
 	c->prototype->setVariableByQName("pop","",Class<IFunction>::getFunction(_pop),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("push","",Class<IFunction>::getFunction(_push),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("push","",Class<IFunction>::getFunction(_push,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("reverse","",Class<IFunction>::getFunction(_reverse),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("shift","",Class<IFunction>::getFunction(shift),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("unshift","",Class<IFunction>::getFunction(unshift),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("concat","",Class<IFunction>::getFunction(_concat,1),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("slice","",Class<IFunction>::getFunction(slice,2),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("splice","",Class<IFunction>::getFunction(splice,2),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("reverse","",Class<IFunction>::getFunction(_reverse),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("join","",Class<IFunction>::getFunction(join,1),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("map",AS3,Class<IFunction>::getFunction(_map,1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("some","",Class<IFunction>::getFunction(some,1),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("sort","",Class<IFunction>::getFunction(_sort),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("sortOn","",Class<IFunction>::getFunction(sortOn),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("splice","",Class<IFunction>::getFunction(splice,2),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toLocaleString","",Class<IFunction>::getFunction(_toLocaleString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("unshift","",Class<IFunction>::getFunction(unshift),DYNAMIC_TRAIT);
 }
 
 void Array::buildTraits(ASObject* o)
@@ -95,50 +100,37 @@
 ASFUNCTIONBODY(Array,_constructor)
 {
 	Array* th=static_cast<Array*>(obj);
-
-	if(argslen==1 && (args[0]->getObjectType()==T_INTEGER || args[0]->getObjectType()==T_UINTEGER || args[0]->getObjectType()==T_NUMBER))
-	{
-		number_t size=args[0]->toNumber();
-		if (size < 0 || size > UINT32_MAX)
-			throwError<RangeError>(kArrayIndexNotIntegerError, Number::toString(size));
-		LOG(LOG_CALLS,_("Creating array of length ") << size);
-		th->resize((uint32_t)size);
-	}
-	else
-	{
-		LOG(LOG_CALLS,_("Called Array constructor"));
-		th->resize(argslen);
-		for(unsigned int i=0;i<argslen;i++)
-		{
-			args[i]->incRef();
-			th->set(i,_MR(args[i]));
-		}
-	}
+	th->constructorImpl(args, argslen);
 	return NULL;
 }
 
 ASFUNCTIONBODY(Array,generator)
 {
 	Array* th=Class<Array>::getInstanceS();
-	if(argslen==1 && (args[0]->getObjectType()==T_INTEGER || args[0]->getObjectType()==T_UINTEGER || args[0]->getObjectType()==T_NUMBER))
+	th->constructorImpl(args, argslen);
+	return th;
+}
+
+void Array::constructorImpl(ASObject* const* args, const unsigned int argslen)
+{
+	if(argslen==1 && (args[0]->is<Integer>() || args[0]->is<UInteger>() || args[0]->is<Number>()))
 	{
-		number_t size=args[0]->toNumber();
-		if (size < 0 || size > UINT32_MAX)
-			throwError<RangeError>(kArrayIndexNotIntegerError, Number::toString(size));
+		uint32_t size = args[0]->toUInt();
+		if ((number_t)size != args[0]->toNumber())
+			throwError<RangeError>(kArrayIndexNotIntegerError, Number::toString(args[0]->toNumber()));
 		LOG(LOG_CALLS,_("Creating array of length ") << size);
-		th->resize((uint32_t)size);
+		resize(size);
 	}
 	else
 	{
 		LOG(LOG_CALLS,_("Called Array constructor"));
-		th->resize(argslen);
+		resize(argslen);
 		for(unsigned int i=0;i<argslen;i++)
 		{
 			args[i]->incRef();
-			th->set(i,_MR(args[i]));
+			set(i,_MR(args[i]));
 		}
 	}
-	return th;
 }
 
 ASFUNCTIONBODY(Array,_concat)
@@ -187,10 +179,13 @@
 ASFUNCTIONBODY(Array,filter)
 {
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen==1 || argslen==2);
-	IFunction* f = static_cast<IFunction*>(args[0]);
-	ASObject* params[3];
 	Array* ret=Class<Array>::getInstanceS();
+	_NR<IFunction> f;
+	ARG_UNPACK(f);
+	if (f.isNull())
+		return ret;
+
+	ASObject* params[3];
 	ASObject *funcRet;
 
 	std::map<uint32_t, data_slot>::iterator it=th->data.begin();
@@ -203,6 +198,9 @@
 		params[2] = th;
 		th->incRef();
 
+		// ensure that return values are the original values
+		ASObject *origval = it->second.data;
+		it->second.data->incRef();
 		if(argslen==1)
 		{
 			funcRet=f->call(getSys()->getNullRef(), params, 3);
@@ -215,10 +213,9 @@
 		if(funcRet)
 		{
 			if(Boolean_concrete(funcRet))
-			{
-				it->second.data->incRef();
-				ret->push(_MR(it->second.data));
-			}
+				ret->push(_MR(origval));
+			else
+				origval->decRef();
 			funcRet->decRef();
 		}
 	}
@@ -228,8 +225,11 @@
 ASFUNCTIONBODY(Array, some)
 {
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen==1 || argslen==2);
-	IFunction* f = static_cast<IFunction*>(args[0]);
+	_NR<IFunction> f;
+	ARG_UNPACK(f);
+	if (f.isNull())
+		return abstract_b(false);
+
 	ASObject* params[3];
 	ASObject *funcRet;
 
@@ -267,8 +267,11 @@
 ASFUNCTIONBODY(Array, every)
 {
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen==1 || argslen==2);
-	IFunction* f = static_cast<IFunction*>(args[0]);
+	_NR<IFunction> f;
+	ARG_UNPACK(f);
+	if (f.isNull())
+		return abstract_b(true);
+
 	ASObject* params[3];
 	ASObject *funcRet;
 
@@ -311,9 +314,9 @@
 
 ASFUNCTIONBODY(Array,_setLength)
 {
-	assert_and_throw(argslen == 1);
+	uint32_t newLen;
+	ARG_UNPACK(newLen);
 	Array* th=static_cast<Array*>(obj);
-	uint32_t newLen=args[0]->toUInt();
 	//If newLen is equal to size do nothing
 	if(newLen==th->size())
 		return NULL;
@@ -323,9 +326,11 @@
 
 ASFUNCTIONBODY(Array,forEach)
 {
-	assert_and_throw(argslen == 1 || argslen == 2);
 	Array* th=static_cast<Array*>(obj);
-	IFunction* f = static_cast<IFunction*>(args[0]);
+	_NR<IFunction> f;
+	ARG_UNPACK(f);
+	if (f.isNull())
+		return NULL;
 	ASObject* params[3];
 
 	std::map<uint32_t, data_slot>::iterator it=th->data.begin();
@@ -374,11 +379,11 @@
 ASFUNCTIONBODY(Array,lastIndexOf)
 {
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen==1 || argslen==2);
+	_NR<ASObject> arg0;
+	ARG_UNPACK(arg0);
 	int ret=-1;
-	ASObject* arg0=args[0];
 
-	if(th->data.empty())
+	if(argslen == 1 && th->data.empty())
 		return abstract_d(0);
 
 	size_t i = th->size()-1;
@@ -410,7 +415,7 @@
 		    continue;
 		DATA_TYPE dtype = th->data[i].type;
 		assert_and_throw(dtype==DATA_OBJECT || dtype==DATA_INT);
-		if((dtype == DATA_OBJECT && th->data[i].data->isEqualStrict(arg0)) ||
+		if((dtype == DATA_OBJECT && th->data[i].data->isEqualStrict(arg0.getPtr())) ||
 			(dtype == DATA_INT && arg0->toInt() == th->data[i].data_i))
 		{
 			ret=i;
@@ -494,14 +499,10 @@
 ASFUNCTIONBODY(Array,slice)
 {
 	Array* th=static_cast<Array*>(obj);
+	int startIndex;
+	int endIndex;
 
-	int startIndex=0;
-	int endIndex=16777215;
-	if(argslen>0)
-		startIndex=args[0]->toInt();
-	if(argslen>1)
-		endIndex=args[1]->toInt();
-
+	ARG_UNPACK(startIndex, 0) (endIndex, 16777215);
 	startIndex=th->capIndex(startIndex);
 	endIndex=th->capIndex(endIndex);
 
@@ -524,13 +525,11 @@
 ASFUNCTIONBODY(Array,splice)
 {
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen >= 1);
-	int startIndex=args[0]->toInt();
+	int startIndex;
+	int deleteCount;
 	//By default, delete all the element up to the end
-	//Use the array len, it will be capped below
-	int deleteCount=th->size();
-	if(argslen > 1)
-		deleteCount=args[1]->toUInt();
+	//DeleteCount defaults to the array len, it will be capped below
+	ARG_UNPACK(startIndex) (deleteCount, th->size());
 
 	int totalSize=th->size();
 	Array* ret=Class<Array>::getInstanceS();
@@ -590,11 +589,10 @@
 ASFUNCTIONBODY(Array,join)
 {
 	Array* th=static_cast<Array*>(obj);
-	
-	tiny_string del = ",";
-	if (argslen == 1)
-	      del=args[0]->toString();
 	string ret;
+	tiny_string del;
+	ARG_UNPACK(del, ",");
+
 	for(uint32_t i=0;i<th->size();i++)
 	{
 		_R<ASObject> o = th->at(i);
@@ -610,10 +608,10 @@
 {
 	Array* th=static_cast<Array*>(obj);
 	int ret=-1;
-	int32_t index=0;
-	ASObject* arg0 = args[0];
-	if (argslen > 1) 
-		index = args[1]->toInt();
+	int32_t index;
+	_NR<ASObject> arg0;
+	ARG_UNPACK(arg0) (index, 0);
+	if (index < 0) index = abs(index);
 
 
 	DATA_TYPE dtype;
@@ -625,7 +623,7 @@
 		data_slot sl = it->second;
 		dtype = sl.type;
 		assert_and_throw(dtype==DATA_OBJECT || dtype==DATA_INT);
-		if((dtype == DATA_OBJECT && sl.data->isEqualStrict(arg0)) ||
+		if((dtype == DATA_OBJECT && sl.data->isEqualStrict(arg0.getPtr())) ||
 			(dtype == DATA_INT && arg0->toInt() == sl.data_i))
 		{
 			ret=it->first;
@@ -765,7 +763,7 @@
 	assert(comparator);
 	_NR<ASObject> ret=_MNR(comparator->call(getSys()->getNullRef(), objs, 2));
 	assert_and_throw(ret);
-	return (ret->toInt()<0); //Less
+	return (ret->toNumber()<0); //Less
 }
 
 ASFUNCTIONBODY(Array,_sort)
@@ -877,8 +875,10 @@
 
 ASFUNCTIONBODY(Array,sortOn)
 {
+	if (argslen != 1 && argslen != 2)
+		throwError<ArgumentError>(kWrongArgumentCountError, "1",
+					  Integer::toString(argslen));
 	Array* th=static_cast<Array*>(obj);
-	assert_and_throw(argslen==1 || argslen==2);
 	std::vector<sorton_field> sortfields;
 	if(args[0]->is<Array>())
 	{
@@ -1133,6 +1133,20 @@
 	return Class<ASString>::getInstanceS(th->toString_priv());
 }
 
+ASFUNCTIONBODY(Array,_toLocaleString)
+{
+	if(Class<Number>::getClass()->prototype->getObj() == obj)
+		return Class<ASString>::getInstanceS("");
+	if(!obj->is<Array>())
+	{
+		LOG(LOG_NOT_IMPLEMENTED, "generic Array::toLocaleString");
+		return Class<ASString>::getInstanceS("");
+	}
+	
+	Array* th=obj->as<Array>();
+	return Class<ASString>::getInstanceS(th->toString_priv(true));
+}
+
 int32_t Array::getVariableByMultiname_i(const multiname& name)
 {
 	assert_and_throw(implEnable);
@@ -1222,6 +1236,8 @@
 		ASObject::setVariableByMultiname_i(name,value);
 		return;
 	}
+	if (index==0xFFFFFFFF)
+		return;
 	if(index>=size())
 		resize(index+1);
 
@@ -1253,17 +1269,45 @@
 	assert_and_throw(name.ns.size()!=0);
 	if(!name.ns[0].hasEmptyName())
 		return false;
+	if (name.name_type == multiname::NAME_STRING && 
+	    !isIntegerWithoutLeadingZeros(name.normalizedName()))
+		return false;
 
 	return name.toUInt(index);
 }
 
+bool Array::isIntegerWithoutLeadingZeros(const tiny_string& value)
+{
+	if (value.empty())
+		return false;
+	else if (value == "0")
+		return true;
+
+	bool first = true;
+	for (CharIterator it=value.begin(); it!=value.end(); ++it)
+	{
+		if (!it.isdigit() || (first && *it == '0'))
+			return false;
+
+		first = false;
+	}
+	
+	return true;
+}
+
 void Array::setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst)
 {
 	assert_and_throw(implEnable);
 	uint32_t index=0;
 	if(!isValidMultiname(name,index))
 		return ASObject::setVariableByMultiname(name,o,allowConst);
-
+	// Derived classes may be sealed!
+	if (getClass() && getClass()->isSealed)
+		throwError<ReferenceError>(kWriteSealedError,
+					   name.normalizedName(),
+					   getClass()->getQualifiedClassName());
+	if (index==0xFFFFFFFF)
+		return;
 	if(index>=size())
 		resize((uint64_t)index+1);
 
@@ -1329,7 +1373,7 @@
 	return toString_priv();
 }
 
-tiny_string Array::toString_priv() const
+tiny_string Array::toString_priv(bool localized) const
 {
 	string ret;
 	for(uint32_t i=0;i<size();i++)
@@ -1340,7 +1384,12 @@
 			if(sl.type==DATA_OBJECT)
 			{
 				if(sl.data && !sl.data->is<Undefined>() && !sl.data->is<Null>())
-					ret+=sl.data->toString().raw_buf();
+				{
+					if (localized)
+						ret += sl.data->toLocaleString().raw_buf();
+					else
+						ret += sl.data->toString().raw_buf();
+				}
 			}
 			else if(sl.type==DATA_INT)
 			{
@@ -1459,6 +1508,11 @@
 
 void Array::resize(uint64_t n)
 {
+	// Bug-for-bug compatible wrapping. See Tamarin test
+	// as3/Array/length_mods.swf and Tamarin bug #685323.
+	if (n > 0xFFFFFFFF)
+		n = (n % 0x100000000);
+
 	std::map<uint32_t,data_slot>::reverse_iterator it;
 	std::map<uint32_t,data_slot>::iterator itstart = n ? data.end() : data.begin();
 	for ( it=data.rbegin() ; it != data.rend(); ++it )
@@ -1514,6 +1568,59 @@
 	}
 }
 
+tiny_string Array::toJSON(std::vector<ASObject *> &path, IFunction *replacer, const tiny_string& spaces,const tiny_string& filter)
+{
+	if (has_toJSON())
+	{
+		return call_toJSON();
+	}
+
+	tiny_string res = "[";
+	std::map<uint32_t,data_slot>::iterator it;
+	// check for cylic reference
+	if (std::find(path.begin(),path.end(), this) != path.end())
+		throwError<TypeError>(kJSONCyclicStructure);
+	path.push_back(this);
+	bool bfirst = true;
+	tiny_string newline = (spaces.empty() ? "" : "\n");
+	for (it=data.begin() ; it != data.end(); ++it)
+	{
+		if(it->second.type==DATA_OBJECT && it->second.data)
+		{
+			tiny_string subres;
+			if (replacer != NULL)
+			{
+				ASObject* params[2];
+				
+				params[0] = Class<Number>::getInstanceS(it->first);
+				params[0]->incRef();
+				params[1] = it->second.data;
+				params[1]->incRef();
+				ASObject *funcret=replacer->call(getSys()->getNullRef(), params, 2);
+				if (funcret)
+					subres = funcret->toJSON(path,NULL,spaces,filter);
+			}
+			else
+				subres = it->second.data->toJSON(path,replacer,spaces,filter);
+			if (!subres.empty())
+			{
+				if (!bfirst)
+					res += ",";
+				res += newline+spaces;
+
+				bfirst = false;
+				res += subres;
+			}
+			path.push_back(it->second.data);
+		}
+	}
+	if (!bfirst)
+		res += newline+spaces.substr_bytes(0,spaces.numBytes()/2);
+	res += "]";
+	return res;
+	
+}
+
 Array::~Array()
 {
 	Array::finalize();
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Array.h lightspark-0.7.2/src/scripting/toplevel/Array.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/Array.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Array.h	2013-11-09 19:23:31.000000000 +0200
@@ -87,8 +87,10 @@
 		sortOnComparator(const std::vector<sorton_field>& sf):fields(sf){}
 		bool operator()(const data_slot& d1, const data_slot& d2);
 	};
-	tiny_string toString_priv() const;
+	void constructorImpl(ASObject* const* args, const unsigned int argslen);
+	tiny_string toString_priv(bool localized=false) const;
 	int capIndex(int i) const;
+	static bool isIntegerWithoutLeadingZeros(const tiny_string& value);
 public:
 	Array(Class_base* c);
 	void finalize();
@@ -120,6 +122,7 @@
 	ASFUNCTION(lastIndexOf);
 	ASFUNCTION(_map);
 	ASFUNCTION(_toString);
+	ASFUNCTION(_toLocaleString);
 	ASFUNCTION(slice);
 	ASFUNCTION(every);
 	ASFUNCTION(some);
@@ -163,6 +166,7 @@
 	void serialize(ByteArray* out, std::map<tiny_string, uint32_t>& stringMap,
 				std::map<const ASObject*, uint32_t>& objMap,
 				std::map<const Class_base*, uint32_t>& traitsMap);
+	virtual tiny_string toJSON(std::vector<ASObject *> &path,IFunction* replacer, const tiny_string &spaces,const tiny_string& filter);
 };
 
 
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/ASString.cpp lightspark-0.7.2/src/scripting/toplevel/ASString.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/ASString.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/ASString.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -20,6 +20,7 @@
 #include <pcre.h>
 
 #include "scripting/toplevel/ASString.h"
+#include "scripting/flash/utils/ByteArray.h"
 #include "compat.h"
 #include "scripting/argconv.h"
 #include "parsing/amf3_generator.h"
@@ -63,7 +64,7 @@
 {
 	ASString* th=static_cast<ASString*>(obj);
 	if(args && argslen==1)
-		th->data=args[0]->toString().raw_buf();
+		th->data=args[0]->toString();
 	return NULL;
 }
 
@@ -74,9 +75,7 @@
 
 void ASString::sinit(Class_base* c)
 {
-	c->isFinal = true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL | CLASS_SEALED);
 	c->setDeclaredMethodByQName("split",AS3,Class<IFunction>::getFunction(split,2),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("substr",AS3,Class<IFunction>::getFunction(substr,2),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("substring",AS3,Class<IFunction>::getFunction(substring,2),NORMAL_METHOD,true);
@@ -456,35 +455,70 @@
 {
 	assert_and_throw(implEnable);
 
-	/* TODO: data holds a utf8-character sequence, not ascii! */
-	const char *s=data.raw_buf();
-	char *end=NULL;
-	while(g_ascii_isspace(*s))
-		s++;
-	double val=g_ascii_strtod(s, &end);
+	const char *s = data.raw_buf();
+	while (*s && isEcmaSpace(g_utf8_get_char(s)))
+		s = g_utf8_next_char(s);
+
+	double val;
+	char *end = NULL;
+	val = parseStringInfinite(s, &end);
+
+	// If did not parse as infinite, try decimal
+	if (!std::isinf(val))
+	{
+		errno = 0;
+		val = g_ascii_strtod(s, &end);
 
-	// strtod converts case-insensitive "inf" and "infinity" to
-	// inf, flash only accepts case-sensitive "Infinity".
-	if(std::isinf(val)) {
-		const char *tmp=s;
-		while(g_ascii_isspace(*tmp))
-			tmp++;
-		if(*tmp=='+' || *tmp=='-')
-			tmp++;
-		if(strncasecmp(tmp, "inf", 3)==0 && strcmp(tmp, "Infinity")!=0)
+		if (errno == ERANGE)
+		{
+			if (val == HUGE_VAL)
+				val = numeric_limits<double>::infinity();
+			else if (val == -HUGE_VAL)
+				val = -numeric_limits<double>::infinity();
+		}
+		else if (std::isinf(val))
+		{
+			// strtod accepts values such as "inf" and lowercase
+			// "infinity" which are not valid values in Flash
 			return numeric_limits<double>::quiet_NaN();
+		}
 	}
 
 	// Fail if there is any rubbish after the converted number
 	while(*end) {
-		if(!g_ascii_isspace(*end))
+		if(!isEcmaSpace(g_utf8_get_char(end)))
 			return numeric_limits<double>::quiet_NaN();
-		end++;
+		end = g_utf8_next_char(end);
 	}
 
 	return val;
 }
 
+number_t ASString::parseStringInfinite(const char *s, char **end) const
+{
+	if (end)
+		*end = const_cast<char *>(s);
+	double sign = 1.;
+	if (*s == '+')
+	{
+		sign = +1.;
+		s++;
+	}
+	else if (*s == '-')
+	{
+		sign = -1.;
+		s++;
+	}
+	if (strncmp(s, "Infinity", 8) == 0)
+	{
+		if (end)
+			*end = const_cast<char *>(s+8);
+		return sign*numeric_limits<double>::infinity();
+	}
+
+	return 0.; // not an infinite value
+}
+
 int32_t ASString::toInt()
 {
 	assert_and_throw(implEnable);
@@ -819,3 +853,17 @@
 	else
 		return Class<ASString>::getInstanceS(args[0]->toString());
 }
+
+bool ASString::isEcmaSpace(uint32_t c)
+{
+	return (c == 0x09) || (c == 0x0B) || (c == 0x0C) || (c == 0x20) ||
+		(c == 0xA0) || (c == 0x1680) || (c == 0x180E) ||
+		((c >= 0x2000) && (c <= 0x200B)) || (c == 0x202F) ||
+		(c == 0x205F) || (c == 0x3000) || (c == 0xFEFF) || 
+		isEcmaLineTerminator(c);
+}
+
+bool ASString::isEcmaLineTerminator(uint32_t c)
+{
+	return (c == 0x0A) || (c == 0x0D) || (c == 0x2028) || (c == 0x2029);
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/ASString.h lightspark-0.7.2/src/scripting/toplevel/ASString.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/ASString.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/ASString.h	2013-11-09 19:23:31.000000000 +0200
@@ -34,6 +34,7 @@
 {
 private:
 	tiny_string toString_priv() const;
+	number_t parseStringInfinite(const char *s, char **end) const;
 public:
 	ASString(Class_base* c);
 	ASString(Class_base* c, const std::string& s);
@@ -73,6 +74,8 @@
 				std::map<const ASObject*, uint32_t>& objMap,
 				std::map<const Class_base*, uint32_t>& traitsMap);
 	std::string toDebugString() { return std::string("\"") + std::string(data) + "\""; }
+	static bool isEcmaSpace(uint32_t c);
+	static bool isEcmaLineTerminator(uint32_t c);
 };
 
 template<>
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Boolean.cpp lightspark-0.7.2/src/scripting/toplevel/Boolean.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Boolean.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Boolean.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -19,6 +19,7 @@
 
 #include "scripting/toplevel/Boolean.h"
 #include "scripting/toplevel/toplevel.h"
+#include "scripting/flash/utils/ByteArray.h"
 #include "scripting/class.h"
 #include "scripting/argconv.h"
 #include "parsing/amf3_generator.h"
@@ -69,11 +70,10 @@
 
 void Boolean::sinit(Class_base* c)
 {
-	c->isFinal=true;
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("valueOf",AS3,Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	c->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
 }
 
 ASFUNCTIONBODY(Boolean,_constructor)
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Date.cpp lightspark-0.7.2/src/scripting/toplevel/Date.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Date.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Date.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -39,9 +39,7 @@
 
 void Date::sinit(Class_base* c)
 {
-	c->isFinal=true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor,7));
+	CLASS_SETUP_CONSTRUCTOR_LENGTH(c, ASObject, _constructor, 7, CLASS_FINAL);
 	c->setDeclaredMethodByQName("getTimezoneOffset",AS3,Class<IFunction>::getFunction(getTimezoneOffset),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("valueOf",AS3,Class<IFunction>::getFunction(valueOf),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("getTime",AS3,Class<IFunction>::getFunction(getTime),NORMAL_METHOD,true);
@@ -821,8 +819,13 @@
 
 ASObject* Date::msSinceEpoch()
 {
-	return abstract_d(milliseconds+extrayears/400*MS_IN_400_YEARS);
+	return abstract_d(getMsSinceEpoch());
 }
+number_t Date::getMsSinceEpoch()
+{
+	return milliseconds+extrayears/400*MS_IN_400_YEARS;
+}
+
 
 tiny_string Date::toString()
 {
@@ -1094,6 +1097,23 @@
 	
 	return res;
 }
+bool Date::isEqual(ASObject* r)
+{
+	check();
+	//if we are comparing the same object the answer is true
+	if(this==r)
+		return true;
+	if (r->is<Date>())
+		return getMsSinceEpoch() == r->as<Date>()->getMsSinceEpoch();
+	return ASObject::isEqual(r);
+}
+
+TRISTATE Date::isLess(ASObject* o)
+{
+	if (o->is<Date>())
+		return (getMsSinceEpoch() < o->as<Date>()->getMsSinceEpoch())?TTRUE:TFALSE;
+	return ASObject::isLess(o);
+}
 
 void Date::serialize(ByteArray* out, std::map<tiny_string, uint32_t>& stringMap,
 				std::map<const ASObject*, uint32_t>& objMap,
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Date.h lightspark-0.7.2/src/scripting/toplevel/Date.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/Date.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Date.h	2013-11-09 19:23:31.000000000 +0200
@@ -35,6 +35,7 @@
 	GDateTime *datetime;
 	GDateTime *datetimeUTC;
 	ASObject *msSinceEpoch();
+	number_t getMsSinceEpoch();
 	tiny_string toString_priv(bool utc, const char* formatstr) const;
 	void MakeDate(int64_t year, int64_t month, int64_t day, int64_t hour, int64_t minute, int64_t second, int64_t millisecond, bool bIsLocalTime);
 	void MakeDateFromMilliseconds(int64_t ms);
@@ -103,6 +104,9 @@
 	ASFUNCTION(toLocaleString);
 	ASFUNCTION(toLocaleDateString);
 	ASFUNCTION(toLocaleTimeString);
+
+	bool isEqual(ASObject* r);
+	TRISTATE isLess(ASObject* r);
 	tiny_string toString();
 	//Serialization interface
 	void serialize(ByteArray* out, std::map<tiny_string, uint32_t>& stringMap,
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Error.cpp lightspark-0.7.2/src/scripting/toplevel/Error.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Error.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Error.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -89,11 +89,11 @@
 tiny_string ASError::toString(bool debugMsg)
 {
 	tiny_string ret;
-	if( !message.empty() )
-		ret = name + ": ";
+	ret = name;
 	if(errorID != 0)
-		ret += tiny_string("Error #") + Integer::toString(errorID) + ": ";
-	ret += message;
+		ret += tiny_string(": Error #") + Integer::toString(errorID);
+	if (!message.empty())
+		ret += tiny_string(": ") + message;
 	return ret;
 }
 
@@ -140,10 +140,10 @@
 
 void ASError::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setDeclaredMethodByQName("getStackTrace",AS3,Class<IFunction>::getFunction(getStackTrace),NORMAL_METHOD,true);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_DYNAMIC_NOT_FINAL);
+	c->setDeclaredMethodByQName("getStackTrace","",Class<IFunction>::getFunction(getStackTrace),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	REGISTER_GETTER(c, errorID);
 	REGISTER_GETTER_SETTER(c, message);
 	REGISTER_GETTER_SETTER(c, name);
@@ -177,8 +177,7 @@
 
 void SecurityError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void SecurityError::buildTraits(ASObject* o)
@@ -205,8 +204,7 @@
 
 void ArgumentError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void ArgumentError::buildTraits(ASObject* o)
@@ -233,8 +231,7 @@
 
 void DefinitionError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void DefinitionError::buildTraits(ASObject* o)
@@ -261,8 +258,7 @@
 
 void EvalError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void EvalError::buildTraits(ASObject* o)
@@ -289,8 +285,7 @@
 
 void RangeError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void RangeError::buildTraits(ASObject* o)
@@ -317,8 +312,7 @@
 
 void ReferenceError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void ReferenceError::buildTraits(ASObject* o)
@@ -345,8 +339,7 @@
 
 void SyntaxError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void SyntaxError::buildTraits(ASObject* o)
@@ -373,8 +366,7 @@
 
 void TypeError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void TypeError::buildTraits(ASObject* o)
@@ -401,8 +393,7 @@
 
 void URIError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void URIError::buildTraits(ASObject* o)
@@ -429,8 +420,7 @@
 
 void VerifyError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void VerifyError::buildTraits(ASObject* o)
@@ -457,8 +447,7 @@
 
 void UninitializedError::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASError>::getRef());
+	CLASS_SETUP(c, ASError, _constructor, CLASS_DYNAMIC_NOT_FINAL);
 }
 
 void UninitializedError::buildTraits(ASObject* o)
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Integer.cpp lightspark-0.7.2/src/scripting/toplevel/Integer.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Integer.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Integer.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -17,15 +17,20 @@
     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **************************************************************************/
 
+#include <cmath>
 #include "parsing/amf3_generator.h"
 #include "scripting/argconv.h"
 #include "scripting/toplevel/Integer.h"
+#include "scripting/flash/utils/ByteArray.h"
 
 using namespace std;
 using namespace lightspark;
 
 ASFUNCTIONBODY(Integer,_toString)
 {
+	if(Class<Integer>::getClass()->prototype->getObj() == obj)
+		return Class<ASString>::getInstanceS("0");
+
 	Integer* th=static_cast<Integer*>(obj);
 	int radix=10;
 	if(argslen==1)
@@ -190,13 +195,14 @@
 
 void Integer::sinit(Class_base* c)
 {
-	c->isFinal = true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("MAX_VALUE","",new (c->memoryAccount) Integer(c,numeric_limits<int32_t>::max()),CONSTANT_TRAIT);
 	c->setVariableByQName("MIN_VALUE","",new (c->memoryAccount) Integer(c,numeric_limits<int32_t>::min()),CONSTANT_TRAIT);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(Integer::_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("valueOf",AS3,Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toExponential","",Class<IFunction>::getFunction(Integer::_toExponential, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toFixed","",Class<IFunction>::getFunction(Integer::_toFixed, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toPrecision","",Class<IFunction>::getFunction(Integer::_toPrecision, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(Integer::_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
 }
 
 void Integer::serialize(ByteArray* out, std::map<tiny_string, uint32_t>& stringMap,
@@ -213,7 +219,7 @@
 bool Integer::fromStringFlashCompatible(const char* cur, int64_t& ret, int radix)
 {
 	//Skip whitespace chars
-	while(g_unichar_isspace(g_utf8_get_char(cur)))
+	while(ASString::isEcmaSpace(g_utf8_get_char(cur)))
 		cur = g_utf8_next_char(cur);
 
 	int64_t multiplier=1;
@@ -251,8 +257,42 @@
 	int64_t value;
 	bool valid=Integer::fromStringFlashCompatible(cur, value, 0);
 
-	if(valid==false || value<INT32_MIN || value>INT32_MAX)
+	if (!valid)
 		return 0;
 	else
-		return static_cast<int32_t>(value);
+		return static_cast<int32_t>(value & 0xFFFFFFFF);
+}
+
+ASFUNCTIONBODY(Integer,_toExponential)
+{
+	Integer *th=obj->as<Integer>();
+	double v = (double)th->val;
+	int32_t fractionDigits;
+	ARG_UNPACK(fractionDigits, 0);
+	if (argslen == 0 || args[0]->is<Undefined>())
+	{
+		if (v == 0)
+			fractionDigits = 1;
+		else
+			fractionDigits = imin(imax((int32_t)ceil(::log10(::fabs(v))), 1), 20);
+	}
+	return Class<ASString>::getInstanceS(Number::toExponentialString(v, fractionDigits));
+}
+
+ASFUNCTIONBODY(Integer,_toFixed)
+{
+	Integer *th=obj->as<Integer>();
+	int fractiondigits;
+	ARG_UNPACK (fractiondigits, 0);
+	return Class<ASString>::getInstanceS(Number::toFixedString(th->val, fractiondigits));
+}
+
+ASFUNCTIONBODY(Integer,_toPrecision)
+{
+	Integer *th=obj->as<Integer>();
+	if (argslen == 0 || args[0]->is<Undefined>())
+		return Class<ASString>::getInstanceS(th->toString());
+	int precision;
+	ARG_UNPACK (precision);
+	return Class<ASString>::getInstanceS(Number::toPrecisionString(th->val, precision));
 }
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Integer.h lightspark-0.7.2/src/scripting/toplevel/Integer.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/Integer.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Integer.h	2013-11-09 19:23:31.000000000 +0200
@@ -49,6 +49,9 @@
 	ASFUNCTION(_constructor);
 	ASFUNCTION(generator);
 	ASFUNCTION(_valueOf);
+	ASFUNCTION(_toExponential);
+	ASFUNCTION(_toFixed);
+	ASFUNCTION(_toPrecision);
 	std::string toDebugString() { return toString()+"i"; }
 	//Serialization interface
 	void serialize(ByteArray* out, std::map<tiny_string, uint32_t>& stringMap,
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/JSON.cpp lightspark-0.7.2/src/scripting/toplevel/JSON.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/JSON.cpp	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/JSON.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,774 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "scripting/argconv.h"
+#include "scripting/toplevel/JSON.h"
+
+using namespace std;
+using namespace lightspark;
+
+JSON::JSON(Class_base* c):ASObject(c)
+{
+}
+
+
+void JSON::sinit(Class_base* c)
+{
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	c->setDeclaredMethodByQName("parse","",Class<IFunction>::getFunction(_parse,2),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("stringify","",Class<IFunction>::getFunction(_stringify,3),NORMAL_METHOD,false);
+}
+void JSON::buildTraits(ASObject* o)
+{
+}
+ASFUNCTIONBODY(JSON,_constructor)
+{
+	throwError<ArgumentError>(kCantInstantiateError);
+	return NULL;
+}
+ASFUNCTIONBODY(JSON,generator)
+{
+	throwError<ArgumentError>(kCoerceArgumentCountError);
+	return NULL;
+}
+
+ASFUNCTIONBODY(JSON,_parse)
+{
+	tiny_string text;
+	IFunction* reviver = NULL;
+
+	if (argslen > 0 && (args[0]->is<Null>() ||args[0]->is<Undefined>()))
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+	ARG_UNPACK(text);
+	if (argslen > 1)
+	{
+		if (!args[1]->is<IFunction>())
+			throwError<TypeError>(kCheckTypeFailedError);
+		reviver = args[1]->as<IFunction>();
+	}
+	ASObject* res = NULL;
+	multiname dummy(NULL);
+	
+	parseAll(text,&res,dummy,reviver);
+	return res;
+}
+
+ASFUNCTIONBODY(JSON,_stringify)
+{
+	_NR<ASObject> value;
+	ARG_UNPACK(value);
+	if (value->has_toJSON())
+		return Class<ASString>::getInstanceS(value->call_toJSON());
+	std::vector<ASObject *> path;
+	tiny_string filter;
+	IFunction* replacer = NULL;
+	if (argslen > 1 && !args[1]->is<Null>() && !args[1]->is<Undefined>())
+	{
+		if (args[1]->is<IFunction>())
+		{
+			replacer = args[1]->as<IFunction>();
+		}
+		else if (args[1]->is<Array>())
+		{
+			filter = " ";
+			Array* ar = args[1]->as<Array>();
+			for (uint64_t i = 0; i < ar->size(); i++)
+			{
+				filter += ar->at(i)->toString();
+				filter += " ";
+			}
+		}
+		else
+			throwError<TypeError>(kJSONInvalidReplacer);
+	}
+
+	tiny_string spaces = "";
+	if (argslen > 2)
+	{
+		ASObject* space = args[2];
+		spaces = "          ";
+		if (space->is<Number>() || space->is<Integer>() || space->is<UInteger>())
+		{
+			int32_t v = space->toInt();
+			if (v < 0) v = 0;
+			if (v > 10) v = 10;
+			spaces = spaces.substr_bytes(0,v);
+		}
+		else if (space->is<Boolean>() || space->is<Null>())
+		{
+			spaces = "";
+		}
+		else
+		{
+			if(space->has_toString())
+			{
+				_R<ASObject> ret = space->call_toString();
+				spaces = ret->toString();
+			}
+			else
+				spaces = space->toString();
+			if (spaces.numBytes() > 10)
+				spaces = spaces.substr_bytes(0,10);
+		}
+	}
+	tiny_string res = value->toJSON(path,replacer,spaces,filter);
+
+	return Class<ASString>::getInstanceS(res);
+}
+void JSON::parseAll(const tiny_string &jsonstring, ASObject** parent , const multiname& key, IFunction *reviver)
+{
+	int len = jsonstring.numBytes();
+	int pos = 0;
+	while (pos < len)
+	{
+		if (*parent && (*parent)->isPrimitive())
+			throwError<SyntaxError>(kJSONInvalidParseInput);
+		pos = parse(jsonstring, pos, parent , key, reviver);
+		while (jsonstring.charAt(pos) == ' ' ||
+			   jsonstring.charAt(pos) == '\t' ||
+			   jsonstring.charAt(pos) == '\n' ||
+			   jsonstring.charAt(pos) == '\r'
+			   )
+			pos++;
+	}
+}
+int JSON::parse(const tiny_string &jsonstring, int pos, ASObject** parent , const multiname& key, IFunction *reviver)
+{
+	while (jsonstring.charAt(pos) == ' ' ||
+		   jsonstring.charAt(pos) == '\t' ||
+		   jsonstring.charAt(pos) == '\n' ||
+		   jsonstring.charAt(pos) == '\r'
+		   )
+		   pos++;
+	int len = jsonstring.numBytes();
+	if (pos < len)
+	{
+		char c = jsonstring.charAt(pos);
+		switch(c)
+		{
+			case '{':
+				pos = parseObject(jsonstring,pos,parent,key, reviver);
+				break;
+			case '[': 
+				pos = parseArray(jsonstring,pos,parent,key, reviver);
+				break;
+			case '"':
+				pos = parseString(jsonstring,pos,parent,key);
+				break;
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+			case '-':
+				pos = parseNumber(jsonstring,pos,parent,key);
+				break;
+			case 't':
+				pos = parseTrue(jsonstring,pos,parent,key);
+				break;
+			case 'f':
+				pos = parseFalse(jsonstring,pos,parent,key);
+				break;
+			case 'n':
+				pos = parseNull(jsonstring,pos,parent,key);
+				break;
+			default:
+				throwError<SyntaxError>(kJSONInvalidParseInput);
+		}
+	}
+	if (reviver)
+	{
+		bool haskey = key.name_type!= multiname::NAME_OBJECT;
+		ASObject* params[2];
+		
+		if (haskey)
+		{
+			params[0] = Class<ASString>::getInstanceS(key.normalizedName());
+			if ((*parent)->hasPropertyByMultiname(key,true,false))
+			{
+				params[1] = (*parent)->getVariableByMultiname(key).getPtr();
+				params[1]->incRef();
+			}
+			else
+				params[1] = getSys()->getNullRef();
+		}
+		else
+		{
+			params[0] = Class<ASString>::getInstanceS("");
+			params[1] = *parent;
+			params[1]->incRef();
+		}
+
+		ASObject *funcret=reviver->call(getSys()->getNullRef(), params, 2);
+		if(funcret)
+		{
+			if (haskey)
+			{
+				if (funcret->is<Undefined>())
+				{
+					(*parent)->deleteVariableByMultiname(key);
+					funcret->decRef();
+				}
+				else
+				{
+					(*parent)->setVariableByMultiname(key,funcret,ASObject::CONST_NOT_ALLOWED);
+				}
+			}
+			else 
+				*parent= funcret;
+		}
+	}
+	return pos;
+}
+int JSON::parseTrue(const tiny_string &jsonstring, int pos,ASObject** parent,const multiname& key)
+{
+	int len = jsonstring.numBytes();
+	if (len >= pos+4)
+	{
+		if (jsonstring.charAt(pos) == 't' && 
+				jsonstring.charAt(pos + 1) == 'r' &&
+				jsonstring.charAt(pos + 2) == 'u' && 
+				jsonstring.charAt(pos + 3) == 'e')
+		{
+			pos += 4;
+			if (*parent == NULL)
+				*parent = abstract_b(true);
+			else 
+				(*parent)->setVariableByMultiname(key,abstract_b(true),ASObject::CONST_NOT_ALLOWED);
+		}
+		else
+			throwError<SyntaxError>(kJSONInvalidParseInput);
+	}
+	else
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+	return pos;
+}
+int JSON::parseFalse(const tiny_string &jsonstring, int pos,ASObject** parent,const multiname& key)
+{
+	int len = jsonstring.numBytes();
+	if (len >= pos+5)
+	{
+		if (jsonstring.charAt(pos) == 'f' && 
+				jsonstring.charAt(pos + 1) == 'a' &&
+				jsonstring.charAt(pos + 2) == 'l' && 
+				jsonstring.charAt(pos + 3) == 's' && 
+				jsonstring.charAt(pos + 4) == 'e')
+		{
+			pos += 5;
+			if (*parent == NULL)
+				*parent = abstract_b(false);
+			else 
+				(*parent)->setVariableByMultiname(key,abstract_b(false),ASObject::CONST_NOT_ALLOWED);
+		}
+		else
+			throwError<SyntaxError>(kJSONInvalidParseInput);
+	}
+	else
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+	return pos;
+}
+int JSON::parseNull(const tiny_string &jsonstring, int pos,ASObject** parent,const multiname& key)
+{
+	int len = jsonstring.numBytes();
+	if (len >= pos+4)
+	{
+		if (jsonstring.charAt(pos) == 'n' && 
+				jsonstring.charAt(pos + 1) == 'u' &&
+				jsonstring.charAt(pos + 2) == 'l' && 
+				jsonstring.charAt(pos + 3) == 'l')
+		{
+			pos += 4;
+			if (*parent == NULL)
+				*parent = getSys()->getNullRef();
+			else 
+				(*parent)->setVariableByMultiname(key,getSys()->getNullRef(),ASObject::CONST_NOT_ALLOWED);
+		}
+		else
+			throwError<SyntaxError>(kJSONInvalidParseInput);
+	}
+	else
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+	return pos;
+}
+int JSON::parseString(const tiny_string &jsonstring, int pos,ASObject** parent,const multiname& key, tiny_string* result)
+{
+	pos++; // ignore starting quotes
+	int len = jsonstring.numChars();
+	if (pos >= len)
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+
+	tiny_string sub = jsonstring.substr(pos,len-pos);
+	
+	tiny_string res;
+	bool done = false;
+	for (CharIterator it=sub.begin(); it!=sub.end(); it++)
+	{
+		pos++;
+		if (*it == '\"')
+		{
+			done = true;
+			break;
+		}
+		else if(*it == '\\')
+		{
+			it++;
+			pos++;
+			if(it == sub.end())
+				break;
+			if(*it == '\"')
+				res += '\"';
+			else if(*it == '\\')
+				res += '\\';
+			else if(*it == '/')
+				res += '/';
+			else if(*it == 'b')
+				res += '\b';
+			else if(*it == 'f')
+				res += '\f';
+			else if(*it == 'n')
+				res += '\n';
+			else if(*it == 'r')
+				res += '\r';
+			else if(*it == 't')
+				res += '\t';
+			else if(*it == 'u')
+			{
+				tiny_string strhex;
+				for (int i = 0; i < 4; i++)
+				{
+					it++; pos++; 
+					if (it==sub.end()) 
+						throwError<SyntaxError>(kJSONInvalidParseInput);
+					switch(*it)
+					{
+						case '0':
+						case '1':
+						case '2':
+						case '3':
+						case '4':
+						case '5':
+						case '6':
+						case '7':
+						case '8':
+						case '9':
+						case 'a':
+						case 'b':
+						case 'c':
+						case 'd':
+						case 'e':
+						case 'f':
+						case 'A':
+						case 'B':
+						case 'C':
+						case 'D':
+						case 'E':
+						case 'F':
+							strhex += *it;
+							break;
+						default:
+							throwError<SyntaxError>(kJSONInvalidParseInput);
+					}
+					if (it==sub.end()) 
+						throwError<SyntaxError>(kJSONInvalidParseInput);
+				}
+				int64_t hexnum;
+				if (Integer::fromStringFlashCompatible(strhex.raw_buf(),hexnum,16))
+				{
+					if (hexnum < 0x20 && hexnum != 0xf)
+						throwError<SyntaxError>(kJSONInvalidParseInput);
+					res += tiny_string::fromChar(hexnum);
+				}
+				else
+					break;
+			}
+			else
+				throwError<SyntaxError>(kJSONInvalidParseInput);
+		}
+		else if (*it < 0x20)
+		{
+			throwError<SyntaxError>(kJSONInvalidParseInput);
+		}
+		else
+		{
+			res += *it;
+		}
+	}
+	if (!done)
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+	
+	if (parent != NULL)
+	{
+		if (*parent == NULL)
+			*parent = Class<ASString>::getInstanceS(res);
+		else 
+			(*parent)->setVariableByMultiname(key,Class<ASString>::getInstanceS(res),ASObject::CONST_NOT_ALLOWED);
+	}
+	if (result)
+		*result =res;
+	return pos;
+}
+int JSON::parseNumber(const tiny_string &jsonstring, int pos, ASObject** parent, const multiname& key)
+{
+	int len = jsonstring.numBytes();
+	tiny_string res;
+	bool done = false;
+	while (!done && pos < len)
+	{
+		char c = jsonstring.charAt(pos);
+		switch(c)
+		{
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+			case '-':
+			case '+':
+			case '.':
+			case 'E':
+			case 'e':
+				res += c;
+				pos++;
+				break;
+			default:
+				done = true;
+				break;
+		}
+	}
+	ASString* numstr = Class<ASString>::getInstanceS(res);
+	number_t num = numstr->toNumber();
+
+	if (std::isnan(num))
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+
+	if (*parent == NULL)
+		*parent = Class<Number>::getInstanceS(num);
+	else 
+	{
+		(*parent)->setVariableByMultiname(key,Class<Number>::getInstanceS(num),ASObject::CONST_NOT_ALLOWED);
+	}
+	return pos;
+}
+int JSON::parseObject(const tiny_string &jsonstring, int pos,ASObject** parent,const multiname& key, IFunction *reviver)
+{
+	int len = jsonstring.numChars();
+	pos++; // ignore '{' or ','
+	ASObject* subobj = Class<ASObject>::getInstanceS();
+	if (*parent == NULL)
+		*parent = subobj;
+	else 
+		(*parent)->setVariableByMultiname(key,subobj,ASObject::CONST_NOT_ALLOWED);
+	multiname name(NULL);
+	name.name_type=multiname::NAME_STRING;
+	name.ns.push_back(nsNameAndKind("",NAMESPACE));
+	name.isAttribute = false;
+	bool done = false;
+	bool bfirst = true;
+	bool needkey = true;
+	bool needvalue = false;
+
+	while (!done && pos < len)
+	{
+		while (jsonstring.charAt(pos) == ' ' ||
+			   jsonstring.charAt(pos) == '\t' ||
+			   jsonstring.charAt(pos) == '\n' ||
+			   jsonstring.charAt(pos) == '\r'
+			   )
+			pos++;
+		char c = jsonstring.charAt(pos);
+		switch(c)
+		{
+			case '}':
+				if (!bfirst && (needkey || needvalue))
+					throwError<SyntaxError>(kJSONInvalidParseInput);
+				done = true;
+				pos++;
+				break;
+			case '\"':
+				{
+					tiny_string keyname;
+					pos = parseString(jsonstring,pos,NULL,name,&keyname);
+					name.name_s_id=getSys()->getUniqueStringId(keyname);
+					needkey = false;
+					needvalue = true;
+				}
+				break;
+			case ',':
+				if (needkey || needvalue)
+					throwError<SyntaxError>(kJSONInvalidParseInput);
+				pos++;
+				name.name_s_id=0;
+				needkey = true;
+				break;
+			case ':':
+				pos++;
+				pos = parse(jsonstring,pos,&subobj,name,reviver);
+				needvalue = false;
+				break;
+			default:
+				throwError<SyntaxError>(kJSONInvalidParseInput);
+		}
+		bfirst=false;
+	}
+	if (!done)
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+
+	return pos;
+}
+
+int JSON::parseArray(const tiny_string &jsonstring, int pos, ASObject** parent, const multiname& key, IFunction *reviver)
+{
+	int len = jsonstring.numChars();
+	pos++; // ignore '['
+	ASObject* subobj = Class<Array>::getInstanceS();
+	if (*parent == NULL)
+		*parent = subobj;
+	else 
+		(*parent)->setVariableByMultiname(key,subobj,ASObject::CONST_NOT_ALLOWED);
+	multiname name(NULL);
+	name.name_type=multiname::NAME_INT;
+	name.name_i = 0;
+	name.ns.push_back(nsNameAndKind("",NAMESPACE));
+	name.isAttribute = false;
+	bool done = false;
+	while (!done && pos < len)
+	{
+		while (jsonstring.charAt(pos) == ' ' ||
+			   jsonstring.charAt(pos) == '\t' ||
+			   jsonstring.charAt(pos) == '\n' ||
+			   jsonstring.charAt(pos) == '\r'
+			   )
+			pos++;
+		char c = jsonstring.charAt(pos);
+		switch(c)
+		{
+			case ']':
+				done = true;
+				pos++;
+				break;
+			case ',':
+				name.name_i++;
+				pos++;
+				break;
+			default:
+				pos = parse(jsonstring,pos,&subobj,name, reviver);
+				break;
+		}
+	}
+	if (!done)
+		throwError<SyntaxError>(kJSONInvalidParseInput);
+
+	return pos;
+}
+
+
+
+
+/***** 
+
+static QString sanitizeString(QString str)
+{
+        str.replace(QLatin1String("\\"), QLatin1String("\\\\"));
+        str.replace(QLatin1String("\""), QLatin1String("\\\""));
+        str.replace(QLatin1String("\b"), QLatin1String("\\b"));
+        str.replace(QLatin1String("\f"), QLatin1String("\\f"));
+        str.replace(QLatin1String("\n"), QLatin1String("\\n"));
+        str.replace(QLatin1String("\r"), QLatin1String("\\r"));
+        str.replace(QLatin1String("\t"), QLatin1String("\\t"));
+        return QString(QLatin1String("\"%1\"")).arg(str);
+}
+
+static QByteArray join(const QList<QByteArray> &list, const QByteArray &sep)
+{
+        QByteArray res;
+        Q_FOREACH(const QByteArray &i, list)
+        {
+                if(!res.isEmpty())
+                {
+                        res += sep;
+                }
+                res += i;
+        }
+        return res;
+}
+
+
+
+static DSVariantList parseArray(const QString &json, int &index, bool &success)
+{
+        DSVariantList list;
+
+        nextToken(json, index);
+
+        bool done = false;
+        while(!done)
+        {
+                int token = lookAhead(json, index);
+
+                if(token == JsonTokenNone)
+                {
+                        success = false;
+                        return DSVariantList();
+                }
+                else if(token == JsonTokenComma)
+                {
+                        nextToken(json, index);
+                }
+                else if(token == JsonTokenSquaredClose)
+                {
+                        nextToken(json, index);
+                        break;
+                }
+                else
+                {
+                        QVariant value = parseValue(json, index, success);
+
+                        if(!success)
+                        {
+                            return DSVariantList();
+                        }
+
+                        list.push_back(value);
+                }
+        }
+
+        return list;
+}
+
+
+static QVariant parseNumber(const QString &json, int &index)
+{
+        eatWhitespace(json, index);
+
+        int lastIndex = lastIndexOfNumber(json, index);
+        int charLength = (lastIndex - index) + 1;
+        QString numberStr;
+
+        numberStr = json.mid(index, charLength);
+
+        index = lastIndex + 1;
+
+        if (numberStr.contains('.')) {
+                return QVariant(numberStr.toDouble(NULL));
+        } else if (numberStr.startsWith('-')) {
+                return QVariant(numberStr.toLongLong(NULL));
+        } else {
+                return QVariant(numberStr.toULongLong(NULL));
+        }
+}
+
+static int lastIndexOfNumber(const QString &json, int index)
+{
+        int lastIndex;
+
+        for(lastIndex = index; lastIndex < json.size(); lastIndex++)
+        {
+                if(QString("0123456789+-.eE").indexOf(json[lastIndex]) == -1)
+                {
+                        break;
+                }
+        }
+
+        return lastIndex -1;
+}
+
+
+
+static int lookAhead(const QString &json, int index)
+{
+        int saveIndex = index;
+        return nextToken(json, saveIndex);
+}
+
+static int nextToken(const QString &json, int &index)
+{
+        eatWhitespace(json, index);
+
+        if(index == json.size())
+        {
+                return JsonTokenNone;
+        }
+
+        QChar c = json[index];
+        index++;
+        switch(c.toLatin1())
+        {
+                case '{': return JsonTokenCurlyOpen;
+                case '}': return JsonTokenCurlyClose;
+                case '[': return JsonTokenSquaredOpen;
+                case ']': return JsonTokenSquaredClose;
+                case ',': return JsonTokenComma;
+                case '"': return JsonTokenString;
+                case '0': case '1': case '2': case '3': case '4':
+                case '5': case '6': case '7': case '8': case '9':
+                case '-': return JsonTokenNumber;
+                case ':': return JsonTokenColon;
+        }
+
+        index--;
+
+        int remainingLength = json.size() - index;
+
+        //True
+        if(remainingLength >= 4)
+        {
+                if (json[index] == 't' && json[index + 1] == 'r' &&
+                        json[index + 2] == 'u' && json[index + 3] == 'e')
+                {
+                        index += 4;
+                        return JsonTokenTrue;
+                }
+        }
+
+        //False
+        if (remainingLength >= 5)
+        {
+                if (json[index] == 'f' && json[index + 1] == 'a' &&
+                        json[index + 2] == 'l' && json[index + 3] == 's' &&
+                        json[index + 4] == 'e')
+                {
+                        index += 5;
+                        return JsonTokenFalse;
+                }
+        }
+
+        //Null
+        if (remainingLength >= 4)
+        {
+                if (json[index] == 'n' && json[index + 1] == 'u' &&
+                        json[index + 2] == 'l' && json[index + 3] == 'l')
+                {
+                        index += 4;
+                        return JsonTokenNull;
+                }
+        }
+
+        return JsonTokenNone;
+}
+*****/
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/JSON.h lightspark-0.7.2/src/scripting/toplevel/JSON.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/JSON.h	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/JSON.h	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,51 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2009-2013  Alessandro Pignotti (a.pignotti@sssup.it)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_TOPLEVEL_JSON_H
+#define SCRIPTING_TOPLEVEL_JSON_H 1
+#include "compat.h"
+#include "asobject.h"
+
+namespace lightspark
+{
+
+class JSON : public ASObject
+{
+public:
+	JSON(Class_base* c);
+	static void sinit(Class_base* c);
+	static void buildTraits(ASObject* o);
+	ASFUNCTION(_constructor);
+	ASFUNCTION(generator);
+	ASFUNCTION(_parse);
+	ASFUNCTION(_stringify);
+private:
+	static void parseAll(const tiny_string &jsonstring, ASObject** parent , const multiname& key, IFunction *reviver);
+	static int parse(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key,IFunction* reviver);
+	static int parseTrue(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key);
+	static int parseFalse(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key);
+	static int parseNull(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key);
+	static int parseString(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key, tiny_string *result = NULL);
+	static int parseNumber(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key);
+	static int parseObject(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key, IFunction *reviver);
+	static int parseArray(const tiny_string &jsonstring, int pos, ASObject **parent, const multiname &key, IFunction *reviver);
+};
+
+}
+#endif /* SCRIPTING_TOPLEVEL_JSON_H */
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Math.cpp lightspark-0.7.2/src/scripting/toplevel/Math.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Math.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Math.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -26,9 +26,7 @@
 
 void Math::sinit(Class_base* c)
 {
-	c->isFinal=true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	// public constants
 	c->setVariableByQName("E","",abstract_d(2.71828182845905),CONSTANT_TRAIT);
 	c->setVariableByQName("LN10","",abstract_d(2.302585092994046),CONSTANT_TRAIT);
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Number.cpp lightspark-0.7.2/src/scripting/toplevel/Number.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Number.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Number.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -20,6 +20,7 @@
 #include "parsing/amf3_generator.h"
 #include "scripting/argconv.h"
 #include "scripting/toplevel/Number.h"
+#include "scripting/flash/utils/ByteArray.h"
 
 using namespace std;
 using namespace lightspark;
@@ -258,9 +259,7 @@
 
 void Number::sinit(Class_base* c)
 {
-	c->isFinal = true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	//Must create and link the number the hard way
 	Number* ninf=new (c->memoryAccount) Number(c, -numeric_limits<double>::infinity());
 	Number* pinf=new (c->memoryAccount) Number(c, numeric_limits<double>::infinity());
@@ -272,10 +271,13 @@
 	c->setVariableByQName("MAX_VALUE","",pmax,CONSTANT_TRAIT);
 	c->setVariableByQName("MIN_VALUE","",pmin,CONSTANT_TRAIT);
 	c->setVariableByQName("NaN","",pnan,CONSTANT_TRAIT);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(Number::_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("toLocaleString",AS3,Class<IFunction>::getFunction(Number::_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("toFixed",AS3,Class<IFunction>::getFunction(Number::toFixed),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("valueOf",AS3,Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
+	c->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(Number::_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toLocaleString","",Class<IFunction>::getFunction(Number::_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toFixed","",Class<IFunction>::getFunction(Number::toFixed, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toExponential","",Class<IFunction>::getFunction(Number::toExponential, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toPrecision","",Class<IFunction>::getFunction(Number::toPrecision, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
 }
 
 ASFUNCTIONBODY(Number,_constructor)
@@ -293,39 +295,190 @@
 ASFUNCTIONBODY(Number,toFixed)
 {
 	number_t val = obj->toNumber();
-	int fractiondigits=0;
+	int fractiondigits;
 	ARG_UNPACK (fractiondigits,0);
+	return Class<ASString>::getInstanceS(toFixedString(val, fractiondigits));
+}
+
+tiny_string Number::toFixedString(double v, int32_t fractiondigits)
+{
 	if (fractiondigits < 0 || fractiondigits > 20)
-		throwError<RangeError>(kInvalidPrecisionError, Integer::toString(fractiondigits));
-	if(std::isnan(val))
-		return  Class<ASString>::getInstanceS("NaN");
+		throwError<RangeError>(kInvalidPrecisionError);
+	if (std::isnan(v))
+		return  "NaN";
+	if (v >= pow(10., 21))
+		return toString(v);
 	number_t fractpart, intpart;
-	if (fractiondigits == 0)
-		val+=0.5;
-	fractpart = modf (val , &intpart);
+	double rounded = v + 0.5*pow(10., -fractiondigits);
+	fractpart = modf(rounded , &intpart);
 
 	tiny_string res("");
-	number_t v = fabs(intpart);
 	char buf[40];
-	snprintf(buf,40,"%ld",int64_t(v));
+	snprintf(buf,40,"%ld",int64_t(fabs(intpart)));
 	res += buf;
 	
 	if (fractiondigits > 0)
 	{
-		int x = fractiondigits;
+		number_t x = fractpart;
 		res += ".";
-		while (fractiondigits) 
+		for (int i=0; i<fractiondigits; i++)
 		{
-			fractpart*=10.0;
-			fractiondigits--;
+			x*=10.0;
+			int n = (int)x;
+			x -= n;
+			res += tiny_string::fromChar('0' + n);
 		}
-		fractpart+=0.5;
-		snprintf(buf,40,"%0*ld",x,int64_t(fractpart));
-		res += buf;
 	}
-	if ( val < 0)
+	if ( v < 0)
 		res = tiny_string::fromChar('-')+res;
-	return Class<ASString>::getInstanceS(res);
+	return res;
+}
+
+ASFUNCTIONBODY(Number,toExponential)
+{
+	Number* th=obj->as<Number>();
+	double v = th->val;
+	int32_t fractionDigits;
+	ARG_UNPACK(fractionDigits, 0);
+	if (argslen == 0 || args[0]->is<Undefined>())
+		fractionDigits = imin(imax(Number::countSignificantDigits(v)-1, 1), 20);
+	return Class<ASString>::getInstanceS(toExponentialString(v, fractionDigits));
+}
+
+tiny_string Number::toExponentialString(double v, int32_t fractionDigits)
+{
+	if (std::isnan(v) || std::isinf(v))
+		return toString(v);
+
+	tiny_string res;
+	if (v < 0)
+	{
+		res = "-";
+		v = -v;
+	}
+
+	if (fractionDigits < 0 || fractionDigits > 20)
+		throwError<RangeError>(kInvalidPrecisionError);
+	
+	char buf[40];
+	snprintf(buf,40,"%.*e", fractionDigits, v);
+	res += buf;
+	res = purgeExponentLeadingZeros(res);
+	return res;
+}
+
+tiny_string Number::purgeExponentLeadingZeros(const tiny_string& exponentialForm)
+{
+	uint32_t i = exponentialForm.find("e");
+	if (i == tiny_string::npos)
+		return exponentialForm;
+
+	tiny_string res;
+	res = exponentialForm.substr(0, i+1);
+
+	i++;
+	if (i >= exponentialForm.numChars())
+		return res;
+
+	uint32_t c = exponentialForm.charAt(i);
+	if (c == '-' || c == '+')
+	{
+		res += c;
+		i++;
+	}
+
+	bool leadingZero = true;
+	while (i < exponentialForm.numChars())
+	{
+		uint32_t c = exponentialForm.charAt(i);
+		if (!leadingZero || (leadingZero && c != '0'))
+		{
+			res += c;
+			leadingZero = false;
+		}
+
+		i++;
+	}
+
+	if (leadingZero)
+		res += '0';
+
+	return res;
+}
+
+/*
+ * Should return the number of significant decimal digits necessary to
+ * uniquely specify v. The actual implementation is a quick-and-dirty
+ * approximation.
+ */
+int32_t Number::countSignificantDigits(double v) {
+	char buf[40];
+	snprintf(buf,40,"%.20e", v);
+	
+	char *p = &buf[0];
+	while (*p == '0' || *p == '.')
+		p++;
+	
+	int32_t digits = 0;
+	int32_t consecutiveZeros = 0;
+	while ((('0' <= *p && *p <= '9') || *p == '.') && consecutiveZeros < 10)
+	{
+		if (*p != '.')
+			digits++;
+
+		if (*p == '0')
+			consecutiveZeros++;
+		else if (*p != '.')
+			consecutiveZeros = 0;
+		p++;
+	}
+
+	digits -= consecutiveZeros;
+
+	if (digits <= 0)
+		digits = 1;
+
+	return digits;
+}
+
+ASFUNCTIONBODY(Number,toPrecision)
+{
+	Number* th=obj->as<Number>();
+	double v = th->val;
+	if (argslen == 0 || args[0]->is<Undefined>())
+		return Class<ASString>::getInstanceS(toString(v));
+
+	int32_t precision;
+	ARG_UNPACK(precision);
+	return Class<ASString>::getInstanceS(toPrecisionString(v, precision));
+}
+
+tiny_string Number::toPrecisionString(double v, int32_t precision)
+{
+	if (precision < 1 || precision > 21)
+	{
+		throwError<RangeError>(kInvalidPrecisionError);
+		return NULL;
+	}
+	else if (std::isnan(v) || std::isinf(v))
+		return toString(v);
+	else if (::fabs(v) > pow(10., precision))
+		return toExponentialString(v, precision-1);
+	else if (v == 0)
+	{
+		tiny_string zero = "0.";
+		for (int i=0; i<precision; i++)
+			zero += "0";
+		return zero;
+	}
+	else
+	{
+		int n = (int)::ceil(::log10(::fabs(v)));
+		if (n < 0)
+			return toExponentialString(v, precision-1);
+		else
+			return toFixedString(v, precision-n);
+	}
 }
 
 ASFUNCTIONBODY(Number,_valueOf)
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Number.h lightspark-0.7.2/src/scripting/toplevel/Number.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/Number.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Number.h	2013-11-09 19:23:31.000000000 +0200
@@ -34,17 +34,24 @@
 friend class ABCVm;
 private:
 	static void purgeTrailingZeroes(char* buf);
+	static tiny_string purgeExponentLeadingZeros(const tiny_string& exponentialForm);
+	static int32_t countSignificantDigits(double v);
 public:
 	Number(Class_base* c, double v=0.):ASObject(c),val(v){type=T_NUMBER;}
 	static const number_t NaN;
 	double val;
 	ASFUNCTION(_constructor);
 	ASFUNCTION(_toString);
+	ASFUNCTION(toExponential);
+	ASFUNCTION(toPrecision);
 	ASFUNCTION(toFixed);
 	ASFUNCTION(_valueOf);
 	tiny_string toString();
 	static tiny_string toString(number_t val);
 	static tiny_string toStringRadix(number_t val, int radix);
+	static tiny_string toExponentialString(double v, int32_t fractionDigits);
+	static tiny_string toFixedString(double v, int32_t fractionDigits);
+	static tiny_string toPrecisionString(double v, int32_t precision);
 	static bool isInteger(number_t val)
 	{
 		return floor(val) == val;
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/RegExp.cpp lightspark-0.7.2/src/scripting/toplevel/RegExp.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/RegExp.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/RegExp.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -35,12 +35,16 @@
 
 void RegExp::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_DYNAMIC_NOT_FINAL);
+	c->setDeclaredMethodByQName("exec","",Class<IFunction>::getFunction(exec),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("exec",AS3,Class<IFunction>::getFunction(exec),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("test","",Class<IFunction>::getFunction(test),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("test",AS3,Class<IFunction>::getFunction(test),NORMAL_METHOD,true);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("exec","",Class<IFunction>::getFunction(exec),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("exec",AS3,Class<IFunction>::getFunction(exec),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("test","",Class<IFunction>::getFunction(test),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("test",AS3,Class<IFunction>::getFunction(test),DYNAMIC_TRAIT);
 	REGISTER_GETTER(c,dotall);
 	REGISTER_GETTER(c,global);
@@ -257,6 +261,8 @@
 
 ASFUNCTIONBODY(RegExp,_toString)
 {
+	if(Class<RegExp>::getClass()->prototype->getObj() == obj)
+		return Class<ASString>::getInstanceS("/(?:)/");
 	if(!obj->is<RegExp>())
 		throw Class<TypeError>::getInstanceS("RegExp.toString is not generic");
 
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/toplevel.cpp lightspark-0.7.2/src/scripting/toplevel/toplevel.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/toplevel.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/toplevel.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -128,6 +128,18 @@
 	closure_this.reset();
 }
 
+void IFunction::sinit(Class_base* c)
+{
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(IFunction::_toString),DYNAMIC_TRAIT);
+
+	c->setDeclaredMethodByQName("call","",Class<IFunction>::getFunction(IFunction::_call),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("call",AS3,Class<IFunction>::getFunction(IFunction::_call),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("apply","",Class<IFunction>::getFunction(IFunction::apply),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("apply",AS3,Class<IFunction>::getFunction(IFunction::apply),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(IFunction::_getter_length),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(IFunction::_toString),NORMAL_METHOD,false);
+}
+
 ASFUNCTIONBODY_GETTER_SETTER(IFunction,prototype);
 ASFUNCTIONBODY_GETTER(IFunction,length);
 
@@ -206,6 +218,15 @@
 	return Class<ASString>::getInstanceS("function Function() {}");
 }
 
+ASObject* Class<IFunction>::generator(ASObject* const* args, const unsigned int argslen)
+{
+	for(unsigned int i=0;i<argslen;i++)
+		args[i]->decRef();
+	if (argslen > 0)
+		throwError<EvalError>(kFunctionConstructorError);
+	return getNopFunction();
+}
+
 ASObject *IFunction::describeType() const
 {
 	xmlpp::DomParser p;
@@ -832,7 +853,7 @@
 
 tiny_string Class_base::toString()
 {
-	tiny_string ret="[Class ";
+	tiny_string ret="[class ";
 	ret+=class_name.name;
 	ret+="]";
 	return ret;
@@ -990,25 +1011,40 @@
 	Class_base::finalize();
 }
 
-const std::vector<Class_base*>& Class_base::getInterfaces() const
+const std::vector<Class_base*>& Class_base::getInterfaces(bool *alldefined) const
 {
+	if (alldefined)
+		*alldefined = true;
 	if(!interfaces.empty())
 	{
 		//Recursively get interfaces implemented by this interface
-		for(unsigned int i=0;i<interfaces.size();i++)
+		std::vector<multiname>::iterator it = interfaces.begin();
+		while (it !=interfaces.end())
 		{
 			ASObject* target;
 			ASObject* interface_obj=this->context->root->applicationDomain->
-				getVariableAndTargetByMultiname(interfaces[i], target);
-			assert_and_throw(interface_obj && interface_obj->getObjectType()==T_CLASS);
-			Class_base* inter=static_cast<Class_base*>(interface_obj);
-
-			interfaces_added.push_back(inter);
-			//Probe the interface for its interfaces
-			inter->getInterfaces();
+					getVariableAndTargetByMultiname(*it, target);
+			if (interface_obj)
+			{
+				assert_and_throw(interface_obj->getObjectType()==T_CLASS);
+				Class_base* inter=static_cast<Class_base*>(interface_obj);
+				//Probe the interface for its interfaces
+				bool bAllDefinedSub;
+				inter->getInterfaces(&bAllDefinedSub);
+				
+				if (bAllDefinedSub)
+				{
+					interfaces_added.push_back(inter);
+					interfaces.erase(it);
+					continue;
+				}
+				else if (alldefined)
+					*alldefined = false;
+			}
+			else if (alldefined)
+				*alldefined = false;
+			it++;
 		}
-		//Clean the interface vector to save some space
-		interfaces.clear();
 	}
 	return interfaces_added;
 }
@@ -1288,6 +1324,21 @@
 	return ASObject::findSettableImpl(borrowedVariables,name,has_getter);
 }
 
+variable* Class_base::findSettableInPrototype(const multiname& name)
+{
+	Prototype* proto = prototype.getPtr();
+	while(proto)
+	{
+		variable *obj = proto->getObj()->findSettable(name);
+		if (obj)
+			return obj;
+
+		proto = proto->prevPrototype.getPtr();
+	}
+
+	return NULL;
+}
+
 EARLY_BIND_STATUS Class_base::resolveMultinameStatically(const multiname& name) const
 {
 	if(findBorrowedGettable(name)!=NULL)
@@ -1309,11 +1360,10 @@
 
 void ASQName::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("uri","",Class<IFunction>::getFunction(_getURI),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("localName","",Class<IFunction>::getFunction(_getLocalName),GETTER_METHOD,true);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
 }
 
 ASFUNCTIONBODY(ASQName,_constructor)
@@ -1532,8 +1582,7 @@
 
 void Namespace::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("uri","",Class<IFunction>::getFunction(_setURI),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("uri","",Class<IFunction>::getFunction(_getURI),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("prefix","",Class<IFunction>::getFunction(_setPrefix),SETTER_METHOD,true);
@@ -1838,15 +1887,9 @@
 		//addPrototypeGetter and setDeclaredMethodByQName.
 		//Thus we make sure that everything is in order when getFunction() below is called
 		ret->addPrototypeGetter();
-		//copy borrowed traits from ASObject by ourself
-		ASObject::sinit(ret);
-		ret->setDeclaredMethodByQName("call",AS3,Class<IFunction>::getFunction(IFunction::_call),NORMAL_METHOD,true);
-		ret->setDeclaredMethodByQName("apply",AS3,Class<IFunction>::getFunction(IFunction::apply),NORMAL_METHOD,true);
+		IFunction::sinit(ret);
 		ret->setDeclaredMethodByQName("prototype","",Class<IFunction>::getFunction(IFunction::_getter_prototype),GETTER_METHOD,true);
 		ret->setDeclaredMethodByQName("prototype","",Class<IFunction>::getFunction(IFunction::_setter_prototype),SETTER_METHOD,true);
-		ret->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(IFunction::_getter_length),GETTER_METHOD,true);
-		ret->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(IFunction::_toString),DYNAMIC_TRAIT);
-		ret->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(Class_base::_toString),NORMAL_METHOD,false);
 	}
 	else
 		ret=static_cast<Class<IFunction>*>(*retAddr);
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/toplevel.h lightspark-0.7.2/src/scripting/toplevel/toplevel.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/toplevel.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/toplevel.h	2013-11-09 19:23:31.000000000 +0200
@@ -189,7 +189,7 @@
 	void addImplementedInterface(const multiname& i);
 	void addImplementedInterface(Class_base* i);
 	virtual void buildInstanceTraits(ASObject* o) const=0;
-	const std::vector<Class_base*>& getInterfaces() const;
+	const std::vector<Class_base*>& getInterfaces(bool *alldefined = NULL) const;
 	virtual void linkInterface(Class_base* c) const;
 	/*
 	 * Returns true when 'this' is a subclass of 'cls',
@@ -222,6 +222,7 @@
 	}
 	const variable* findBorrowedGettable(const multiname& name) const DLL_LOCAL;
 	variable* findBorrowedSettable(const multiname& name, bool* has_getter=NULL) DLL_LOCAL;
+	variable* findSettableInPrototype(const multiname& name) DLL_LOCAL;
 	EARLY_BIND_STATUS resolveMultinameStatically(const multiname& name) const;
 	const multiname* resolveSlotTypeName(uint32_t slotId) const { /*TODO: implement*/ return NULL; }
 };
@@ -311,6 +312,8 @@
 	IFunction(Class_base *c);
 	virtual IFunction* clone()=0;
 	_NR<ASObject> closure_this;
+
+	static void sinit(Class_base* c);
 public:
 	/* If this is a method, inClass is the class this is defined in.
 	 * If this is a function, inClass == NULL
@@ -488,6 +491,7 @@
 	void buildInstanceTraits(ASObject* o) const
 	{
 	}
+	virtual ASObject* generator(ASObject* const* args, const unsigned int argslen);
 };
 
 class Undefined : public ASObject
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/UInteger.cpp lightspark-0.7.2/src/scripting/toplevel/UInteger.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/UInteger.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/UInteger.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -17,6 +17,7 @@
     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **************************************************************************/
 
+#include <cmath>
 #include "scripting/argconv.h"
 #include "scripting/toplevel/UInteger.h"
 
@@ -115,17 +116,21 @@
 
 void UInteger::sinit(Class_base* c)
 {
-	c->isFinal = true;
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setVariableByQName("MAX_VALUE","",abstract_ui(0xFFFFFFFF),CONSTANT_TRAIT);
 	c->setVariableByQName("MIN_VALUE","",abstract_ui(0),CONSTANT_TRAIT);
-	c->prototype->setVariableByQName("toString",AS3,Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("valueOf",AS3,Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toExponential","",Class<IFunction>::getFunction(_toExponential, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toFixed","",Class<IFunction>::getFunction(_toFixed, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toPrecision","",Class<IFunction>::getFunction(_toPrecision, 1),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(_valueOf),DYNAMIC_TRAIT);
 }
 
 ASFUNCTIONBODY(UInteger,_toString)
 {
+	if(Class<UInteger>::getClass()->prototype->getObj() == obj)
+		return Class<ASString>::getInstanceS("0");
+
 	UInteger* th=static_cast<UInteger*>(obj);
 	uint32_t radix;
 	ARG_UNPACK (radix,10);
@@ -160,3 +165,37 @@
 			return o->isEqual(this);
 	}
 }
+
+ASFUNCTIONBODY(UInteger,_toExponential)
+{
+	UInteger *th=obj->as<UInteger>();
+	double v = (double)th->val;
+	int32_t fractionDigits;
+	ARG_UNPACK(fractionDigits, 0);
+	if (argslen == 0 || args[0]->is<Undefined>())
+	{
+		if (v == 0)
+			fractionDigits = 1;
+		else
+			fractionDigits = imin(imax((int32_t)ceil(::log10(v)), 1), 20);
+	}
+	return Class<ASString>::getInstanceS(Number::toExponentialString(v, fractionDigits));
+}
+
+ASFUNCTIONBODY(UInteger,_toFixed)
+{
+	UInteger *th=obj->as<UInteger>();
+	int fractiondigits;
+	ARG_UNPACK (fractiondigits, 0);
+	return Class<ASString>::getInstanceS(Number::toFixedString(th->val, fractiondigits));
+}
+
+ASFUNCTIONBODY(UInteger,_toPrecision)
+{
+	UInteger *th=obj->as<UInteger>();
+	if (argslen == 0 || args[0]->is<Undefined>())
+		return Class<ASString>::getInstanceS(th->toString());
+	int precision;
+	ARG_UNPACK (precision);
+	return Class<ASString>::getInstanceS(Number::toPrecisionString(th->val, precision));
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/UInteger.h lightspark-0.7.2/src/scripting/toplevel/UInteger.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/UInteger.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/UInteger.h	2013-11-09 19:23:31.000000000 +0200
@@ -49,6 +49,9 @@
 	ASFUNCTION(generator);
 	ASFUNCTION(_toString);
 	ASFUNCTION(_valueOf);
+	ASFUNCTION(_toExponential);
+	ASFUNCTION(_toFixed);
+	ASFUNCTION(_toPrecision);
 	std::string toDebugString() { return toString()+"ui"; }
 	//CHECK: should this have a special serialization?
 };
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Vector.cpp lightspark-0.7.2/src/scripting/toplevel/Vector.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/Vector.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Vector.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -28,31 +28,48 @@
 
 void Vector::sinit(Class_base* c)
 {
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
-	c->setSuper(Class<ASObject>::getRef());
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_FINAL);
 	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(getLength),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(setLength),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("toString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("fixed","",Class<IFunction>::getFunction(getFixed),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("fixed","",Class<IFunction>::getFunction(setFixed),SETTER_METHOD,true);
+	c->setDeclaredMethodByQName("concat","",Class<IFunction>::getFunction(_concat),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("concat",AS3,Class<IFunction>::getFunction(_concat),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("every","",Class<IFunction>::getFunction(every),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("every",AS3,Class<IFunction>::getFunction(every),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("filter","",Class<IFunction>::getFunction(filter),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("filter",AS3,Class<IFunction>::getFunction(filter),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("forEach","",Class<IFunction>::getFunction(forEach),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("forEach",AS3,Class<IFunction>::getFunction(forEach),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("indexOf","",Class<IFunction>::getFunction(indexOf),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("indexOf",AS3,Class<IFunction>::getFunction(indexOf),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("lastIndexOf","",Class<IFunction>::getFunction(lastIndexOf),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("lastIndexOf",AS3,Class<IFunction>::getFunction(lastIndexOf),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("join","",Class<IFunction>::getFunction(join),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("join",AS3,Class<IFunction>::getFunction(join),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("map","",Class<IFunction>::getFunction(_map),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("map",AS3,Class<IFunction>::getFunction(_map),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("pop","",Class<IFunction>::getFunction(_pop),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("pop",AS3,Class<IFunction>::getFunction(_pop),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("push","",Class<IFunction>::getFunction(push),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("push",AS3,Class<IFunction>::getFunction(push),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("reverse","",Class<IFunction>::getFunction(_reverse),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("reverse",AS3,Class<IFunction>::getFunction(_reverse),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("shift","",Class<IFunction>::getFunction(shift),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("shift",AS3,Class<IFunction>::getFunction(shift),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("slice","",Class<IFunction>::getFunction(slice),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("slice",AS3,Class<IFunction>::getFunction(slice),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("some","",Class<IFunction>::getFunction(some),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("some",AS3,Class<IFunction>::getFunction(some),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("sort","",Class<IFunction>::getFunction(_sort),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("sort",AS3,Class<IFunction>::getFunction(_sort),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("splice","",Class<IFunction>::getFunction(splice),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("splice",AS3,Class<IFunction>::getFunction(splice),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("toLocaleString","",Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("toLocaleString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("unshift","",Class<IFunction>::getFunction(unshift),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("unshift",AS3,Class<IFunction>::getFunction(unshift),NORMAL_METHOD,true);
 	
 
@@ -127,10 +144,10 @@
 		Array* a = static_cast<Array*>(args[0]);
 		for(unsigned int i=0;i<a->size();++i)
 		{
-			ASObject* obj = a->at(i).getPtr();
+			_R<ASObject> obj = a->at(i);
 			obj->incRef();
 			//Convert the elements of the array to the type of this vector
-			ret->vec.push_back( type->coerce(obj) );
+			ret->vec.push_back( type->coerce(obj.getPtr()) );
 		}
 		return ret;
 	}
@@ -975,3 +992,11 @@
 
 	return validIndex;
 }
+
+ASObject* Vector::at(unsigned int index, ASObject *defaultValue) const
+{
+	if (index < vec.size())
+		return vec.at(index);
+	else
+		return defaultValue;
+}
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/Vector.h lightspark-0.7.2/src/scripting/toplevel/Vector.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/Vector.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/Vector.h	2013-11-09 19:23:31.000000000 +0200
@@ -71,6 +71,9 @@
         {
                 return vec.at(index);
         }
+	//Get value at index, or return defaultValue (a borrowed
+	//reference) if index is out-of-range
+	ASObject* at(unsigned int index, ASObject *defaultValue) const;
 
 	//Appends an object to the Vector. o is coerced to vec_type.
 	//Takes ownership of o.
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/XML.cpp lightspark-0.7.2/src/scripting/toplevel/XML.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/XML.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/XML.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -32,24 +32,40 @@
 using namespace std;
 using namespace lightspark;
 
-XML::XML(Class_base* c):ASObject(c),node(NULL),constructed(false),ignoreComments(true)
+static bool ignoreComments;
+static bool ignoreProcessingInstructions;
+static bool ignoreWhitespace;
+static uint32_t prettyIndent;
+static bool prettyPrinting;
+
+void setDefaultXMLSettings()
+{
+	ignoreComments = true;
+	ignoreProcessingInstructions = true;
+	ignoreWhitespace = true;
+	prettyIndent = 2;
+	prettyPrinting = true;
+}
+
+XML::XML(Class_base* c):ASObject(c),node(NULL),constructed(false), hasParentNode(false)
 {
 }
 
 XML::XML(Class_base* c,const string& str):ASObject(c),node(NULL),constructed(true)
 {
-	node=buildFromString(str, false);
+	node=buildFromString(str, false,&hasParentNode);
 }
 
 XML::XML(Class_base* c,_R<XML> _r, xmlpp::Node* _n):ASObject(c),root(_r),node(_n),constructed(true)
 {
 	assert(node);
+	hasParentNode = true;
 }
 
 XML::XML(Class_base* c,xmlpp::Node* _n):ASObject(c),constructed(true)
 {
 	assert(_n);
-	node=buildCopy(_n);
+	node=buildCopy(_n,&hasParentNode);
 	assert(node);
 }
 
@@ -61,8 +77,23 @@
 
 void XML::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
+	setDefaultXMLSettings();
+
+	c->setDeclaredMethodByQName("ignoreComments","",Class<IFunction>::getFunction(_getIgnoreComments),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("ignoreComments","",Class<IFunction>::getFunction(_setIgnoreComments),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("ignoreProcessingInstructions","",Class<IFunction>::getFunction(_getIgnoreProcessingInstructions),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("ignoreProcessingInstructions","",Class<IFunction>::getFunction(_setIgnoreProcessingInstructions),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("ignoreWhitespace","",Class<IFunction>::getFunction(_getIgnoreWhitespace),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("ignoreWhitespace","",Class<IFunction>::getFunction(_setIgnoreWhitespace),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("prettyIndent","",Class<IFunction>::getFunction(_getPrettyIndent),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("prettyIndent","",Class<IFunction>::getFunction(_setPrettyIndent),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("prettyPrinting","",Class<IFunction>::getFunction(_getPrettyPrinting),GETTER_METHOD,false);
+	c->setDeclaredMethodByQName("prettyPrinting","",Class<IFunction>::getFunction(_setPrettyPrinting),SETTER_METHOD,false);
+	c->setDeclaredMethodByQName("settings","",Class<IFunction>::getFunction(_getSettings),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("setSettings","",Class<IFunction>::getFunction(_setSettings),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("defaultSettings","",Class<IFunction>::getFunction(_getDefaultSettings),NORMAL_METHOD,false);
+
 	c->prototype->setVariableByQName("toString","",Class<IFunction>::getFunction(_toString),DYNAMIC_TRAIT);
 	c->setDeclaredMethodByQName("toString",AS3,Class<IFunction>::getFunction(_toString),NORMAL_METHOD,true);
 	c->prototype->setVariableByQName("valueOf","",Class<IFunction>::getFunction(valueOf),DYNAMIC_TRAIT);
@@ -81,7 +112,7 @@
 	c->setDeclaredMethodByQName("namespace",AS3,Class<IFunction>::getFunction(_namespace),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("normalize",AS3,Class<IFunction>::getFunction(_normalize),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("descendants",AS3,Class<IFunction>::getFunction(descendants),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("appendChild",AS3,Class<IFunction>::getFunction(appendChild),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("appendChild",AS3,Class<IFunction>::getFunction(_appendChild),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("parent",AS3,Class<IFunction>::getFunction(parent),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("inScopeNamespaces",AS3,Class<IFunction>::getFunction(inScopeNamespaces),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("addNamespace",AS3,Class<IFunction>::getFunction(addNamespace),NORMAL_METHOD,true);
@@ -94,6 +125,7 @@
 	c->setDeclaredMethodByQName("setNamespace",AS3,Class<IFunction>::getFunction(_setNamespace),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("copy",AS3,Class<IFunction>::getFunction(_copy),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("setChildren",AS3,Class<IFunction>::getFunction(_setChildren),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("toJSON",AS3,Class<IFunction>::getFunction(_toJSON),NORMAL_METHOD,true);
 }
 
 ASFUNCTIONBODY(XML,generator)
@@ -146,7 +178,7 @@
 	   args[0]->is<Null>() || 
 	   args[0]->is<Undefined>())
 	{
-		th->node=th->buildFromString("", false);
+		th->node=th->buildFromString("", false,&th->hasParentNode);
 	}
 	else if(args[0]->getClass()->isSubClass(Class<ByteArray>::getClass()))
 	{
@@ -155,7 +187,7 @@
 		ByteArray* ba=Class<ByteArray>::cast(args[0]);
 		uint32_t len=ba->getLength();
 		const uint8_t* str=ba->getBuffer(len, false);
-		th->node=th->buildFromString(std::string((const char*)str,len), false,
+		th->node=th->buildFromString(std::string((const char*)str,len), false,&th->hasParentNode,
 					     getVm()->getDefaultXMLNamespace());
 	}
 	else if(args[0]->is<ASString>() ||
@@ -166,22 +198,22 @@
 	{
 		//By specs, XML constructor will only convert to string Numbers or Booleans
 		//ints are not explicitly mentioned, but they seem to work
-		th->node=th->buildFromString(args[0]->toString(), false,
+		th->node=th->buildFromString(args[0]->toString(), false,&th->hasParentNode,
 					     getVm()->getDefaultXMLNamespace());
 	}
 	else if(args[0]->is<XML>())
 	{
-		th->node=th->buildCopy(args[0]->as<XML>()->node);
+		th->node=th->buildCopy(args[0]->as<XML>()->node,&th->hasParentNode);
 	}
 	else if(args[0]->is<XMLList>())
 	{
 		XMLList *list=args[0]->as<XMLList>();
 		_R<XML> reduced=list->reduceToXML();
-		th->node=th->buildCopy(reduced->node);
+		th->node=th->buildCopy(reduced->node,&th->hasParentNode);
 	}
 	else
 	{
-		th->node=th->buildFromString(args[0]->toString(), false,
+		th->node=th->buildFromString(args[0]->toString(), false,&th->hasParentNode,
 					     getVm()->getDefaultXMLNamespace());
 	}
 	return NULL;
@@ -257,7 +289,7 @@
  	return Class<XMLList>::getInstanceS(ret);
 }
 
-ASFUNCTIONBODY(XML,appendChild)
+ASFUNCTIONBODY(XML,_appendChild)
 {
 	XML* th=Class<XML>::cast(obj);
 	assert_and_throw(argslen==1);
@@ -282,11 +314,24 @@
 		arg=_MR(Class<XML>::getInstanceS(args[0]->toString()));
 	}
 
-	th->node->import_node(arg->node, true);
+	th->appendChild(arg);
 	th->incRef();
 	return th;
 }
 
+void XML::appendChild(_R<XML> newChild)
+{
+	// Work around a text node concatenation bug in libxml++ older
+	// than 2.35.3 by importing manually instead of calling
+	// import_node().
+	xmlNode* imported_node = xmlDocCopyNode(newChild->node->cobj(), node->cobj()->doc, 1);
+	if (!imported_node)
+		return;
+
+	xmlAddChild(node->cobj(), imported_node);
+
+}
+
 /* returns the named attribute in an XMLList */
 ASFUNCTIONBODY(XML,attribute)
 {
@@ -395,7 +440,7 @@
 			//Override the node defined namespaces
 			cNode->nsDef=&localNamespaces.front();
 		}
-		retVal=xmlNodeDump(buf, xmlDoc, cNode, 0, 0);
+		retVal=xmlNodeDump(buf, xmlDoc, cNode, 0, prettyPrinting);
 		//Restore the previously defined namespaces
 		cNode->nsDef=oldNsDef;
 	}
@@ -659,7 +704,11 @@
 {
 	xmlpp::Node *parent=node->get_parent();
 	if (parent)
+	{
+		if (!hasParentNode)
+			return getSys()->getUndefinedRef();
 		return Class<XML>::getInstanceS(getRootNode(), parent);
+	}
 	else
 		return getSys()->getUndefinedRef();
 }
@@ -947,6 +996,19 @@
 	xmlNodeAddContentLen(node->cobj(), BAD_CAST str.raw_buf(), str.numBytes());
 }
 
+void XML::setTextContent(const tiny_string& content)
+{
+	if (getNodeKind() == XML_TEXT_NODE ||
+	    getNodeKind() == XML_ATTRIBUTE_NODE ||
+	    getNodeKind() == XML_COMMENT_NODE ||
+	    getNodeKind() == XML_PI_NODE)
+	{
+		xmlChar *encoded = xmlEncodeSpecialChars(node->cobj()->doc, BAD_CAST content.raw_buf());
+		xmlNodeSetContent(node->cobj(), encoded);
+		xmlFree(encoded);
+	}
+}
+
 void XML::removeAllChildren()
 {
 	xmlpp::Node::NodeList children=node->get_children();
@@ -1298,6 +1360,164 @@
 	return Class<ASString>::getInstanceS(th->toString_priv());
 }
 
+ASFUNCTIONBODY(XML,_getIgnoreComments)
+{
+	return abstract_b(ignoreComments);
+}
+ASFUNCTIONBODY(XML,_setIgnoreComments)
+{
+	assert(args && argslen==1);
+	ignoreComments = Boolean_concrete(args[0]);
+	LOG(LOG_INFO,"ignoreComments handling is not implemented yet");
+	return NULL;
+}
+ASFUNCTIONBODY(XML,_getIgnoreProcessingInstructions)
+{
+	return abstract_b(ignoreProcessingInstructions);
+}
+ASFUNCTIONBODY(XML,_setIgnoreProcessingInstructions)
+{
+	assert(args && argslen==1);
+	ignoreProcessingInstructions = Boolean_concrete(args[0]);
+	LOG(LOG_INFO,"ignoreProcessingInstructions handling is not implemented yet");
+	return NULL;
+}
+ASFUNCTIONBODY(XML,_getIgnoreWhitespace)
+{
+	return abstract_b(ignoreWhitespace);
+}
+ASFUNCTIONBODY(XML,_setIgnoreWhitespace)
+{
+	assert(args && argslen==1);
+	ignoreWhitespace = Boolean_concrete(args[0]);
+	xmlKeepBlanksDefault(ignoreWhitespace ? 0 : 1);
+	return NULL;
+}
+ASFUNCTIONBODY(XML,_getPrettyIndent)
+{
+	return abstract_i(prettyIndent);
+}
+ASFUNCTIONBODY(XML,_setPrettyIndent)
+{
+	assert(args && argslen==1);
+	prettyIndent = args[0]->toInt();
+	xmlThrDefIndentTreeOutput(prettyIndent);
+	return NULL;
+}
+ASFUNCTIONBODY(XML,_getPrettyPrinting)
+{
+	return abstract_b(prettyPrinting);
+}
+ASFUNCTIONBODY(XML,_setPrettyPrinting)
+{
+	assert(args && argslen==1);
+	prettyPrinting = Boolean_concrete(args[0]);
+	return NULL;
+}
+ASFUNCTIONBODY(XML,_getSettings)
+{
+	ASObject* res = Class<ASObject>::getInstanceS();
+	multiname mn(NULL);
+	mn.name_type=multiname::NAME_STRING;
+	mn.ns.push_back(nsNameAndKind("",NAMESPACE));
+	mn.ns.push_back(nsNameAndKind(AS3,NAMESPACE));
+	mn.isAttribute = true;
+
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreComments");
+	res->setVariableByMultiname(mn,abstract_b(ignoreComments),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreProcessingInstructions");
+	res->setVariableByMultiname(mn,abstract_b(ignoreProcessingInstructions),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreWhitespace");
+	res->setVariableByMultiname(mn,abstract_b(ignoreWhitespace),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("prettyIndent");
+	res->setVariableByMultiname(mn,abstract_i(prettyIndent),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("prettyPrinting");
+	res->setVariableByMultiname(mn,abstract_b(prettyPrinting),CONST_NOT_ALLOWED);
+	return res;
+}
+ASFUNCTIONBODY(XML,_setSettings)
+{
+	if (argslen == 0)
+	{
+		setDefaultXMLSettings();
+		return getSys()->getNullRef();
+	}
+	_NR<ASObject> arg0;
+	ARG_UNPACK(arg0);
+	if (arg0->is<Null>() || arg0->is<Undefined>())
+	{
+		setDefaultXMLSettings();
+		return getSys()->getNullRef();
+	}
+	multiname mn(NULL);
+	mn.name_type=multiname::NAME_STRING;
+	mn.ns.push_back(nsNameAndKind("",NAMESPACE));
+	mn.ns.push_back(nsNameAndKind(AS3,NAMESPACE));
+	mn.isAttribute = true;
+	_NR<ASObject> o;
+
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreComments");
+	if (arg0->hasPropertyByMultiname(mn,true,true))
+	{
+		o=arg0->getVariableByMultiname(mn,SKIP_IMPL);
+		ignoreComments = o->toInt();
+	}
+
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreProcessingInstructions");
+	if (arg0->hasPropertyByMultiname(mn,true,true))
+	{
+		o=arg0->getVariableByMultiname(mn,SKIP_IMPL);
+		ignoreProcessingInstructions = o->toInt();
+	}
+
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreWhitespace");
+	if (arg0->hasPropertyByMultiname(mn,true,true))
+	{
+		o=arg0->getVariableByMultiname(mn,SKIP_IMPL);
+		ignoreWhitespace = o->toInt();
+	}
+
+	mn.name_s_id=getSys()->getUniqueStringId("prettyIndent");
+	if (arg0->hasPropertyByMultiname(mn,true,true))
+	{
+		o=arg0->getVariableByMultiname(mn,SKIP_IMPL);
+		prettyIndent = o->toInt();
+	}
+
+	mn.name_s_id=getSys()->getUniqueStringId("prettyPrinting");
+	if (arg0->hasPropertyByMultiname(mn,true,true))
+	{
+		o=arg0->getVariableByMultiname(mn,SKIP_IMPL);
+		prettyPrinting = o->toInt();
+	}
+	return getSys()->getNullRef();
+}
+ASFUNCTIONBODY(XML,_getDefaultSettings)
+{
+	ASObject* res = Class<ASObject>::getInstanceS();
+	multiname mn(NULL);
+	mn.name_type=multiname::NAME_STRING;
+	mn.ns.push_back(nsNameAndKind("",NAMESPACE));
+	mn.ns.push_back(nsNameAndKind(AS3,NAMESPACE));
+	mn.isAttribute = true;
+
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreComments");
+	res->setVariableByMultiname(mn,abstract_b(true),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreProcessingInstructions");
+	res->setVariableByMultiname(mn,abstract_b(true),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("ignoreWhitespace");
+	res->setVariableByMultiname(mn,abstract_b(true),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("prettyIndent");
+	res->setVariableByMultiname(mn,abstract_i(2),CONST_NOT_ALLOWED);
+	mn.name_s_id=getSys()->getUniqueStringId("prettyPrinting");
+	res->setVariableByMultiname(mn,abstract_b(true),CONST_NOT_ALLOWED);
+	return res;
+}
+ASFUNCTIONBODY(XML,_toJSON)
+{
+	return Class<ASString>::getInstanceS("XML");
+}
+
 tiny_string XML::toString_priv()
 {
 	//We have to use vanilla libxml2, libxml++ is not enough
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/XML.h lightspark-0.7.2/src/scripting/toplevel/XML.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/XML.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/XML.h	2013-11-09 19:23:31.000000000 +0200
@@ -45,11 +45,6 @@
 	XMLList* getAllAttributes();
 	void getText(XMLVector& ret);
 	_NR<XML> getRootNode();
-	bool ignoreComments;
-	bool ignoreProcessingInstructions;
-	bool ignoreWhitespace;
-	uint32_t prettyIndent;
-	bool prettyPrinting;
 	/*
 	 * @param name The name of the wanted children, "*" for all children
 	 *
@@ -57,11 +52,15 @@
 	void childrenImpl(XMLVector& ret, const tiny_string& name);
 	void childrenImpl(XMLVector& ret, uint32_t index);
 	tiny_string getNamespacePrefixByURI(const tiny_string& uri, bool create=false);
-        void setLocalName(const tiny_string& localname);
-        void setNamespace(const tiny_string& ns_uri, const tiny_string& ns_prefix="");
+	void setLocalName(const tiny_string& localname);
+	void setNamespace(const tiny_string& ns_uri, const tiny_string& ns_prefix="");
 	void removeAllChildren();
+	// Append node or attribute to this. Concatenates adjacent
+	// text nodes.
+	void appendChild(_R<XML> child);
 	static void normalizeRecursive(xmlpp::Node *node);
 	void addTextContent(const tiny_string& str);
+	bool hasParentNode;
 public:
 	XML(Class_base* c);
 	XML(Class_base* c,const std::string& str);
@@ -79,7 +78,7 @@
 	ASFUNCTION(_copy);
 	ASFUNCTION(attributes);
 	ASFUNCTION(attribute);
-	ASFUNCTION(appendChild);
+	ASFUNCTION(_appendChild);
 	ASFUNCTION(length);
 	ASFUNCTION(localName);
 	ASFUNCTION(name);
@@ -99,6 +98,22 @@
 	ASFUNCTION(_setName);
 	ASFUNCTION(_setNamespace);
 	ASFUNCTION(_setChildren);
+
+	ASFUNCTION(_getIgnoreComments);
+	ASFUNCTION(_setIgnoreComments);
+	ASFUNCTION(_getIgnoreProcessingInstructions);
+	ASFUNCTION(_setIgnoreProcessingInstructions);
+	ASFUNCTION(_getIgnoreWhitespace);
+	ASFUNCTION(_setIgnoreWhitespace);
+	ASFUNCTION(_getPrettyIndent);
+	ASFUNCTION(_setPrettyIndent);
+	ASFUNCTION(_getPrettyPrinting);
+	ASFUNCTION(_setPrettyPrinting);
+	ASFUNCTION(_getSettings);
+	ASFUNCTION(_setSettings);
+	ASFUNCTION(_getDefaultSettings);
+	ASFUNCTION(_toJSON);
+
 	static void buildTraits(ASObject* o){};
 	static void sinit(Class_base* c);
 	void getDescendantsByQName(const tiny_string& name, const tiny_string& ns, XMLVector& ret);
@@ -106,12 +121,13 @@
 	_NR<ASObject> getVariableByMultiname(const multiname& name, GET_VARIABLE_OPTION opt);
 	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype);
 	void setVariableByMultiname(const multiname& name, ASObject* o, CONST_ALLOWED_FLAG allowConst);
+	void setTextContent(const tiny_string& content);
 	tiny_string toString();
 	int32_t toInt();
 	void toXMLString_priv(xmlBufferPtr buf);
 	bool hasSimpleContent() const;
 	bool hasComplexContent() const;
-        xmlElementType getNodeKind() const;
+	xmlElementType getNodeKind() const;
 	ASObject *getParentNode();
 	XML *copy() const;
 	void normalize();
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/XMLList.cpp lightspark-0.7.2/src/scripting/toplevel/XMLList.cpp
--- lightspark-0.7.2.orig/src/scripting/toplevel/XMLList.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/XMLList.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -78,8 +78,7 @@
 
 void XMLList::sinit(Class_base* c)
 {
-	c->setSuper(Class<ASObject>::getRef());
-	c->setConstructor(Class<IFunction>::getFunction(_constructor));
+	CLASS_SETUP(c, ASObject, _constructor, CLASS_SEALED | CLASS_FINAL);
 	c->setDeclaredMethodByQName("length","",Class<IFunction>::getFunction(_getLength),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("attribute",AS3,Class<IFunction>::getFunction(attribute),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("attributes",AS3,Class<IFunction>::getFunction(attributes),NORMAL_METHOD,true);
@@ -100,7 +99,7 @@
 	c->setDeclaredMethodByQName("toXMLString",AS3,Class<IFunction>::getFunction(toXMLString),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("text",AS3,Class<IFunction>::getFunction(text),NORMAL_METHOD,true);
 	REGISTER_XML_DELEGATE(addNamespace);
-	REGISTER_XML_DELEGATE(appendChild);
+	REGISTER_XML_DELEGATE2(appendChild,_appendChild);
 	REGISTER_XML_DELEGATE(childIndex);
 	REGISTER_XML_DELEGATE(inScopeNamespaces);
 	//REGISTER_XML_DELEGATE(insertChildAfter);
@@ -120,7 +119,7 @@
 }
 
 ASFUNCTIONBODY_XML_DELEGATE(addNamespace);
-ASFUNCTIONBODY_XML_DELEGATE(appendChild);
+ASFUNCTIONBODY_XML_DELEGATE(_appendChild);
 ASFUNCTIONBODY_XML_DELEGATE(childIndex);
 ASFUNCTIONBODY_XML_DELEGATE(inScopeNamespaces);
 //ASFUNCTIONBODY_XML_DELEGATE(insertChildAfter);
@@ -183,7 +182,12 @@
 {
 	xmlpp::DomParser parser;
 	std::string default_ns=getVm()->getDefaultXMLNamespace();
-	std::string expanded="<parent xmlns=\"" + default_ns + "\">" + str + "</parent>";
+	std::string xmldecl;
+	std::string str_without_xmldecl = extractXMLDeclaration(str, xmldecl);
+	std::string expanded = xmldecl + 
+		"<parent xmlns=\"" + default_ns + "\">" + 
+		XMLBase::parserQuirks(str_without_xmldecl) + 
+		"</parent>";
 	try
 	{
 		parser.parse_memory(expanded);
@@ -206,6 +210,23 @@
 		nodes.push_back(_MR(Class<XML>::getInstanceS(*it)));
 }
 
+std::string XMLList::extractXMLDeclaration(const std::string& xml, std::string& xmldecl_out)
+{
+	std::string res = xml;
+	xmldecl_out = "";
+	if (xml.compare(0, 4, "<?xml"))
+	{
+		size_t declEnd = xml.find("?>");
+		if (declEnd != xml.npos)
+		{
+			declEnd += 2;
+			xmldecl_out = xml.substr(0, declEnd);
+			res = xml.substr(declEnd);
+		}
+	}
+	return res;
+}
+
 _R<XML> XMLList::reduceToXML() const
 {
 	//Needed to convert XMLList to XML
@@ -554,15 +575,30 @@
 {
 	assert_and_throw(implEnable);
 	unsigned int index=0;
-	if(!Array::isValidMultiname(name,index))
-		return ASObject::setVariableByMultiname(name,o,allowConst);
-
-	XML* newNode=dynamic_cast<XML*>(o);
-	if(newNode==NULL)
-		return ASObject::setVariableByMultiname(name,o,allowConst);
-
-	//Nodes are always added at the end. The requested index are ignored. This is a tested behaviour.
-	nodes.push_back(_MR(newNode));
+	if(Array::isValidMultiname(name,index))
+	{
+		if (index >= nodes.size())
+		{
+			appendSingleNode(o);
+		}
+		else
+		{
+			replace(index, o);
+		}
+	}
+	else if (nodes.size() == 0)
+	{
+		appendSingleNode(o);
+	}
+	else if (nodes.size() == 1)
+	{
+		nodes.pop_back();
+		appendSingleNode(o);
+	}
+	else
+	{
+		// do nothing, see ECMA-357, Section 9.2.1.2
+	}
 }
 
 void XMLList::getDescendantsByQName(const tiny_string& name, const tiny_string& ns, XML::XMLVector& ret)
@@ -620,6 +656,32 @@
 	return false;
 }
 
+void XMLList::appendSingleNode(ASObject *x)
+{
+	LOG(LOG_NOT_IMPLEMENTED, "XMLList::appendSingleNode should set the parent property of the added node");
+
+	if (x->is<XML>())
+	{
+		x->incRef();
+		append(_MR(x->as<XML>()));
+	}
+	else if (x->is<XMLList>())
+	{
+		XMLList *list = x->as<XMLList>();
+		if (list->nodes.size() == 1)
+		{
+			append(list->nodes[0]);
+		}
+		// do nothing, if length != 1. See ECMA-357, Section
+		// 9.2.1.2
+	}
+	else
+	{
+		tiny_string str = x->toString();
+		append(_MR(Class<XML>::getInstanceS(str)));
+	}
+}
+
 void XMLList::append(_R<XML> x)
 {
 	nodes.push_back(x);
@@ -630,6 +692,43 @@
 	nodes.insert(nodes.end(),x->nodes.begin(),x->nodes.end());
 }
 
+void XMLList::replace(unsigned int idx, ASObject *o)
+{
+	if (idx >= nodes.size())
+		return;
+
+	LOG(LOG_NOT_IMPLEMENTED, "XMLList::replace should set the parent property of the added nodes");
+
+	if (nodes[idx]->getNodeKind() == XML_ATTRIBUTE_NODE)
+	{
+		nodes[idx]->setTextContent(o->toString());
+	}
+	else if (o->is<XMLList>())
+	{
+		unsigned int k = 0;
+		vector<_R<XML>, reporter_allocator<_R<XML>>>::iterator it = nodes.begin();
+		while (k < idx && it!=nodes.end())
+		{
+			++k;
+			++it;
+		}
+
+		it = nodes.erase(it);
+
+		XMLList *toAdd = o->as<XMLList>();
+		nodes.insert(it, toAdd->nodes.begin(), toAdd->nodes.end());
+	}
+	else if (o->is<XML>())
+	{
+		o->incRef();
+		nodes[idx] = _MR(o->as<XML>());
+	}
+	else
+	{
+		nodes[idx] = _MR(Class<XML>::getInstanceS(o->toString()));
+	}
+}
+
 tiny_string XMLList::toString_priv() const
 {
 	if(hasSimpleContent())
@@ -749,7 +848,7 @@
 	for (it=nodes.begin(); it!=nodes.end(); ++it)
 	{
 		ASObject *arg0=it->getPtr();
-		ASObject *ret=XML::appendChild(dest, &arg0, 1);
+		ASObject *ret=XML::_appendChild(dest, &arg0, 1);
 		if(ret)
 			ret->decRef();
 	}
diff -Nuar lightspark-0.7.2.orig/src/scripting/toplevel/XMLList.h lightspark-0.7.2/src/scripting/toplevel/XMLList.h
--- lightspark-0.7.2.orig/src/scripting/toplevel/XMLList.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/scripting/toplevel/XMLList.h	2013-11-09 19:23:31.000000000 +0200
@@ -33,7 +33,10 @@
 	bool constructed;
 	tiny_string toString_priv() const;
 	void buildFromString(const std::string& str);
+	std::string extractXMLDeclaration(const std::string& xml, std::string& xmldecl_out);
 	void toXMLString_priv(xmlBufferPtr buf) const;
+	void appendSingleNode(ASObject *x);
+	void replace(unsigned int i, ASObject *x);
 public:
 	XMLList(Class_base* c);
 	/*
@@ -49,7 +52,7 @@
 	ASFUNCTION(_getLength);
 	ASFUNCTION(attribute);
 	ASFUNCTION(attributes);
-	ASFUNCTION(appendChild);
+	ASFUNCTION(_appendChild);
 	ASFUNCTION(child);
 	ASFUNCTION(children);
 	ASFUNCTION(childIndex);
diff -Nuar lightspark-0.7.2.orig/src/swf.cpp lightspark-0.7.2/src/swf.cpp
--- lightspark-0.7.2.orig/src/swf.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/swf.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -52,22 +52,22 @@
 using namespace std;
 using namespace lightspark;
 
-static GStaticPrivate tls_system = G_STATIC_PRIVATE_INIT;
+DEFINE_AND_INITIALIZE_TLS(tls_system);
 SystemState* lightspark::getSys()
 {
-	SystemState* ret = (SystemState*)g_static_private_get(&tls_system);
+	SystemState* ret = (SystemState*)tls_get(&tls_system);
 	return ret;
 }
 
 void lightspark::setTLSSys(SystemState* sys)
 {
-        g_static_private_set(&tls_system,sys,NULL);
+        tls_set(&tls_system,sys);
 }
 
-static GStaticPrivate parse_thread_tls = G_STATIC_PRIVATE_INIT; /* TLS */
+DEFINE_AND_INITIALIZE_TLS(parse_thread_tls);
 ParseThread* lightspark::getParseThread()
 {
-	ParseThread* pt = (ParseThread*)g_static_private_get(&parse_thread_tls);
+	ParseThread* pt = (ParseThread*)tls_get(&parse_thread_tls);
 	assert(pt);
 	return pt;
 }
@@ -1271,7 +1271,7 @@
 
 void ParseThread::execute()
 {
-	g_static_private_set(&parse_thread_tls,this,NULL);
+	tls_set(&parse_thread_tls,this);
 	try
 	{
 		UI8 Signature[4];
@@ -1315,6 +1315,14 @@
 
 void ParseThread::parseSWF(UI8 ver)
 {
+	if (loader && !loader->allowLoadingSWF())
+	{
+		_NR<LoaderInfo> li=loader->getContentLoaderInfo();
+		getVm()->addEvent(li,_MR(Class<SecurityErrorEvent>::getInstanceS(
+			"Cannot import a SWF file when LoaderContext.allowCodeImport is false."))); // 3226
+		return;
+	}
+
 	objectSpinlock.lock();
 	RootMovieClip* root=NULL;
 	if(parsedObject.isNull())
@@ -1333,7 +1341,7 @@
 	}
 	objectSpinlock.unlock();
 
-	std::queue<const ControlTag*> symbolClassTags;
+	std::queue<const ControlTag*> queuedTags;
 	try
 	{
 		parseSWFHeader(root, ver);
@@ -1378,14 +1386,14 @@
 			{
 				case END_TAG:
 				{
-					// The whole frame has been parsed, now execute all queued SymbolClass tags,
+					// The whole frame has been parsed, now execute all queued tags,
 					// in the order in which they appeared in the file.
-					while(!symbolClassTags.empty())
+					while(!queuedTags.empty())
 					{
-						const ControlTag* t=symbolClassTags.front();
+						const ControlTag* t=queuedTags.front();
 						t->execute(root);
 						delete t;
-						symbolClassTags.pop();
+						queuedTags.pop();
 					}
 
 					if(!empty)
@@ -1411,12 +1419,12 @@
 				case SHOW_TAG:
 					// The whole frame has been parsed, now execute all queued SymbolClass tags,
 					// in the order in which they appeared in the file.
-					while(!symbolClassTags.empty())
+					while(!queuedTags.empty())
 					{
-						const ControlTag* t=symbolClassTags.front();
+						const ControlTag* t=queuedTags.front();
 						t->execute(root);
 						delete t;
-						symbolClassTags.pop();
+						queuedTags.pop();
 					}
 
 					root->commitFrame(true);
@@ -1424,13 +1432,14 @@
 					delete tag;
 					break;
 				case SYMBOL_CLASS_TAG:
+				case ACTION_TAG:
 				{
-					// Add symbol class tags to the queue, to be executed when the rest of the 
+					// Add symbol class tags or action to the queue, to be executed when the rest of the 
 					// frame has been parsed. This is to handle invalid SWF files that define ID's
 					// used in the SymbolClass tag only after the tag, which would otherwise result
 					// in "undefined dictionary ID" errors.
 					const ControlTag* stag = static_cast<const ControlTag*>(tag);
-					symbolClassTags.push(stag);
+					queuedTags.push(stag);
 					break;
 				}
 				case CONTROL_TAG:
@@ -1932,6 +1941,14 @@
 	engineData->openPageInBrowser(url, window);
 }
 
+void SystemState::showMouseCursor(bool visible)
+{
+	if (visible)
+		EngineData::runInGtkThread(sigc::mem_fun(engineData, &EngineData::showMouseCursor));
+	else
+		EngineData::runInGtkThread(sigc::mem_fun(engineData, &EngineData::hideMouseCursor));
+}
+
 /* This is run in vm's thread context */
 void RootMovieClip::initFrame()
 {
diff -Nuar lightspark-0.7.2.orig/src/swf.h lightspark-0.7.2/src/swf.h
--- lightspark-0.7.2.orig/src/swf.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/swf.h	2013-11-09 19:23:31.000000000 +0200
@@ -30,6 +30,7 @@
 #include "swftypes.h"
 #include "scripting/flash/display/flashdisplay.h"
 #include "scripting/flash/net/flashnet.h"
+#include "scripting/flash/utils/IntervalManager.h"
 #include "timer.h"
 #include "memory_support.h"
 #include "platforms/engineutils.h"
@@ -429,6 +430,8 @@
 
 	//Opening web pages
 	void openPageInBrowser(const tiny_string& url, const tiny_string& window);
+
+	void showMouseCursor(bool visible);
 };
 
 class ParseThread: public IThreadJob
diff -Nuar lightspark-0.7.2.orig/src/swftypes.cpp lightspark-0.7.2/src/swftypes.cpp
--- lightspark-0.7.2.orig/src/swftypes.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/swftypes.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -162,6 +162,7 @@
 			if(str.empty())
 				return false;
 			index=0;
+			uint64_t parsed = 0;
 			for(auto i=str.begin(); i!=str.end(); ++i)
 			{
 				if (*i == '.' && acceptStringFractions)
@@ -175,14 +176,21 @@
 					for (; i!=str.end(); ++i)
 						if (*i != '0')
 							return false;
-					return true;
+					break;
 				}
 				else if(!i.isdigit())
 					return false;
 
-				index*=10;
-				index+=i.digit_value();
+				parsed*=10;
+				parsed+=i.digit_value();
+				if (parsed > UINT32_MAX)
+					break;
 			}
+
+			if (parsed > UINT32_MAX)
+				return false;
+
+			index = (uint32_t)parsed;
 			break;
 		}
 		//This is already an int, so its good enough
@@ -192,7 +200,7 @@
 			index=name_i;
 			break;
 		case multiname::NAME_NUMBER:
-			if(!Number::isInteger(name_d) || name_d < 0)
+			if(!Number::isInteger(name_d) || name_d < 0 || name_d > UINT32_MAX)
 				return false;
 			index=name_d;
 			break;
@@ -1398,6 +1406,18 @@
 {
 }
 
+FILLSTYLE& FILLSTYLE::operator=(FILLSTYLE r)
+{
+	std::swap(Matrix, r.Matrix);
+	std::swap(Gradient, r.Gradient);
+	std::swap(FocalGradient, r.FocalGradient);
+	std::swap(bitmap, r.bitmap);
+	std::swap(Color, r.Color);
+	std::swap(FillStyleType, r.FillStyleType);
+	std::swap(version, r.version);
+	return *this;
+}
+
 nsNameAndKind::nsNameAndKind(const tiny_string& _name, NS_KIND _kind)
 {
 	nsNameAndKindImpl tmp(_name, _kind);
@@ -1504,3 +1524,26 @@
 
 	return ss.str();
 }
+
+std::istream& lightspark::operator>>(std::istream& stream, SOUNDINFO& v)
+{
+	BitStream bs(stream);
+	UB(2,bs); // reserved
+	v.SyncStop = UB(1,bs);
+	v.SyncNoMultiple = UB(1,bs);
+	v.HasEnvelope = UB(1,bs);
+	v.HasLoops = UB(1,bs);
+	v.HasOutPoint = UB(1,bs);
+	v.HasInPoint = UB(1,bs);
+	if (v.HasInPoint)
+		stream >> v.InPoint;
+	if (v.HasOutPoint)
+		stream >> v.OutPoint;
+	if (v.HasLoops)
+		stream >> v.LoopCount;
+	if (v.HasEnvelope)
+		stream >> v.EnvPoints;
+	// TODO: EnvelopeRecords
+	return stream;
+}
+
diff -Nuar lightspark-0.7.2.orig/src/swftypes.h lightspark-0.7.2/src/swftypes.h
--- lightspark-0.7.2.orig/src/swftypes.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/swftypes.h	2013-11-09 19:23:31.000000000 +0200
@@ -885,6 +885,7 @@
 public:
 	FILLSTYLE(uint8_t v);
 	FILLSTYLE(const FILLSTYLE& r);
+	FILLSTYLE& operator=(FILLSTYLE r);
 	virtual ~FILLSTYLE();
 	MATRIX Matrix;
 	GRADIENT Gradient;
@@ -924,10 +925,10 @@
 class LINESTYLE2
 {
 public:
-	LINESTYLE2(uint8_t v):FillType(v),version(v){}
+	LINESTYLE2(uint8_t v):HasFillFlag(false),FillType(v),version(v){}
 	UB StartCapStyle;
 	UB JointStyle;
-	UB HasFillFlag;
+	bool HasFillFlag;
 	UB NoHScaleFlag;
 	UB NoVScaleFlag;
 	UB PixelHintingFlag;
@@ -1295,6 +1296,21 @@
 	CLIPEVENTFLAGS AllEventFlags;
 };
 
+class SOUNDINFO
+{
+public:
+	UB SyncStop;
+	UB SyncNoMultiple;
+	UB HasEnvelope;
+	UB HasLoops;
+	UB HasOutPoint;
+	UB HasInPoint;
+	UI32_SWF InPoint;
+	UI32_SWF OutPoint;
+	UI16_SWF LoopCount;
+	UI8 EnvPoints;
+};
+
 class RunState
 {
 public:
@@ -1359,7 +1375,7 @@
 std::istream& operator>>(std::istream& stream, CONVOLUTIONFILTER& v);
 std::istream& operator>>(std::istream& stream, COLORMATRIXFILTER& v);
 std::istream& operator>>(std::istream& stream, GRADIENTBEVELFILTER& v);
-
+std::istream& operator>>(std::istream& stream, SOUNDINFO& v);
 
 };
 #endif /* SWFTYPES_H */
diff -Nuar lightspark-0.7.2.orig/src/threading.cpp lightspark-0.7.2/src/threading.cpp
--- lightspark-0.7.2.orig/src/threading.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/threading.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -26,6 +26,33 @@
 
 using namespace lightspark;
 
+#if GLIB_CHECK_VERSION(2, 31, 0)
+
+void lightspark::tls_set(GPrivate *key, gpointer value)
+{
+	g_private_set(key, value);
+}
+
+gpointer lightspark::tls_get(GPrivate *key)
+{
+	return g_private_get(key);
+}
+
+#else
+
+void lightspark::tls_set(GStaticPrivate *key, gpointer value)
+{
+	g_static_private_set(key, value, NULL);
+}
+
+gpointer lightspark::tls_get(GStaticPrivate *key)
+{
+	return g_static_private_get(key);
+}
+
+#endif
+
+
 Semaphore::Semaphore(uint32_t init):value(init)
 {
 }
diff -Nuar lightspark-0.7.2.orig/src/threading.h lightspark-0.7.2/src/threading.h
--- lightspark-0.7.2.orig/src/threading.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/threading.h	2013-11-09 19:23:31.000000000 +0200
@@ -55,6 +55,16 @@
 typedef Mutex Spinlock;
 typedef Mutex::Lock SpinlockLocker;
 
+#if GLIB_CHECK_VERSION(2, 31, 0)
+#define DEFINE_AND_INITIALIZE_TLS(name) static GPrivate (name)
+void tls_set(GPrivate *key, gpointer value);
+gpointer tls_get(GPrivate *key);
+#else
+#define DEFINE_AND_INITIALIZE_TLS(name) static GStaticPrivate (name) = G_STATIC_PRIVATE_INIT
+void tls_set(GStaticPrivate *key, gpointer value);
+gpointer tls_get(GStaticPrivate *key);
+#endif
+
 class DLL_PUBLIC Semaphore
 {
 private:
diff -Nuar lightspark-0.7.2.orig/src/tiny_string.cpp lightspark-0.7.2/src/tiny_string.cpp
--- lightspark-0.7.2.orig/src/tiny_string.cpp	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/tiny_string.cpp	2013-11-09 19:23:31.000000000 +0200
@@ -42,6 +42,78 @@
 	buf[len]='\0';
 }
 
+tiny_string::tiny_string(const char* s,bool copy):_buf_static(),buf(_buf_static),type(READONLY)
+{
+	if(copy)
+		makePrivateCopy(s);
+	else
+	{
+		stringSize=strlen(s)+1;
+		buf=(char*)s; //This is an unsafe conversion, we have to take care of the RO data
+	}
+}
+
+tiny_string::tiny_string(const tiny_string& r):_buf_static(),buf(_buf_static),stringSize(r.stringSize),type(STATIC)
+{
+	//Fast path for static read-only strings
+	if(r.type==READONLY)
+	{
+		type=READONLY;
+		buf=r.buf;
+		return;
+	}
+	if(stringSize > STATIC_SIZE)
+		createBuffer(stringSize);
+	memcpy(buf,r.buf,stringSize);
+}
+
+tiny_string::tiny_string(const std::string& r):_buf_static(),buf(_buf_static),stringSize(r.size()+1),type(STATIC)
+{
+	if(stringSize > STATIC_SIZE)
+		createBuffer(stringSize);
+	memcpy(buf,r.c_str(),stringSize);
+}
+
+tiny_string::~tiny_string()
+{
+	resetToStatic();
+}
+
+tiny_string& tiny_string::operator=(const tiny_string& s)
+{
+	resetToStatic();
+	stringSize=s.stringSize;
+	//Fast path for static read-only strings
+	if(s.type==READONLY)
+	{
+		type=READONLY;
+		buf=s.buf;
+	}
+	else
+	{
+		if(stringSize > STATIC_SIZE)
+			createBuffer(stringSize);
+		memcpy(buf,s.buf,stringSize);
+	}
+	return *this;
+}
+
+tiny_string& tiny_string::operator=(const std::string& s)
+{
+	resetToStatic();
+	stringSize=s.size()+1;
+	if(stringSize > STATIC_SIZE)
+		createBuffer(stringSize);
+	memcpy(buf,s.c_str(),stringSize);
+	return *this;
+}
+
+tiny_string& tiny_string::operator=(const char* s)
+{
+	makePrivateCopy(s);
+	return *this;
+}
+
 tiny_string& tiny_string::operator=(const Glib::ustring& r)
 {
 	resetToStatic();
@@ -123,6 +195,17 @@
 	return *this;
 }
 
+tiny_string& tiny_string::operator+=(const std::string& s)
+{
+	//TODO: optimize
+	return *this += tiny_string(s);
+}
+
+tiny_string& tiny_string::operator+=(uint32_t c)
+{
+	return (*this += tiny_string::fromChar(c));
+}
+
 const tiny_string tiny_string::operator+(const tiny_string& r) const
 {
 	tiny_string ret(*this);
@@ -130,6 +213,218 @@
 	return ret;
 }
 
+const tiny_string tiny_string::operator+(const char* s) const
+{
+	return *this + tiny_string(s);
+}
+
+const tiny_string tiny_string::operator+(const std::string& r) const
+{
+	return *this + tiny_string(r);
+}
+
+bool tiny_string::operator<(const tiny_string& r) const
+{
+	//don't check trailing \0
+	return memcmp(buf,r.buf,std::min(stringSize,r.stringSize))<0;
+}
+
+bool tiny_string::operator>(const tiny_string& r) const
+{
+	//don't check trailing \0
+	return memcmp(buf,r.buf,std::min(stringSize,r.stringSize))>0;
+}
+
+bool tiny_string::operator==(const tiny_string& r) const
+{
+	//The length is checked as an optimization before checking the contents
+	if(stringSize != r.stringSize)
+		return false;
+	//don't check trailing \0
+	return memcmp(buf,r.buf,stringSize-1)==0;
+}
+
+bool tiny_string::operator==(const std::string& r) const
+{
+	//The length is checked as an optimization before checking the contents
+	if(stringSize != r.size()+1)
+		return false;
+	//don't check trailing \0
+	return memcmp(buf,r.c_str(),stringSize-1)==0;
+}
+
+bool tiny_string::operator!=(const std::string& r) const
+{
+	if(stringSize != r.size()+1)
+		return true;
+	//don't check trailing \0
+	return memcmp(buf,r.c_str(),stringSize-1)!=0;
+}
+
+bool tiny_string::operator!=(const tiny_string& r) const
+{
+	return !(*this==r);
+}
+
+bool tiny_string::operator==(const char* r) const
+{
+	return strcmp(buf,r)==0;
+}
+
+bool tiny_string::operator==(const xmlChar* r) const
+{
+	return strcmp(buf,reinterpret_cast<const char*>(r))==0;
+}
+
+bool tiny_string::operator!=(const char* r) const
+{
+	return !(*this==r);
+}
+
+const char* tiny_string::raw_buf() const
+{
+	return buf;
+}
+
+bool tiny_string::empty() const
+{
+	return stringSize == 1;
+}
+
+/* returns the length in bytes, not counting the trailing \0 */
+uint32_t tiny_string::numBytes() const
+{
+	return stringSize-1;
+}
+
+/* returns the length in utf-8 characters, not counting the trailing \0 */
+uint32_t tiny_string::numChars() const
+{
+	//we cannot use g_utf8_strlen, as we may have '\0' inside our string
+	uint32_t len = 0;
+	char* end = buf+numBytes();
+	char* p = buf;
+	while(p < end)
+	{
+		p = g_utf8_next_char(p);
+		++len;
+	}
+	return len;
+}
+
+char* tiny_string::strchr(char c) const
+{
+	//TODO: does this handle '\0' in middle of buf gracefully?
+	return g_utf8_strchr(buf, numBytes(), c);
+}
+
+char* tiny_string::strchrr(char c) const
+{
+	//TODO: does this handle '\0' in middle of buf gracefully?
+	return g_utf8_strrchr(buf, numBytes(), c);
+}
+
+tiny_string::operator std::string() const
+{
+	return std::string(buf,stringSize-1);
+}
+
+bool tiny_string::startsWith(const char* o) const
+{
+	return strncmp(buf,o,strlen(o)) == 0;
+}
+bool tiny_string::endsWith(const char* o) const
+{
+	size_t olen = strlen(o);
+	return (numBytes() >= olen) && 
+		(strncmp(buf+numBytes()-olen,o,olen) == 0);
+}
+
+/* idx is an index of utf-8 characters */
+uint32_t tiny_string::charAt(uint32_t idx) const
+{
+	return g_utf8_get_char(g_utf8_offset_to_pointer(buf,idx));
+}
+
+/* start is an index of characters.
+ * returns index of character */
+uint32_t tiny_string::find(const tiny_string& needle, uint32_t start) const
+{
+	//TODO: omit copy into std::string
+	size_t bytestart = g_utf8_offset_to_pointer(buf,start) - buf;
+	size_t bytepos = std::string(*this).find(needle.raw_buf(),bytestart,needle.numBytes());
+	if(bytepos == std::string::npos)
+		return npos;
+	else
+		return g_utf8_pointer_to_offset(buf,buf+bytepos);
+}
+
+uint32_t tiny_string::rfind(const tiny_string& needle, uint32_t start) const
+{
+	//TODO: omit copy into std::string
+	size_t bytestart;
+	if(start == npos)
+		bytestart = std::string::npos;
+	else
+		bytestart = g_utf8_offset_to_pointer(buf,start) - buf;
+
+	size_t bytepos = std::string(*this).rfind(needle.raw_buf(),bytestart,needle.numBytes());
+	if(bytepos == std::string::npos)
+		return npos;
+	else
+		return g_utf8_pointer_to_offset(buf,buf+bytepos);
+}
+
+void tiny_string::makePrivateCopy(const char* s)
+{
+	resetToStatic();
+	stringSize=strlen(s)+1;
+	if(stringSize > STATIC_SIZE)
+		createBuffer(stringSize);
+	strcpy(buf,s);
+}
+
+void tiny_string::createBuffer(uint32_t s)
+{
+	type=DYNAMIC;
+	reportMemoryChange(s);
+	buf=new char[s];
+}
+
+void tiny_string::resizeBuffer(uint32_t s)
+{
+	assert(type==DYNAMIC);
+	char* oldBuf=buf;
+	reportMemoryChange(s-stringSize);
+	buf=new char[s];
+	assert(s >= stringSize);
+	memcpy(buf,oldBuf,stringSize);
+	delete[] oldBuf;
+}
+
+void tiny_string::resetToStatic()
+{
+	if(type==DYNAMIC)
+	{
+		reportMemoryChange(-stringSize);
+		delete[] buf;
+	}
+	stringSize=1;
+	_buf_static[0] = '\0';
+	buf=_buf_static;
+	type=STATIC;
+}
+
+tiny_string tiny_string::fromChar(uint32_t c)
+{
+	tiny_string ret;
+	ret.buf = ret._buf_static;
+	ret.type = STATIC;
+	ret.stringSize = g_unichar_to_utf8(c,ret.buf) + 1;
+	ret.buf[ret.stringSize-1] = '\0';
+	return ret;
+}
+
 tiny_string& tiny_string::replace(uint32_t pos1, uint32_t n1, const tiny_string& o )
 {
 	assert(pos1 <= numChars());
@@ -202,6 +497,94 @@
 	return res;
 }
 
+tiny_string tiny_string::lowercase() const
+{
+	// have to loop manually, because g_utf8_strdown doesn't
+	// handle nul-chars
+	tiny_string ret;
+	uint32_t allocated = 2*numBytes()+7;
+	ret.createBuffer(allocated);
+	char *p = ret.buf;
+	char *pend = ret.buf + allocated;
+	uint32_t len = 0;
+	for (CharIterator it=begin(); it!=end(); it++)
+	{
+		assert(pend-p >= 6);
+		gunichar c = g_unichar_tolower(*it);
+		gint n = g_unichar_to_utf8(c, p);
+		p += n;
+		len += n;
+	}
+	*p = '\0';
+	ret.stringSize = len+1;
+	return ret;
+}
+
+tiny_string tiny_string::uppercase() const
+{
+	// have to loop manually, because g_utf8_strup doesn't
+	// handle nul-chars
+	tiny_string ret;
+	uint32_t allocated = 2*numBytes()+7;
+	ret.createBuffer(allocated);
+	char *p = ret.buf;
+	char *pend = ret.buf + allocated;
+	uint32_t len = 0;
+	for (CharIterator it=begin(); it!=end(); it++)
+	{
+		assert(pend-p >= 6);
+		gunichar c = g_unichar_toupper(*it);
+		gint n = g_unichar_to_utf8(c, p);
+		p += n;
+		len += n;
+	}
+	*p = '\0';
+	ret.stringSize = len+1;
+	return ret;
+}
+
+/* like strcasecmp(s1.raw_buf(),s2.raw_buf()) but for unicode
+ * TODO: slow! */
+int tiny_string::strcasecmp(tiny_string& s2) const
+{
+	char* str1 = g_utf8_casefold(this->raw_buf(),this->numBytes());
+	char* str2 = g_utf8_casefold(s2.raw_buf(),s2.numBytes());
+	int ret = g_utf8_collate(str1,str2);
+	g_free(str1);
+	g_free(str2);
+	return ret;
+}
+
+uint32_t tiny_string::bytePosToIndex(uint32_t bytepos) const
+{
+	if (bytepos >= numBytes())
+		return numChars();
+
+	return g_utf8_pointer_to_offset(raw_buf(), raw_buf() + bytepos);
+}
+
+CharIterator tiny_string::begin()
+{
+	return CharIterator(buf);
+}
+
+CharIterator tiny_string::begin() const
+{
+	return CharIterator(buf);
+}
+
+CharIterator tiny_string::end()
+{
+	//points to the trailing '\0' byte
+	return CharIterator(buf+numBytes());
+}
+
+CharIterator tiny_string::end() const
+{
+	//points to the trailing '\0' byte
+	return CharIterator(buf+numBytes());
+}
+
 #ifdef MEMORY_USAGE_PROFILING
 void tiny_string::reportMemoryChange(int32_t change) const
 {
diff -Nuar lightspark-0.7.2.orig/src/tiny_string.h lightspark-0.7.2/src/tiny_string.h
--- lightspark-0.7.2.orig/src/tiny_string.h	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/src/tiny_string.h	2013-11-09 19:23:31.000000000 +0200
@@ -56,8 +56,8 @@
 	CharIterator operator++(int) // postfix
 	{
 		CharIterator result = *this;
-	    ++(*this);
-	    return result;
+		++(*this);
+		return result;
 	}
 	bool operator==(const CharIterator& o) const
 	{
@@ -83,7 +83,7 @@
  * The string can contain '\0's, so don't use raw_buf().
  * Use len() to determine actual size.
  */
-class tiny_string
+class DLL_PUBLIC tiny_string
 {
 friend std::ostream& operator<<(std::ostream& s, const tiny_string& r);
 private:
@@ -105,224 +105,52 @@
 	void reportMemoryChange(int32_t change) const {}
 #endif
 	//TODO: use static buffer again if reassigning to short string
-	void makePrivateCopy(const char* s)
-	{
-		resetToStatic();
-		stringSize=strlen(s)+1;
-		if(stringSize > STATIC_SIZE)
-			createBuffer(stringSize);
-		strcpy(buf,s);
-	}
-	void createBuffer(uint32_t s)
-	{
-		type=DYNAMIC;
-		reportMemoryChange(s);
-		buf=new char[s];
-	}
-	void resizeBuffer(uint32_t s)
-	{
-		assert(type==DYNAMIC);
-		char* oldBuf=buf;
-		reportMemoryChange(s-stringSize);
-		buf=new char[s];
-		assert(s >= stringSize);
-		memcpy(buf,oldBuf,stringSize);
-		delete[] oldBuf;
-	}
-	void resetToStatic()
-	{
-		if(type==DYNAMIC)
-		{
-			reportMemoryChange(-stringSize);
-			delete[] buf;
-		}
-		stringSize=1;
-		_buf_static[0] = '\0';
-		buf=_buf_static;
-		type=STATIC;
-	}
+	void makePrivateCopy(const char* s);
+	void createBuffer(uint32_t s);
+	void resizeBuffer(uint32_t s);
+	void resetToStatic();
 public:
 	static const uint32_t npos = (uint32_t)(-1);
 
 	tiny_string():_buf_static(),buf(_buf_static),stringSize(1),type(STATIC){buf[0]=0;}
 	/* construct from utf character */
-	static tiny_string fromChar(uint32_t c)
-	{
-		tiny_string ret;
-		ret.buf = ret._buf_static;
-		ret.type = STATIC;
-		ret.stringSize = g_unichar_to_utf8(c,ret.buf) + 1;
-		ret.buf[ret.stringSize-1] = '\0';
-		return ret;
-	}
-	tiny_string(const char* s,bool copy=false):_buf_static(),buf(_buf_static),type(READONLY)
-	{
-		if(copy)
-			makePrivateCopy(s);
-		else
-		{
-			stringSize=strlen(s)+1;
-			buf=(char*)s; //This is an unsafe conversion, we have to take care of the RO data
-		}
-	}
-	tiny_string(const tiny_string& r):_buf_static(),buf(_buf_static),stringSize(r.stringSize),type(STATIC)
-	{
-		//Fast path for static read-only strings
-		if(r.type==READONLY)
-		{
-			type=READONLY;
-			buf=r.buf;
-			return;
-		}
-		if(stringSize > STATIC_SIZE)
-			createBuffer(stringSize);
-		memcpy(buf,r.buf,stringSize);
-	}
-	tiny_string(const std::string& r):_buf_static(),buf(_buf_static),stringSize(r.size()+1),type(STATIC)
-	{
-		if(stringSize > STATIC_SIZE)
-			createBuffer(stringSize);
-		memcpy(buf,r.c_str(),stringSize);
-	}
+	static tiny_string fromChar(uint32_t c);
+	tiny_string(const char* s,bool copy=false);
+	tiny_string(const tiny_string& r);
+	tiny_string(const std::string& r);
 	tiny_string(const Glib::ustring& r);
 	tiny_string(std::istream& in, int len);
-	~tiny_string()
-	{
-		resetToStatic();
-	}
-	tiny_string& operator=(const tiny_string& s)
-	{
-		resetToStatic();
-		stringSize=s.stringSize;
-		//Fast path for static read-only strings
-		if(s.type==READONLY)
-		{
-			type=READONLY;
-			buf=s.buf;
-		}
-		else
-		{
-			if(stringSize > STATIC_SIZE)
-				createBuffer(stringSize);
-			memcpy(buf,s.buf,stringSize);
-		}
-		return *this;
-	}
-	tiny_string& operator=(const std::string& s)
-	{
-		resetToStatic();
-		stringSize=s.size()+1;
-		if(stringSize > STATIC_SIZE)
-			createBuffer(stringSize);
-		memcpy(buf,s.c_str(),stringSize);
-		return *this;
-	}
-	tiny_string& operator=(const char* s)
-	{
-		makePrivateCopy(s);
-		return *this;
-	}
+	~tiny_string();
+	tiny_string& operator=(const tiny_string& s);
+	tiny_string& operator=(const std::string& s);
+	tiny_string& operator=(const char* s);
 	tiny_string& operator=(const Glib::ustring& s);
 	tiny_string& operator+=(const char* s);
 	tiny_string& operator+=(const tiny_string& r);
-	tiny_string& operator+=(const std::string& s)
-	{
-		//TODO: optimize
-		return *this += tiny_string(s);
-	}
+	tiny_string& operator+=(const std::string& s);
 	tiny_string& operator+=(const Glib::ustring& s);
-	tiny_string& operator+=(uint32_t c)
-	{
-		return (*this += tiny_string::fromChar(c));
-	}
+	tiny_string& operator+=(uint32_t c);
 	const tiny_string operator+(const tiny_string& r) const;
-	const tiny_string operator+(const char* s) const
-	{
-		return *this + tiny_string(s);
-	}
-	const tiny_string operator+(const std::string& r) const
-	{
-		return *this + tiny_string(r);
-	}
+	const tiny_string operator+(const char* s) const;
+	const tiny_string operator+(const std::string& r) const;
 	const tiny_string operator+(const Glib::ustring& r) const;
-	bool operator<(const tiny_string& r) const
-	{
-		//don't check trailing \0
-		return memcmp(buf,r.buf,std::min(stringSize,r.stringSize))<0;
-	}
-	bool operator>(const tiny_string& r) const
-	{
-		//don't check trailing \0
-		return memcmp(buf,r.buf,std::min(stringSize,r.stringSize))>0;
-	}
-	bool operator==(const tiny_string& r) const
-	{
-		//The length is checked as an optimization before checking the contents
-		if(stringSize != r.stringSize)
-			return false;
-		//don't check trailing \0
-		return memcmp(buf,r.buf,stringSize-1)==0;
-	}
-	bool operator==(const std::string& r) const
-	{
-		//The length is checked as an optimization before checking the contents
-		if(stringSize != r.size()+1)
-			return false;
-		//don't check trailing \0
-		return memcmp(buf,r.c_str(),stringSize-1)==0;
-	}
-	bool operator!=(const std::string& r) const
-	{
-		if(stringSize != r.size()+1)
-			return true;
-		//don't check trailing \0
-		return memcmp(buf,r.c_str(),stringSize-1)!=0;
-	}
-	bool operator!=(const tiny_string& r) const
-	{
-		return !(*this==r);
-	}
-	bool operator==(const char* r) const
-	{
-		return strcmp(buf,r)==0;
-	}
-	bool operator==(const xmlChar* r) const
-	{
-		return strcmp(buf,reinterpret_cast<const char*>(r))==0;
-	}
-	bool operator!=(const char* r) const
-	{
-		return !(*this==r);
-	}
+	bool operator<(const tiny_string& r) const;
+	bool operator>(const tiny_string& r) const;
+	bool operator==(const tiny_string& r) const;
+	bool operator==(const std::string& r) const;
+	bool operator!=(const std::string& r) const;
+	bool operator!=(const tiny_string& r) const;
+	bool operator==(const char* r) const;
+	bool operator==(const xmlChar* r) const;
+	bool operator!=(const char* r) const;
 	bool operator==(const Glib::ustring&) const;
 	bool operator!=(const Glib::ustring&) const;
-	const char* raw_buf() const
-	{
-		return buf;
-	}
-	bool empty() const
-	{
-		return stringSize == 1;
-	}
+	const char* raw_buf() const;
+	bool empty() const;
 	/* returns the length in bytes, not counting the trailing \0 */
-	uint32_t numBytes() const
-	{
-		return stringSize-1;
-	}
+	uint32_t numBytes() const;
 	/* returns the length in utf-8 characters, not counting the trailing \0 */
-	uint32_t numChars() const
-	{
-		//we cannot use g_utf8_strlen, as we may have '\0' inside our string
-		uint32_t len = 0;
-		char* end = buf+numBytes();
-		char* p = buf;
-		while(p < end)
-		{
-			p = g_utf8_next_char(p);
-			++len;
-		}
-		return len;
-	}
+	uint32_t numChars() const;
 	/* start and len are indices of utf8-characters */
 	tiny_string substr(uint32_t start, uint32_t len) const;
 	tiny_string substr(uint32_t start, const CharIterator& end) const;
@@ -330,113 +158,33 @@
 	tiny_string substr_bytes(uint32_t start, uint32_t len) const;
 	/* finds the first occurence of char in the utf-8 string
 	 * Return NULL if not found, else ptr to beginning of first occurence of c */
-	char* strchr(char c) const
-	{
-		//TODO: does this handle '\0' in middle of buf gracefully?
-		return g_utf8_strchr(buf, numBytes(), c);
-	}
-	char* strchrr(char c) const
-	{
-		//TODO: does this handle '\0' in middle of buf gracefully?
-		return g_utf8_strrchr(buf, numBytes(), c);
-	}
-	/*explicit*/ operator std::string() const
-	{
-		return std::string(buf,stringSize-1);
-	}
+	char* strchr(char c) const;
+	char* strchrr(char c) const;
+	/*explicit*/ operator std::string() const;
 	operator Glib::ustring() const;
-	bool startsWith(const char* o) const
-	{
-		return strncmp(buf,o,strlen(o)) == 0;
-	}
-        bool endsWith(const char* o) const
-        {
-                size_t olen = strlen(o);
-                return (numBytes() >= olen) && 
-                        (strncmp(buf+numBytes()-olen,o,olen) == 0);
-        }
+	bool startsWith(const char* o) const;
+        bool endsWith(const char* o) const;
 	/* idx is an index of utf-8 characters */
-	uint32_t charAt(uint32_t idx) const
-	{
-		return g_utf8_get_char(g_utf8_offset_to_pointer(buf,idx));
-	}
+	uint32_t charAt(uint32_t idx) const;
 	/* start is an index of characters.
 	 * returns index of character */
-	uint32_t find(const tiny_string& needle, uint32_t start = 0) const
-	{
-		//TODO: omit copy into std::string
-		size_t bytestart = g_utf8_offset_to_pointer(buf,start) - buf;
-		size_t bytepos = std::string(*this).find(needle.raw_buf(),bytestart,needle.numBytes());
-		if(bytepos == std::string::npos)
-			return npos;
-		else
-			return g_utf8_pointer_to_offset(buf,buf+bytepos);
-	}
-	uint32_t rfind(const tiny_string& needle, uint32_t start = npos) const
-	{
-		//TODO: omit copy into std::string
-		size_t bytestart;
-		if(start == npos)
-			bytestart = std::string::npos;
-		else
-			bytestart = g_utf8_offset_to_pointer(buf,start) - buf;
-
-		size_t bytepos = std::string(*this).rfind(needle.raw_buf(),bytestart,needle.numBytes());
-		if(bytepos == std::string::npos)
-			return npos;
-		else
-			return g_utf8_pointer_to_offset(buf,buf+bytepos);
-	}
+	uint32_t find(const tiny_string& needle, uint32_t start = 0) const;
+	uint32_t rfind(const tiny_string& needle, uint32_t start = npos) const;
 	tiny_string& replace(uint32_t pos1, uint32_t n1, const tiny_string& o);
 	tiny_string& replace_bytes(uint32_t bytestart, uint32_t bytenum, const tiny_string& o);
-	tiny_string lowercase() const
-	{
-		//TODO: omit copy, handle \0 in string
-		char *strdown = g_utf8_strdown(buf,numBytes());
-		tiny_string ret(strdown,/*copy:*/true);
-		g_free(strdown);
-		return ret;
-	}
-	tiny_string uppercase() const
-	{
-		//TODO: omit copy, handle \0 in string
-		char *strup = g_utf8_strup(buf,numBytes());
-		tiny_string ret(strup,/*copy:*/true);
-		g_free(strup);
-		return ret;
-	}
-	/* like strcasecmp(s1.raw_buf(),s2.raw_buf()) but for unicode
-	 * TODO: slow! */
-	int strcasecmp(tiny_string& s2) const
-	{
-		char* str1 = g_utf8_casefold(this->raw_buf(),this->numBytes());
-		char* str2 = g_utf8_casefold(s2.raw_buf(),s2.numBytes());
-		int ret = g_utf8_collate(str1,str2);
-		g_free(str1);
-		g_free(str2);
-		return ret;
-	}
+	tiny_string lowercase() const;
+	tiny_string uppercase() const;
+	/* like strcasecmp(s1.raw_buf(),s2.raw_buf()) but for unicode */
+	int strcasecmp(tiny_string& s2) const;
 	/* split string at each occurrence of delimiter character */
 	std::list<tiny_string> split(uint32_t delimiter) const;
+	/* Convert from byte offset to UTF-8 character index */
+	uint32_t bytePosToIndex(uint32_t bytepos) const;
 	/* iterate over utf8 characters */
-	CharIterator begin()
-	{
-		return CharIterator(buf);
-	}
-	CharIterator begin() const
-	{
-		return CharIterator(buf);
-	}
-	CharIterator end()
-	{
-		//points to the trailing '\0' byte
-		return CharIterator(buf+numBytes());
-	}
-	CharIterator end() const
-	{
-		//points to the trailing '\0' byte
-		return CharIterator(buf+numBytes());
-	}
+	CharIterator begin();
+	CharIterator begin() const;
+	CharIterator end();
+	CharIterator end() const;
 };
 
 };
diff -Nuar lightspark-0.7.2.orig/tests/encodeURI_test.mxml lightspark-0.7.2/tests/encodeURI_test.mxml
--- lightspark-0.7.2.orig/tests/encodeURI_test.mxml	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/tests/encodeURI_test.mxml	2013-11-09 19:23:31.000000000 +0200
@@ -14,15 +14,82 @@
 		var encodedStr:String = "0189ABYZabyz;/?:@&=+$,#-_.!~*'()%20%7B%7D&";
 		var lowerEncodedStr:String = "0189ABYZabyz;/?:@&=+$,#-_.!~*'()%20%7b%7d&";
 		Tests.assertEquals(encodedStr, encodeURI(decodedStr), "encodeURI(): standard encodeURI");
+		Tests.assertEquals("a%C3%A4o%C3%B6", encodeURI("aäoö"), "encodeURI(): UTF-8 string");
 		Tests.assertEquals(decodedStr, decodeURI(encodedStr), "deocdeURI(): standard decodeURI");
 		Tests.assertEquals(decodedStr, decodeURI(lowerEncodedStr), "decodeURI(): decode lowercase encoded string");
+		Tests.assertEquals("ABC %3B%2F%3F%3A%40%26%3D%2B%24%2C%23 DEF", decodeURI("ABC%20%3B%2F%3F%3A%40%26%3D%2B%24%2C%23%20DEF"), "decodeURI(): reserved characters are not decoded");
+		Tests.assertEquals("aäoö", decodeURI("a%C3%A4o%C3%B6"), "decodeURI(): UTF-8 string");
+
+		var actual:String = "no exception thrown";
+		try {
+			decodeURI("%3X");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURI(): invalid percent encoding");
+
+		actual = "no exception thrown";
+		try {
+			decodeURI("%C0%80");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURI(): invalid UTF-8 sequence");
+
+		actual = "no exception thrown";
+		try {
+			decodeURI("%C3xyz");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURI(): truncated UTF-8 sequence");
 
 		decodedStr = "0189ABYZabyz;/?:@&=+$,#-_.!~*'() {}&";
 		encodedStr = "0189ABYZabyz%3B%2F%3F%3A%40%26%3D%2B%24%2C%23-_.!~*'()%20%7B%7D%26";
 		lowerEncodedStr = "0189ABYZabyz%3b%2f%3f%3a%40%26%3d%2b%24%2c%23-_.!~*'()%20%7b%7d%26";
 		Tests.assertEquals(encodedStr, encodeURIComponent(decodedStr), "encodeURIComponent(): standard encodeURIComponent");
+		Tests.assertEquals("a%C3%A4o%C3%B6", encodeURIComponent("aäoö"), "encodeURIComponent(): UTF-8 string");
 		Tests.assertEquals(decodedStr, decodeURIComponent(encodedStr), "deocdeURIComponent(): standard decodeURIComponent");
 		Tests.assertEquals(decodedStr, decodeURIComponent(lowerEncodedStr), "decodeURIComponent(): decode lowercase encoded string");
+		Tests.assertEquals("aäoö", decodeURIComponent("a%C3%A4o%C3%B6"), "decodeURIComponent(): UTF-8 string");
+
+		actual = "no exception thrown";
+		try {
+			decodeURIComponent("%3X");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURIComponent(): invalid percent encoding");
+
+		actual = "no exception thrown";
+		try {
+			decodeURIComponent("%C0%80");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURIComponent(): invalid UTF-8 sequence");
+
+		actual = "no exception thrown";
+		try {
+			decodeURIComponent("%C3xyz");
+		} catch (e:URIError) {
+			actual="URIError";
+		} catch (e:Error) {
+			actual = "wrong Error";
+		}
+		Tests.assertEquals("URIError", actual, "decodeURIComponent(): truncated UTF-8 sequence");
+
+
 		Tests.report(visual, this.name);
 	}
 	]]>
diff -Nuar lightspark-0.7.2.orig/tests/make-tamarin lightspark-0.7.2/tests/make-tamarin
--- lightspark-0.7.2.orig/tests/make-tamarin	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/tests/make-tamarin	2013-11-09 19:23:31.000000000 +0200
@@ -5,6 +5,7 @@
 
 TAMARIN=${TAMARIN:-tamarin}
 ASC=${ASC:-`pwd`/asc.jar}
+AVM=${AVM:-${TAMARIN}/objdir/shell/avmshell}
 if [[ ! -d $TAMARIN ]]; then
   echo "Directory tamarin not found, please run"
   echo "hg clone http://hg.mozilla.org/tamarin-redux tamarin"
@@ -23,15 +24,111 @@
   exit 1
 fi
 
-CUR=`pwd`
+export CUR=`pwd`
 
-#cd $TAMARIN/test/acceptance && \
-#rm -f ats_temp.abc ats_temp.as shell.as && \
-#echo "override| -optimize -in $CUR/tamarin-lightspark.as -AS3 -swf 200,200 -in ./ats_temp.as" > dir.asc_args && \
-#./runtests.py --asc $ASC --builtinabc ../../core/builtin.abc --shellabc ../../shell/shell_toplevel.abc --ats --atsdir $CUR/tamarin-SWF || exit 1
-(cd $TAMARIN/test/acceptance && \
-rm -f ats_temp.abc ats_temp.as shell.as && \
-grep USES_SWFVERSION . -R --files-with-matches | xargs --no-run-if-empty rm && \
-echo "override| -optimize -in $CUR/tamarin-lightspark.as -AS3 -swf 200,200 -in ./ats_temp.as" > dir.asc_args && \
-./runtests.py --asc $ASC --builtinabc ../../generated/builtin.abc --shellabc ../../generated/shell_toplevel.abc --ats --atsdir $CUR/tamarin-SWF $1) \
-|| echo "Compiling tests failed. Make sure you have the latest tamarin-redux and asc.jar from http://hg.mozilla.org/tamarin-redux and ftp://ftp.mozilla.org/pub/js/tamarin/builds/asc/latest/asc.jar, respectively."
+printCompileErrorAndExit()
+{
+    echo "Compiling tests failed. Make sure you have the latest tamarin-redux and asc.jar from http://hg.mozilla.org/tamarin-redux and ftp://ftp.mozilla.org/pub/js/tamarin/builds/asc/latest/asc.jar, respectively."
+    exit 1;
+}
+
+# compile tests from Tamarin before commit 7555
+makeTamarin1()
+{
+    (cd $TAMARIN/test/acceptance && \
+    rm -f ats_temp.abc ats_temp.as shell.as && \
+    grep USES_SWFVERSION . -R --files-with-matches | xargs --no-run-if-empty rm && \
+    echo "override| -optimize -in $CUR/tamarin-lightspark.as -AS3 -swf 200,200 -in ./ats_temp.as" > dir.asc_args && \
+    ./runtests.py --asc $ASC --builtinabc ../../generated/builtin.abc --shellabc ../../generated/shell_toplevel.abc --ats --atsdir $CUR/tamarin-SWF $1) \
+    || printCompileErrorAndExit;
+}
+
+# compile tests from Tamarin commit 7555 and later
+makeTamarin2()
+{
+    if [[ ! -f $AVM ]]; then
+        echo "Set shell variable AVM to point to avmshell executable"
+        exit 1
+    fi
+
+    java -jar $ASC -import $TAMARIN/generated/builtin.abc quit.as
+
+    cd $TAMARIN/test/acceptance
+    compiled=$(./runtests.py --asc $ASC --avm $AVM --builtinabc ../../generated/builtin.abc --shellabc ../../generated/shell_toplevel.abc --rebuildtests $1)
+    if [[ $? -ne 0 ]]; then
+        printCompileErrorAndExit;
+    fi
+
+    # The first sed selects lines starting with "compiling" unless the
+    # following lines starts with "Excluding".
+    #
+    # The second sed filters out some strange cases (TODO: check
+    # these!).
+    echo "$compiled" | \
+        sed -n '/^compiling/{N; /\nExcluding/ b excluded; P; D; b; :excluded d}' | \
+        sed -n '/ascompiling\|mmgc\/outofmemory\.as\|mmgc\/memlimit\.as\|bug_515935.as\|abc_$/!p' | \
+        sed -e 's/compiling \(.*\)/\1/' \
+            -e 's/\(.*\.\)[a-z]\+$/\1abc/' | \
+        xargs -L 1 bash -c 'linkTamarinTest $0'
+    cd -
+}
+
+# Sort classes in $TEST_SUPPORT in dependecy order: put interface
+# classes first and sort other classes alphabetically.
+function sortSupportClasses() {
+    local interfaces=$(echo "$TEST_SUPPORT" | tr " " "\n" | grep Interface)
+    local classes=$(echo "$TEST_SUPPORT" | tr " " "\n" | grep -v Interface | sort)
+    TEST_SUPPORT=$(echo "$interfaces $classes" | tr "\n" " ")
+}
+
+# Create a .swf for a Tamarin test case by figuring out which .abc
+# files belong to the test case and merging them.
+# Input: the name of test case's main .abc or .abs file
+function linkTamarinTest() {
+    shouldExcludeTest "$1"
+    local exclude_test=$?
+
+    if [[ -f "$1" && "$exclude_test" -eq 0 ]]; then
+        echo "Linking $1"
+
+        mkdir -p $CUR/tamarin-SWF/$(dirname $1)
+        OUTPUT_SWF="$CUR/tamarin-SWF/${1/%ab[cs]/swf}"
+
+        COMMON="Assert.abc Utils.abc"
+        ABS_SUPPORT=$(if [[ -f ${1/%abc/abs} ]]; then echo abcasm/abs_helper.abc; fi)
+        TEST_SUPPORT=$(if [[ -d ${1/%.abc/} ]]; then echo $(ls ${1/%.abc/}/*.abc 2> /dev/null); fi)
+        sortSupportClasses
+        ABC_FILES="$COMMON $TEST_SUPPORT $ABS_SUPPORT $1 $CUR/quit.abc"
+
+        $CUR/../tools/mergeABCtoSWF $ABC_FILES -o $OUTPUT_SWF
+    elif [[ "$exclude_test" -ne 0 ]]; then
+	echo "Excluding $1"
+    fi
+}
+
+# Exclude testcases that need imports from shell_toplevel (avmplus,
+# avmshell packages) until versioned identifiers are supported.
+function shouldExcludeTest() {
+    local asfile=${1/ab[cs]/as}
+    grep --quiet --no-messages "import avmplus\|import avmshell" "$asfile"
+    if [[ $? -eq 0 ]]; then
+	return 1
+    else
+	return 0
+    fi
+}
+
+export -f linkTamarinTest sortSupportClasses shouldExcludeTest
+
+if [[ "x$1" = "x" ]]; then
+    rm -rf tamarin-SWF/*
+fi
+
+# Tamarin testing framework changed in commit 7555 in a way that is
+# incompatible with previous version of this script. Use Assert.as, a
+# file introduced in that commit, to detect the new test setup.
+if [[ -f $TAMARIN/test/acceptance/Assert.as ]]; then
+    makeTamarin2;
+else
+    makeTamarin1;
+fi
diff -Nuar lightspark-0.7.2.orig/tests/methodNamespace_test.mxml lightspark-0.7.2/tests/methodNamespace_test.mxml
--- lightspark-0.7.2.orig/tests/methodNamespace_test.mxml	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/tests/methodNamespace_test.mxml	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,141 @@
+<?xml version="1.0"?>
+<mx:Application name="lightspark_methodNamespace_test"
+	xmlns:mx="http://www.adobe.com/2006/mxml"
+	layout="absolute"
+	applicationComplete="appComplete();"
+	backgroundColor="white">
+
+<mx:Script>
+	<![CDATA[
+	import Tests;
+	private function appComplete():void
+	{
+		namespace as3_ns = "http://adobe.com/AS3/2006/builtin";
+		namespace public_ns = "";
+
+		testMethods(Object.prototype, "Object prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Object(), "Object instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(String.prototype, "String prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["split", public_ns, "exists"],
+			 ["split", as3_ns, "ReferenceError"]]);
+
+		testMethods(new String(""), "String instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "exists"],
+			 ["split", public_ns, "exists"],
+			 ["split", as3_ns, "exists"]]);
+
+		testMethods(Number.prototype, "Number prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Number(0), "Number instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "exists"]]);
+
+		testMethods(Boolean.prototype, "Boolean prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Boolean(), "Boolean instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "exists"]]);
+
+		testMethods(Function.prototype, "Function prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["call", public_ns, "exists"],
+			 ["call", as3_ns, "exists"]]);
+
+		testMethods(function():void {}, "function instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["call", public_ns, "exists"],
+			 ["call", as3_ns, "exists"]]);
+
+		testMethods(Math, "Math",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(Error, "Error",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Error(), "Error instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(Date, "Date",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Date(), "Date",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "exists"]]);
+
+		testMethods(RegExp.prototype, "RegExp prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["exec", public_ns, "exists"],
+			 ["exec", as3_ns, "exists"]]);
+
+		testMethods(new RegExp(), "RegExp instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["exec", public_ns, "exists"],
+			 ["exec", as3_ns, "exists"]]);
+
+		testMethods(Vector.prototype, "Vector prototype",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "ReferenceError"],
+			 ["every", public_ns, "undefined"],
+			 ["every", as3_ns, "ReferenceError"]]);
+
+		testMethods(new Vector.<int>(), "Vector instance",
+			[["toString", public_ns, "exists"],
+			 ["toString", as3_ns, "exists"],
+			 ["every", public_ns, "exists"],
+			 ["every", as3_ns, "exists"]]);
+
+		Tests.report(visual, this.name);
+	}
+
+	private function testMethods(obj:*, testName:String, methodsAndExpectedResults:Array):void {
+		for (var i:int=0; i<methodsAndExpectedResults.length; i++) {
+			var method:String = methodsAndExpectedResults[i][0];
+			var ns:Namespace = methodsAndExpectedResults[i][1];
+			var expected:String = methodsAndExpectedResults[i][2];
+			var s:String = checkMethodExists(obj, ns, method);
+			var name:String = ns.toString() + "::" + method + " on " + testName;
+			Tests.assertEquals(expected, s, name);
+		}
+	}
+
+	private function checkMethodExists(obj:*, ns:Namespace, method:String):String {
+		var result:String = "exists";
+		try {
+			var f:* = obj.ns::[method];
+			if (f == undefined) {
+			    result = "undefined";
+			}
+		} catch(e:ReferenceError) {
+			result = "ReferenceError";
+		} catch(e:Error) {
+			result = e.toString();
+		}
+		return result;
+	}
+	]]>
+</mx:Script>
+
+<mx:UIComponent id="visual" />
+
+</mx:Application>
diff -Nuar lightspark-0.7.2.orig/tests/quit.as lightspark-0.7.2/tests/quit.as
--- lightspark-0.7.2.orig/tests/quit.as	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/tests/quit.as	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,2 @@
+namespace flashsystemns = "flash.system";
+flashsystemns::fscommand("quit");
diff -Nuar lightspark-0.7.2.orig/tests/tests lightspark-0.7.2/tests/tests
--- lightspark-0.7.2.orig/tests/tests	2013-03-16 13:19:18.000000000 +0200
+++ lightspark-0.7.2/tests/tests	2013-11-09 19:23:31.000000000 +0200
@@ -33,6 +33,56 @@
 JUNITFILE=""
 NOXVFB=0;
 
+# Convert output from local and pre-7555 commit Tamarin testcases to JUnit XML
+function writeJUnit1() {
+	tcnum=0
+	#Find all lines that start with '. [' or 'F [' or 'A ..F.. ['
+	tcnum=$(echo "$1" | sed -n -e "/^\(A \)\?[F\.]\+ \[.*/p" \
+	| { while read L
+	do
+		tcnum=`expr $tcnum + 1`
+		#Escape <>& and remove non-printable characters
+		xml_l=`echo -e "$L" | sed -e 's/[^[:print:]]//g' -e 's/\&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'`
+		#Check if L starts with an 'F' or with 'A ...F'
+		if echo -e "$L" | grep -e "^\(A \.*\)\?F" > /dev/null ; then
+			echo "<testcase classname=\"$2\" name=\"${3}_tc${tcnum}\"><failure type=\"testfailure\">$xml_l</failure></testcase>" >> "$JUNITFILE"
+		else
+			echo "<testcase classname=\"$2\" name=\"${3}_tc${tcnum}\"/>" >> "$JUNITFILE"
+		fi
+	done
+	echo $tcnum
+	})
+
+	if [[ "$tcnum" != "$4" ]]; then
+		echo -e "\nError parsing test output of $test: Not enough testcases seen"
+		exit 1
+	fi
+}
+
+# Convert output from post-7555 commit Tamarin to JUnit XML
+function writeJUnit2() {
+	tcnum=0
+	tcnum=$(echo "$1" | grep 'PASSED!\|FAILED!' \
+	| { while read L
+	do
+		tcnum=`expr $tcnum + 1`
+		#Escape <>& and remove non-printable characters
+		xml_l=`echo -e "$L" | sed -e 's/[^[:print:]]//g' -e 's/\&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'`
+		if echo "$L" | grep 'FAILED!' > /dev/null ; then
+		    echo  "<testcase classname=\"$2\" name=\"${3}_tc${tcnum}\"><failure type=\"testfailure\">$xml_l</failure></testcase>" >> "$JUNITFILE"
+		else
+		    echo "<testcase classname=\"$2\" name=\"${3}_tc${tcnum}\"/>" >> "$JUNITFILE"
+		fi
+	done
+	echo $tcnum
+	})
+
+	if [[ "$tcnum" != "$4" ]]; then
+		echo -e "\nError parsing test output of $test: Not enough testcases seen"
+		exit 1
+	fi
+}
+
 if ! `which timeout > /dev/null`; then
 	echo "Warning: 'timeout' command not found"
 	TIMEOUTCMD=""
@@ -182,7 +232,7 @@
 	echo -e "\n" 1>&2;
 fi
 
-FAILURECOUNT=0; SUCCESSCOUNT=0; TESTCOUNT=0;
+FAILURECOUNT=0; SUCCESSCOUNT=0; TESTCOUNT=0; EXITEDCOUNT=0; ALLSUCCESSCOUNT=0; NOSUMMARYCOUNT=0;
 
 #Colors used for colorization
 CLEAR='\\\e[0m';
@@ -283,15 +333,21 @@
 			fi
 		fi
 		if [[ -n "$JUNITFILE" ]]; then
-			echo "<testcase classname=\"$testclass\" name=\"$testname\"><failure type=\"exitvalue\">Exit Value $ev</failure></testcase>" >> "$JUNITFILE"
+			if [[ "$ev" = "124" ]]; then
+				echo "<testcase classname=\"$testclass\" name=\"$testname\"><failure type=\"timeout\">Timeout</failure></testcase>" >> "$JUNITFILE"
+			else
+				echo "<testcase classname=\"$testclass\" name=\"$testname\"><failure type=\"exitvalue\">Exit Value $ev</failure></testcase>" >> "$JUNITFILE"
+			fi
 		fi
 		FAILURECOUNT=`expr $FAILURECOUNT + 1`;
 		FAILED_TESTS="$FAILED_TESTS $test"
+		EXITEDCOUNT=`expr $EXITEDCOUNT + 1`
 		continue
 	fi
 	#Remove the RANDR error when running under xvfb, convert control characters to something like \303
 	lines=`sed -e '/Xlib:  extension "RANDR" missing on display.*/d' -e 's/[[:cntrl:]]//' $LOGFILE`
 	if [ "`echo $lines | grep '==Failures'`" != "" ]; then
+		# local tests and Tamarin before commit 7555 
 		THISFAILEDCOUNT=`echo "$lines" | sed -n -e 's/.*=Failures (\(.*\)\/.*)=.*/\1/p'`
 		THISNUMTESTS=`echo "$lines" | sed -n -e 's/.*=Failures (.*\/\(.*\))=.*/\1/p'`
 		THISSUCCESSCOUNT=`expr $THISNUMTESTS - $THISFAILEDCOUNT`
@@ -299,9 +355,22 @@
 		SUCCESSCOUNT=`expr $SUCCESSCOUNT + $THISSUCCESSCOUNT`;
 		FAILED_TESTS="$FAILED_TESTS $test"
 	elif [ "`echo $lines | grep '==No failures'`" != "" ]; then
+		# local tests and Tamarin before commit 7555 
 		THISSUCCESSCOUNT=`echo "$lines" | sed -n -e 's/.*=No failures (\(.*\))=.*/\1/p'`
 		THISNUMTESTS="$THISSUCCESSCOUNT"
 		SUCCESSCOUNT=`expr $SUCCESSCOUNT + $THISSUCCESSCOUNT`;
+		ALLSUCCESSCOUNT=`expr $ALLSUCCESSCOUNT + 1`
+	elif [ "`echo $lines | grep 'PASSED!\|FAILED!'`" != "" ]; then
+		# Tamarin commit 7555 and later
+		THISSUCCESSCOUNT=`echo "$lines" | grep -c 'PASSED!'`
+		THISFAILEDCOUNT=`echo "$lines" | grep -c 'FAILED!'`
+		THISNUMTESTS=`expr $THISSUCCESSCOUNT + $THISFAILEDCOUNT`
+		FAILURECOUNT=`expr $FAILURECOUNT + $THISFAILEDCOUNT`;
+		SUCCESSCOUNT=`expr $SUCCESSCOUNT + $THISSUCCESSCOUNT`;
+		FAILED_TESTS="$FAILED_TESTS $test"
+		if [ $THISFAILEDCOUNT -eq 0 ]; then
+			ALLSUCCESSCOUNT=`expr $ALLSUCCESSCOUNT + 1`
+		fi
 	else
 		if [ $COLORS -eq 1 ]; then
 			echo -e "\\e[0;31m$test printed no test summary!\\e[0m"
@@ -313,31 +382,15 @@
 		fi
 		FAILURECOUNT=`expr $FAILURECOUNT + 1`;
 		FAILED_TESTS="$FAILED_TESTS $test"
+		NOSUMMARYCOUNT=`expr $NOSUMMARYCOUNT + 1`
 		continue
 	fi
 
 	if [[ -n "$JUNITFILE" ]]; then
-		#For xml output
-		tcnum=0
-		#Find all lines that start with '. [' or 'F [' or 'A ..F.. ['
-		tcnum=$(echo "$lines" | sed -n -e "/^\(A \)\?[F\.]\+ \[.*/p" \
-		| { while read L
-		do
-			tcnum=`expr $tcnum + 1`
-			#Escape <>& and remove non-printable characters
-			xml_l=`echo -e "$L" | sed -e 's/[^[:print:]]//g' -e 's/\&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'`
-			#Check if L starts with an 'F' or with 'A ...F'
-			if echo -e "$L" | grep -e "^\(A \.*\)\?F" > /dev/null ; then
-				echo "<testcase classname=\"$testclass\" name=\"${testname}_tc${tcnum}\"><failure type=\"testfailure\">$xml_l</failure></testcase>" >> "$JUNITFILE"
-			else
-				echo "<testcase classname=\"$testclass\" name=\"${testname}_tc${tcnum}\"/>" >> "$JUNITFILE"
-			fi
-		done
-		echo $tcnum
-		})
-		if [[ "$tcnum" != "$THISNUMTESTS" ]]; then
-			echo -e "\nError parsing test output of $test: Not enough testcases seen"
-			exit 1
+		if [[ "`echo $lines | grep '==Failures\|==No failures'`" != "" ]]; then
+			writeJUnit1 "$lines" "$testclass" "$testname" "$THISNUMTESTS"
+		else
+			writeJUnit2 "$lines" "$testclass" "$testname" "$THISNUMTESTS"
 		fi
 	fi
 
@@ -399,7 +452,13 @@
 fi
 
 if [ $COLORS -eq 1 ]; then
-	echo -e "Tests run: $TESTCOUNT, \e[1;32m$SUCCESSCOUNT successful\e[0m and \e[1;31m$FAILURECOUNT failed\e[0m" 1>&2
+	echo -e "\e[1;36mTEST SUMMARY:" 1>&2
+	echo -e "$TESTCOUNT tests\e[0m were run, of which \e[1;32m`expr $TESTCOUNT - $EXITEDCOUNT` finished\e[0m and \e[1;31m$EXITEDCOUNT exited prematurely\e[0m." 1>&2
+	echo -e "\e[1;36m`expr $SUCCESSCOUNT + $FAILURECOUNT` single test cases\e[0m were performed: \e[1;32m$SUCCESSCOUNT were successful\e[0m and \e[1;31m$FAILURECOUNT failed\e[0m (\e[1;36m`expr $SUCCESSCOUNT \* 100 / \( $SUCCESSCOUNT + $FAILURECOUNT \)`% success rate\e[0m)." 1>&2
+	echo -e "\e[1;32m$ALLSUCCESSCOUNT tests passed every single test case\e[0m, while \e[1;31m$NOSUMMARYCOUNT didn't print a test summary\e[0m." 1>&2
 else
-	echo -e "Tests run: $TESTCOUNT, $SUCCESSCOUNT successful and $FAILURECOUNT failed" 1>&2
+	echo -e "TEST SUMMARY:" 1>&2
+	echo -e "$TESTCOUNT tests were run, of which `expr $TESTCOUNT - $EXITEDCOUNT` finished and $EXITEDCOUNT exited prematurely." 1>&2
+	echo -e "`expr $SUCCESSCOUNT + $FAILURECOUNT` single test cases were performed: $SUCCESSCOUNT were successful and $FAILURECOUNT failed (`expr $SUCCESSCOUNT \* 100 / \( $SUCCESSCOUNT + $FAILURECOUNT \)`% success rate)." 1>&2
+	echo -e "$ALLSUCCESSCOUNT tests passed every single test case, while $NOSUMMARYCOUNT didn't print a test summary." 1>&2
 fi
diff -Nuar lightspark-0.7.2.orig/tools/mergeABCtoSWF lightspark-0.7.2/tools/mergeABCtoSWF
--- lightspark-0.7.2.orig/tools/mergeABCtoSWF	1970-01-01 02:00:00.000000000 +0200
+++ lightspark-0.7.2/tools/mergeABCtoSWF	2013-11-09 19:23:31.000000000 +0200
@@ -0,0 +1,134 @@
+#!/usr/bin/python
+
+# Copyright (C) 2013 Antti Ajanki (antti.ajanki@iki.fi)
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# This script merges one or more ABC files into a simple SWF wrapper.
+#
+# Usage: mergeABCtoSWF abcFile1 [abcFile2 ...] [-o outputSWFFile]
+#
+# The ABC files should be in dependency order, files that provide
+# functions should be listed before files that use those functions.
+
+import struct
+import sys
+import os.path
+from optparse import OptionParser
+
+class SWFFile:
+    TAG_END = 0
+    TAG_SHOW_FRAME = 1
+    TAG_FILE_ATTRIBUTES = 69
+    TAG_DOABC = 82
+
+    ATTR_HAS_AS3 = 8
+
+    # RECT 8000x6000
+    DEFAULT_RECT = '\x78\x00\x03\xe8\x00\x00\x0b\xb8\x00'
+    
+    def __init__(self, filename):
+        self.file = open(filename, 'wb')
+        self.writeSWFHeader()
+
+    def writeSWFHeader(self):
+        self.file.write('FWS')
+        # version
+        self.file.write(chr(9))
+        # length, will be set in finalize
+        self.file.write('\0'*4)
+        # rect size in twips
+        self.file.write(self.DEFAULT_RECT)
+        # framerate
+        self.writeUI16(20 << 8)
+        # frame count
+        self.writeUI16(1)
+        self.addFileAttributesTag()
+
+    def finalize(self):
+        self.addShowFrameTag()
+        self.addEndTag()
+        self.updateSize()
+        self.file.close()
+        self.file = None
+
+    def addFileAttributesTag(self):
+        body = chr(self.ATTR_HAS_AS3) + '\0'*3
+        self.writeTag(self.TAG_FILE_ATTRIBUTES, body)
+        
+    def addABCBlock(self, abc):
+        body = '\0'*4 # flags
+        body += '\0' # name
+        body += abc
+        self.writeTag(self.TAG_DOABC, body)
+
+    def addShowFrameTag(self):
+        self.writeTag(self.TAG_SHOW_FRAME, '')
+
+    def addEndTag(self):
+        self.file.write('\0\0')
+
+    def writeTag(self, tagType, body):
+        #print 'tag %d at %d length %s' % (tagType, self.file.tell(), len(body))
+        self.writeTagHeader(tagType, len(body))
+        self.file.write(body)
+        
+    def writeTagHeader(self, tagType, tagLength):
+        assert (tagType & 0x3FF) == tagType
+        if tagLength >= 0x3F:
+            self.writeUI16((tagType << 6) | 0x3F)
+            self.writeSI32(tagLength)
+        else:
+            self.writeUI16((tagType << 6) | tagLength)
+        
+    def updateSize(self):
+        size = self.file.tell()
+        self.file.seek(4, 0)
+        self.writeSI32(size)
+        self.file.seek(0, 2)
+
+    def writeUI16(self, value):
+        self.file.write(struct.pack('<H', value))
+
+    def writeSI32(self, value):
+        self.file.write(struct.pack('<i', value))
+
+
+def parseParameters():
+    usage = 'usage: %prog abcFile1 [abcFile2 ...] [-o outputSWFFile]'
+    parser = OptionParser(usage=usage)
+    parser.add_option('-o', dest='output',
+                      help='Name of the output SWF file')
+    (options, abcFiles) = parser.parse_args()
+
+    if not abcFiles:
+        print 'ABC filenames required'
+        sys.exit(1)
+    
+    if options.output:
+        SWF = options.output
+    else:
+        SWF = os.path.splitext(abcFiles[-1])[0] + '.swf'
+    
+    return (abcFiles, SWF)
+
+def main():
+    abcfiles, swfFileName = parseParameters()
+    swf = SWFFile(swfFileName)
+    for abc in abcfiles:
+        swf.addABCBlock(open(abc).read())
+    swf.finalize()
+
+if __name__ == '__main__':
+    main()
